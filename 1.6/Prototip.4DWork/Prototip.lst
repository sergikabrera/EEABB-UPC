file G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS

file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\uLCD-43PT.fnc

000001  000001  #platform "uLCD-43PT"
000002  000001  #platform "uLCD-43PT"
000003  000008  */
000004  000009      #constant uLCD_43PT_GFX2
000005  000009      #constant uLCD_43PT_GFX2
000006  000010        
000007  000011      #IFNOT EXISTS PICASO_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\PicasoFunctions.fnc

000008  000012          #inherit "PicasoFunctions.fnc"        // inherit the generic functions
000009  000012          #inherit "PicasoFunctions.fnc"        // inherit the generic functions
000010  000001        
000011  000002  // Common inheritance for PicasoGFX2 platforms
000012  000003        
000013  000004  #constant PICASO_FUNCTIONS
000014  000004  #constant PICASO_FUNCTIONS
000015  000005        
000016  000006        
000017  000007  #CONST
000018  000017  #END
000019  000018        
000020  000019  #CONST
000021  000025  #END
000022  000026        
000023  000027        
000024  000028  #CONST
000025  000040  #END
000026  000041        
000027  000042        
000028  000043  #CONST
000029  000208  #END
000030  000209        
000031  000210        
000032  000211  // baud divisor rates for setbaud(n);
000033  000212  #CONST
000034  000234  #END
000035  000235        
000036  000236        
000037  000237        
000038  000238        
000039  000243  */
000040  000244        
000041  000245        
000042  000246  //==============================================//
000043  000247  // EVE bios functions                           //
000044  000248  //==============================================//
000045  000249                                                  //
000046  000250  func serin(), 1;                // read a byte from COM0
000047  000251  // Syntax: serin();
000048  000252  // Usage : char := serin();
000049  000253  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
000050  000254  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000051  000255  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000052  000256  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000053  000257  //     : Returns: -1 if no character is available
000054  000258  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
000055  000259  //     : Returns: positive value 0 to 255 for a valid character received
000056  000260        
000057  000261  func putch("char"), 0;                // write single char to current output device
000058  000262  // Syntax: putch("char");
000059  000263  // Usage : putch("A");
000060  000264  // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
000061  000265  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000062  000266  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000063  000267  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000064  000268  //     : The arguments can be a variable, array element, expression or constant
000065  000269        
000066  000270  func serout("char"), 0;                // write a byte to COM0
000067  000271  // Syntax: serout1("char");
000068  000272  // Usage : serout1(ch);
000069  000273  // Notes : send character to COM1
000070  000274        
000071  000275  func setbaud("baudnum"), 0;            // set baud rate of COM0
000072  000276  // Syntax: setbaud(baud_number);
000073  000277  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
000074  000278  // *Notes : argument specifies the baud rate using pre-defined constant.
000075  000279  //       : The pre-defined constant is a value of 0-19 , and internally
000076  000280  //       : this is used as a table pointer to get the baud rate divisor
000077  000281  //       : value for one of the 20 selected baud rates, control is then
000078  000282  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
000079  000283  //       : The pre-defined constants equate to a value of 0-19.
000080  000284  //       : If a value other than 0-19 is used, a run time error (eror 25)
000081  000285  //       : will occur.
000082  000286        
000083  000287  func to("device"), 1;                // output device redirection
000084  000288  // Syntax: to(outstream);
000085  000289  // Usage : to(APPEND); putstr("TWO ");
000086  000290  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000087  000291  //     :
000088  000292  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000089  000293  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000090  000294  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000091  000295  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000092  000296  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000093  000297  //     : completed its action. The APPEND argument is used to send the printed output to the same
000094  000298  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000095  000299  //     : sequential data to a media stream.
000096  000300  //     :
000097  000301  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000098  000302  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000099  000303  //     :                            appended to user memory if previous redirection was to an array.
000100  000304  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000101  000305  //     : TEXT           0xFF08      Output is directed to the screen (default).
000102  000306  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000103  000307  //     : I2C            0xF820      Output is directed to the I2C port.
000104  000308  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000105  000309        
000106  000310        
000107  000311  func pause("milliseconds"), 0;            // blocking delay
000108  000312  // Syntax: pause(milliseconds);
000109  000313  // Usage : pause(1000);                //pause for 1 second
000110  000314  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000111  000315        
000112  000316  func putnum("arg1","arg2"), 1;            // print number to current output device
000113  000317  // Syntax: putnum(format, value);
000114  000318  // Usage : var := putnum(HEX, val);
000115  000319  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000116  000320  //     : Format: A constant that specifies the number format
000117  000321  //     : Value : The number to be printed
000118  000322  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000119  000323  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000120  000324  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000121  000325  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000122  000326  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000123  000327  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000124  000328  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000125  000329  //     :                                     BIN6     BIN6Z     BIN6ZB
000126  000330  //     :                                     BIN7     BIN7Z     BIN7ZB
000127  000331  //     :                                     BIN8     BIN8Z     BIN8ZB
000128  000332  //     :                                     BIN9     BIN9Z     BIN9ZB
000129  000333  //     :                                     BIN10     BIN10Z     BIN10ZB
000130  000334  //     :                                     BIN11     BIN11Z     BIN11ZB
000131  000335  //     :                                     BIN12     BIN12Z     BIN12ZB
000132  000336  //     :                                     BIN13     BIN13Z     BIN13ZB
000133  000337  //     :                                     BIN14     BIN14Z     BIN14ZB
000134  000338  //     :                                     BIN15     BIN15Z     BIN15ZB
000135  000339  //     :                                     BIN16     BIN16Z     BIN16ZB
000136  000340  //     :
000137  000341  //     : bit 15 Leading spaces (1=space before signed number, 0=No space)
000138  000342  //     : bit 14 sign bit (0=signed, 1=unsigned)
000139  000343  //     : bit 13 Blanking (1=Leading zero blanking, 0=Show Zeros)
000140  000344  //     : bit 12 Leading zeros (1=Zeros included, 0=Zeros suppressed)
000141  000345  //     : bits 11-8 Displayed digit quantity
000142  000346  //     : bits 7-5 Reserved
000143  000347  //     : bits 4-0 Number base (usually 2,10 or 16)
000144  000348        
000145  000349        
000146  000350  func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
000147  000351        
000148  000352  func putstr("string"), 1;                       // print string to current output device
000149  000353  // Syntax: putstr(pointer);
000150  000354  // Usage : putstr("HELLO\n");
000151  000355  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000152  000356  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000153  000357  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000154  000358  //       : The output of putstr can be redirected to the communications port, the media, or memory
000155  000359  //       : using the to(...); function.
000156  000360  //       : A string constant is automatically terminated with a zero.
000157  000361  //       : A string in a data statement is not automatically terminated with a zero.
000158  000362  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000159  000363  //       : element packs 1 or 2 characters.
000160  000364        
000161  000365        
000162  000366  func strlen("varAddress"), 1;                   // return length of a var packed string in character units
000163  000367  // Syntax: strlen("varAddress);
000164  000368  // Usage : strlen("HELLO\n");
000165  000369  // Notes : gives the length of a string that is packed into regular var array
000166  000370  //       : Use str_Length(ptr)  for string pointer mode
000167  000371        
000168  000372        
000169  000373  //==============================================//
000170  000374  // Memory Access Function Prototypes            //
000171  000375  //==============================================//
000172  000376                                                  //
000173  000377  func peekW("address"), 1;                       // read a word from system memory
000174  000378  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000175  000379  // refer to address map of internal variables   //
000176  000380  //==============================================//
000177  000381  // Math Functions                               //
000178  000382  //==============================================//
000179  000383                                                  //
000180  000384  func ABS("value"), 1;                           // return a positive number
000181  000385  // Syntax: ABS(value);
000182  000386  // Usage : var := ABS(arg);
000183  000387  // Notes : Returns the absolute value of an argument
000184  000388        
000185  000389  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000186  000390  // Syntax: MIN(value1, value2);
000187  000391  // Usage : var := MIN(arg1, arg2);
000188  000392  // Notes : Returns the minimum of 2 arguments
000189  000393        
000190  000394  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000191  000395  // Syntax: MAX(value1, value2);
000192  000396  // Usage : var := MAX(arg1, arg2);
000193  000397  // Notes : Returns the maximum of 2 arguments
000194  000398        
000195  000399  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000196  000400  // Syntax: SWAP(&var1, &var2);
000197  000401  // Usage : SWAP(&var1, &var2);
000198  000402  // Notes : Swaps the contents of 2 variables or memory locations
000199  000403        
000200  000404  func SIN("angle"), 1;                           // return SIN of angle
000201  000405  // Syntax: SIN(angle);
000202  000406  // Usage : var := SIN(arg);
000203  000407  // Notes : Returns the sine in radians of an argument in degrees
000204  000408  //       : the returned value range is from 127 to -127. The real
000205  000409  //       : cosine values vary from 1.0 to -1.0 so appropriate
000206  000410  //       : scaling must be done in user code.
000207  000411        
000208  000412  func COS("angle"), 1;                           // return COS of angle
000209  000413  // Syntax: COS(angle);
000210  000414  // Usage : var := COS(arg);
000211  000415  // Notes : Returns the cosine in radians of an argument in degrees
000212  000416  //       : the returned value range is from 127 to -127. The real
000213  000417  //       : cosine values vary from 1.0 to -1.0 so appropriate
000214  000418  //       : scaling must be done in user code.
000215  000419        
000216  000420  func RAND(), 1;                                 // return a pseudo random number
000217  000421  // Syntax: RAND();
000218  000422  // Usage : var := RAND();
000219  000423  // Notes : Returns a random number between 0 and 0xFFFF.
000220  000424  //       : The random number generator must first be seeded
000221  000425  //       : by using the SEED(number) function.
000222  000426        
000223  000427  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000224  000428  // Syntax: SEED(number);
000225  000429  // Usage : SEED(arg);
000226  000430  // Notes : Seeds the random number generator.
000227  000431        
000228  000432  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000229  000433  // Syntax: OVF();
000230  000434  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000231  000435  //       : hiWord := OVF();
000232  000436  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000233  000437        
000234  000438  func SQRT("number"), 1;                         // return square root of a number
000235  000439  // Syntax: SQRT(number);
000236  000440  // Usage : SQRT(arg);
000237  000441  // Notes : Returns the integer square root of a number.
000238  000442  //------------------------------------------------------------------//
000239  000443  //          Text Related Function Prototypes
000240  000444  //------------------------------------------------------------------//
000241  000445        
000242  000446  func txt_MoveCursor("line", "column"), 0;
000243  000447  // Syntax: txt_SetCursor(line, column);
000244  000448  // Usage : txt_SetCursor(arg1, arg2);
000245  000449  // Notes : Moves the text Cursor to a new screen position set by
000246  000450  //       : line,column parameters.
000247  000451        
000248  000452  func txt_Set("mode", "value"), 0;
000249  000453  // Syntax: txt_Set(mode, value);
000250  000454  // Usage : txt_Set(arg1, arg2);
000251  000455  // Returns : Original value before the change
000252  000456  // Notes : Sets various text related parameters used by other functions
000253  000457  //       : This allows the features to be set programatically with a
000254  000458  //       : single function call.It is strongly recommended to use the
000255  000459  //       : pre-defined constants rather than the mode numbers.
000256  000460  //       : NB:- Although it is often required to be able to set text
000257  000461  //       : functions with a single function call for graphics engine
000258  000462  //       : related functions, there is a complete set of single parameter
000259  000463  //       : shortcut functions that have exactly the same function as
000260  000464  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000261  000465  //       :
000262  000466  //       : mode = TEXT_COLOUR (mode 0)
000263  000467  //       : txt_Set(TEXT_COLOUR, value);
000264  000468  //       : value = 0 to 0xFFFF, Black to White
000265  000469  //       : Sets the Text colour for the display
000266  000470  //       : Default = LIME.
000267  000471  //       :
000268  000472  //       : mode = TEXT_HIGHLIGHT (mode 1)
000269  000473  //       : txt_Set(TEXT_HIGHLIGHT, value);
000270  000474  //       : value = 0 to 0xFFFF, Black to White
000271  000475  //       : Sets the Text background colour for the display. Effective
000272  000476  //       : when text mode is Opaque.
000273  000477  //       : Default = BLACK.
000274  000478  //       :
000275  000479  //       : mode = FONT_ID (mode 2)
000276  000480  //       : txt_Set(FONT_ID, value);
000277  000481  //       : value = FONT1, FONT2 or FONT3 for internal fonts
000278  000482  //       : else this value is the name of a font included
000279  000483  //       : in a users program in a data statement.
000280  000484  //       : Default = FONT SIZE 3.
000281  000485  //       :
000282  000486  //       : mode = TEXT_WIDTH  (mode 3)
000283  000487  //       : txt_Set(TEXT_WIDTH, value);
000284  000488  //       : value = 1 to 16
000285  000489  //       : Sets the Text Width multiplier
000286  000490  //       : text will be printed magnified horizontally
000287  000491  //       : by this factor, Default = 1.
000288  000492  //       :
000289  000493  //       : mode = TEXT_HEIGHT  (mode 4)
000290  000494  //       : txt_Set(TEXT_HEIGHT, value);
000291  000495  //       : value = 1 to 16
000292  000496  //       : Sets the Text Height multiplier
000293  000497  //       : text will be printed magnified vertically
000294  000498  //       : by this factor, Default = 1.
000295  000499  //       :
000296  000500  //       : mode = TEXT_XGAP  (mode 5)
000297  000501  //       : txt_Set(TEXT_XGAP, value);
000298  000502  //       : value = 1 to 32
000299  000503  //       : Sets the horizontal gap between characters
000300  000504  //       : The gap is in pixel units, Default = 0
000301  000505  //       :
000302  000506  //       : mode = TEXT_YGAP  (mode 6)
000303  000507  //       : txt_Set(TEXT_YGAP, value);
000304  000508  //       : value = 1 to 32
000305  000509  //       : Sets the vertical gap below characters
000306  000510  //       : The gap is in pixel units, Default = 0
000307  000511  //       :
000308  000512  //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
000309  000513  //       : txt_Set(TEXT_PRINTDELAY, value);
000310  000514  //       : value = 0 to 255
000311  000515  //       : Sets the delay time (in ms) during character
000312  000516  //       : printing to give a 'teletype' like effect.
000313  000517  //       : Often used to attract attention to a string
000314  000518  //       : being printed which can often be missed if
000315  000519  //       : just suddenly appearing or changing.
000316  000520  //       : Default = 0 ms.
000317  000521  //       :
000318  000522  //       : mode = TEXT_OPACITY (mode 8)
000319  000523  //       : txt_Set(TEXT_OPACITY, value);
000320  000524  //       : value = TRANSPARENT (0) = Text Trasparent
000321  000525  //       : value = OPAQUE (1) = Text Opaque
000322  000526  //       : Sets the Opacity/Transparency of the text
000323  000527  //       : Default = 0 or TRANSPARENT
000324  000528  //       :
000325  000529  //       : mode = TEXT_BOLD (mode 9)
000326  000530  //       : txt_Set(TEXT_BOLD, value);
000327  000531  //       : value = dont care
000328  000532  //       : Sets Bold Text mode for the next string or char
000329  000533  //       : The feature automatically resets after printing
000330  000534  //       : using putstr or print has completed
000331  000535  //       :
000332  000536  //       : mode = TEXT_ITALIC (mode 10)
000333  000537  //       : txt_Set(TEXT_ITALIC, value);
000334  000538  //       : value = dont care
000335  000539  //       : Sets Italic Text mode for the next string or char
000336  000540  //       : The feature automatically resets after printing
000337  000541  //       : using putstr or print has completed
000338  000542        
000339  000543  //       : mode = TEXT_INVERSE (mode 11)
000340  000544  //       : txt_Set(TEXT_INVERSE, value);
000341  000545  //       : value = dont care
000342  000546  //       : Sets Inverse Text mode for the next string or char
000343  000547  //       : The feature automatically resets after printing
000344  000548  //       : using putstr or print has completed
000345  000549  //       :
000346  000550  //       : mode = TEXT_UNDERLINED (mode 12)
000347  000551  //       : txt_Set(TEXT_UNDERLINED, value);
000348  000552  //       : value = dont care
000349  000553  //       : Sets Underlined Text mode for the next string or char
000350  000554  //       : The feature automatically resets after printing
000351  000555  //       : using putstr or print has completed
000352  000556  //       :
000353  000557  //       : mode = TEXT_ATTRIBUTES (mode 13)
000354  000558  //       : txt_Set(TEXT_ATTRIBUTES, value);
000355  000559  //       : value = bits are defined as:
000356  000560  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000357  000561  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000358  000562  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000359  000563  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000360  000564  //       : Allows a combination of text attributes to be defined together
000361  000565  //       : by 'or'ing the bits together.
000362  000566  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000363  000567  //       : The feature automatically resets after printing
000364  000568  //       : using putstr or print has completed.
000365  000569  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000366  000570  //       :
000367  000571  //       : mode = TEXT_WRAP (mode 14)
000368  000572  //       : txt_Set(TEXT_WRAP , value);
000369  000573  //       : Sets the position where text wrap will occur
000370  000574  //       : The feature automatically resets when screen
000371  000575  //       : mode is changed. If the value is set to 0,
000372  000576  //       : text wrap is turned off.
000373  000577  //       : of the current screen. Default value is 0
000374  000578  // Notes : The value is in pixel units.
000375  000579  //       :
000376  000580        
000377  000581  //       : txt_Set mode 15 reserved for future use
000378  000582  //       :
000379  000583        
000380  000584        
000381  000585        
000382  000586  //=====================================================//
000383  000587  // Single parameter short-cuts                         //
000384  000588  // for the txt_Set functions                           //
000385  000589  // These functions return the existing value before    //
000386  000590  // the change is made.                                 //
000387  000591  //=====================================================//
000388  000592  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000389  000593  func txt_BGcolour("colour"), 1;             // 1  text background colour
000390  000594  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000391  000595  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000392  000596  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000393  000597  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000394  000598  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000395  000599  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000396  000600  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000397  000601  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000398  000602  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000399  000603  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000400  000604  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000401  000605  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000402  000606  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000403  000607  func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
000404  000608        
000405  000609        
000406  000610  //------------------------------------------------------------------//
000407  000611  //                 Hardware Function Prototypes
000408  000612  //------------------------------------------------------------------//
000409  000613        
000410  000614  // I/O Pin reference:-
000411  000615  //
000412  000616  //    IO1_PIN           is pin 2 of J1
000413  000617  //    IO2_PIN           is pin 1 of J1
000414  000618  //    IO3_PIN           is pin 3 of J1
000415  000619  //    IO4_PIN           is pin 5 of J1 (also used for BUS_RD)
000416  000620  //    IO5_PIN           is pin 9 of J2 (also used for BUS_WR)
000417  000621  //    BUS_RD_PIN        is pin 5 of J1 (alias IO4_PIN)
000418  000622  //    BUS_WR_PIN        is pin 9 of J2 (alias IO5_PIN)
000419  000623  //    BUS_0             is pin 27 of J1
000420  000624  //    BUS_1             is pin 25 of J1
000421  000625  //    BUS_2             is pin 23 of J1
000422  000626  //    BUS_3             is pin 21 of J1
000423  000627  //    BUS_4             is pin 19 of J1
000424  000628  //    BUS_5             is pin 17 of J1
000425  000629  //    BUS_6             is pin 13 of J2
000426  000630  //    BUS_7             is pin 11 of J2
000427  000631  //    BACKLITE          is backlite control pin
000428  000632  //    AUDIO_ENABLE      is amplifier chip control pin
000429  000633        
000430  000634  func pin_Set("mode", "pin"), 1;            // set pin to required mode
000431  000635  // Syntax: pin_Set(mode, pin);
000432  000636  // Usage : pin_Set(arg1, arg2);
000433  000637  // Notes : Sets the appropriate pins to Inputs or Outputs
000434  000638  //       : returns true if the pin number is legal (usually ignored)
000435  000639  //       :
000436  000640  //       : mode = 0 : Set Pin to Output
000437  000641  //       : pin_Set(0, pin);
000438  000642  //       : pin_Set(OUTPUT, pin);
000439  000643  //       : pin = 1  : set IO1_PIN to output (pin 2 J1)
000440  000644  //       : pin = 2  : set IO2_PIN to output (pin 1 J1)
000441  000645  //       : pin = 3  : set IO3_PIN to output (pin 3 J1)
000442  000646  //       : pin = 4  : set IO4_PIN to output (pin 5 J1, also used for BUS_RD)
000443  000647  //       : pin = 5  : set IO5_PIN to output (pin 9 J2, also used for BUS_WR)
000444  000648  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000445  000649  //       : pin = 8  : set BUS_0   to output (pin 27 of J1)
000446  000650  //       : pin = 9  : set BUS_1   to output (pin 25 of J1)
000447  000651  //       : pin = 10 : set BUS_2   to output (pin 23 of J1)
000448  000652  //       : pin = 11 : set BUS_3   to output (pin 21 of J1)
000449  000653  //       : pin = 12 : set BUS_4   to output (pin 19 of J1)
000450  000654  //       : pin = 13 : set BUS_5   to output (pin 17 of J1)
000451  000655  //       : pin = 14 : set BUS_6   to output (pin 13 of J2)
000452  000656  //       : pin = 15 : set BUS_7   to output (pin 11 of J2)
000453  000657  //       : Sets the desired pin to be used as an Output.
000454  000658  //       :
000455  000659  //       : mode = 1 : Set Pin to Input
000456  000660  //       : pin_Set(1, pin);
000457  000661  //       : pin_Set(INPUT, pin);
000458  000662  //       : pin = 1  : set IO1_PIN to input (pin 2 J1)
000459  000663  //       : pin = 2  : set IO2_PIN to input (pin 1 J1)
000460  000664  //       : pin = 3  : set IO3_PIN to input (pin 3 J1)
000461  000665  //       : pin = 4  : set IO4_PIN to input (pin 5 J1, also used for BUS_RD)
000462  000666  //       : pin = 5  : set IO5_PIN to input (pin 9 J2, also used for BUS_WR)
000463  000667  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000464  000668  //       : pin = 8  : set BUS_0   to input (pin 27 of J1)
000465  000669  //       : pin = 9  : set BUS_1   to input (pin 25 of J1)
000466  000670  //       : pin = 10 : set BUS_2   to input (pin 23 of J1)
000467  000671  //       : pin = 11 : set BUS_3   to input (pin 21 of J1)
000468  000672  //       : pin = 12 : set BUS_4   to input (pin 19 of J1)
000469  000673  //       : pin = 13 : set BUS_5   to input (pin 17 of J1)
000470  000674  //       : pin = 14 : set BUS_6   to input (pin 13 of J2)
000471  000675  //       : pin = 15 : set BUS_7   to input (pin 11 of J2)
000472  000676  //       : Sets the desired pin to be used as an Input.
000473  000677        
000474  000678  func pin_HI("pin"), 1;                    // set pin to logic '1'
000475  000679  // Syntax: pin_HI(pin);
000476  000680  // Usage : pin_HI(arg);
000477  000681  // Notes : Outputs a logic "High" (3.3V) on the appropriate
000478  000682  //       : pin that was previously selected as an Output.
000479  000683  //       : returns true if the pin number is legal (usually ignored)
000480  000684  //       :
000481  000685  //       : pin = 1  : set IO1_PIN to "High" level (pin 2 of J1)
000482  000686  //       : pin = 2  : set IO2_PIN to "High" level (pin 1 of J1)
000483  000687  //       : pin = 3  : set IO3_PIN to "High" level (pin 3 of J1)
000484  000688  //       : pin = 4  : set IO4_PIN to "High" level (pin 5 of J1, also used for BUS_RD)
000485  000689  //       : pin = 5  : set IO5_PIN to "High" level (pin 9 of J2, also used for BUS_WR)
000486  000690  //       : pin = 6  : set DCENB pin to "High" level (BACKLITE ON)
000487  000691  //       : pin = 7  : set AUDIO_ENABL pin to "High" level (AMP OFF)
000488  000692  //       : pin = 8  : set BUS_0   to "High" level (pin 27 of J1)
000489  000693  //       : pin = 9  : set BUS_1   to "High" level (pin 25 of J1)
000490  000694  //       : pin = 10 : set BUS_2   to "High" level (pin 23 of J1)
000491  000695  //       : pin = 11 : set BUS_3   to "High" level (pin 21 of J1)
000492  000696  //       : pin = 12 : set BUS_4   to "High" level (pin 19 of J1)
000493  000697  //       : pin = 13 : set BUS_5   to "High" level (pin 17 of J1)
000494  000698  //       : pin = 14 : set BUS_6   to "High" level (pin 13 of J2)
000495  000699  //       : pin = 15 : set BUS_7   to "High" level (pin 11 of J2)
000496  000700        
000497  000701  func pin_LO("pin"), 1;                    // set pin to logic '0'
000498  000702  // Syntax: pin_LO(pin);
000499  000703  // Usage : pin_LO(arg);
000500  000704  // Notes : Outputs a logic "Low" (0V) on the appropriate
000501  000705  //       : pin that was previously selected as an Output.
000502  000706  //       : returns true if the pin number is legal (usually ignored)
000503  000707  //       :
000504  000708  //       : pin = 1 : set IO1_PIN to "Low" level (pin 2 of J1)
000505  000709  //       : pin = 2 : set IO2_PIN to "Low" level (pin 1 of J1)
000506  000710  //       : pin = 3 : set IO3_PIN to "Low" level (pin 3 of J1)
000507  000711  //       : pin = 4 : set IO4_PIN to "Low" level (pin 5 of J1, also used for BUS_RD)
000508  000712  //       : pin = 5 : set IO5_PIN to "Low" level (pin 9 of J2, also used for BUS_WR)
000509  000713  //       : pin = 6 : set DCENB pin to "Low" level (BACKLITE)
000510  000714  //       : pin = 7 : set AUDIO_ENABL pin to "Low" level (AMP ON)
000511  000715  //       : pin = 8  : set BUS_0  to "Low" level (pin 27 of J1)
000512  000716  //       : pin = 9  : set BUS_1  to "Low" level (pin 25 of J1)
000513  000717  //       : pin = 10 : set BUS_2  to "Low" level (pin 23 of J1)
000514  000718  //       : pin = 11 : set BUS_3  to "Low" level (pin 21 of J1)
000515  000719  //       : pin = 12 : set BUS_4  to "Low" level (pin 19 of J1)
000516  000720  //       : pin = 13 : set BUS_5  to "Low" level (pin 17 of J1)
000517  000721  //       : pin = 14 : set BUS_6  to "Low" level (pin 13 of J2)
000518  000722  //       : pin = 15 : set BUS_7  to "Low" level (pin 11 of J2)
000519  000723        
000520  000724  func pin_Read("pin"), 1;                // read pin, logic or analogue
000521  000725  // Syntax: pin_Read(pin);
000522  000726  // Usage : arg1 := pin_Read(arg2);
000523  000727  // Notes : Reads the logic state of the appropriate
000524  000728  //       : pin that was previously selected as an Input.
000525  000729  //       :
000526  000730  //       : pin = 1  : Read the state of IO1_PIN (pin 2 of J1)
000527  000731  //       : pin = 2  : Read the state of IO2_PIN (pin 1 of J1)
000528  000732  //       : pin = 3  : Read the state of IO3_PIN (pin 3 of J1)
000529  000733  //       : pin = 4  : Read the state of IO4_PIN (pin 5 of J1, also used for BUS_RD)
000530  000734  //       : pin = 5  : Read the state of IO5_PIN (pin 9 of J2, also used for BUS_WR)
000531  000735  //       : pin = 6  : Read the state of DCENB pin to "Low" level (BACKLITE)
000532  000736  //       : pin = 7  : Read the state of AUDIO_ENABL pin to "Low" level (AMP ON)
000533  000737  //       : pin = 8  : Read the state of BUS_0   (pin 27 of J1)
000534  000738  //       : pin = 9  : Read the state of BUS_1   (pin 25 of J1)
000535  000739  //       : pin = 10 : Read the state of BUS_2   (pin 23 of J1)
000536  000740  //       : pin = 11 : Read the state of BUS_3   (pin 21 of J1)
000537  000741  //       : pin = 12 : Read the state of BUS_4   (pin 19 of J1)
000538  000742  //       : pin = 13 : Read the state of BUS_5   (pin 17 of J1)
000539  000743  //       : pin = 14 : Read the state of BUS_6   (pin 13 of J2)
000540  000744  //       : pin = 15 : Read the state of BUS_7   (pin 11 of J2)
000541  000745  //       : Returns a 0 (logic low) or 1 (logic high).
000542  000746        
000543  000747        
000544  000748  //------------------------------------------------------------------//
000545  000749  //                 P1 module BUS I/O control
000546  000750  //------------------------------------------------------------------//
000547  000751        
000548  000752  func bus_In(), 1;
000549  000753  // Syntax: bus_In();
000550  000754  // Usage : arg1 := bus_In();
000551  000755  // Notes : Read the 8bit wide bus into the lower 8 bits of arg1.
000552  000756  //       : The upper 8 bits of arg1 are set to 0.
000553  000757  //       : the BUS_RD and BUS_WR pins are not affected.
000554  000758  //       :
000555  000759  //       : BUS_0 is pin 27 of J1
000556  000760  //       : BUS_1 is pin 25 of J1
000557  000761  //       : BUS_2 is pin 23 of J1
000558  000762  //       : BUS_3 is pin 21 of J1
000559  000763  //       : BUS_4 is pin 19 of J1
000560  000764  //       : BUS_5 is pin 17 of J1
000561  000765  //       : BUS_6 is pin 13 of J2
000562  000766  //       : BUS_7 is pin 11 of J2
000563  000767        
000564  000768  func bus_Out("var"), 0;
000565  000769  // Syntax: bus_Out(var);
000566  000770  // Usage : bus_Out(arg1);
000567  000771  // Notes : The lower 8 bits of arg1 are placed on the 8bit wide bus.
000568  000772  //       : The upper 8 bits of arg1 are ignored.
000569  000773  //       : the BUS_RD and BUS_WR pins are not affected.
000570  000774  //       : NB:- any BUS pins that are set to inputs are not affected.
000571  000775  //       :
000572  000776  //       : BUS_0 is pin 27 of J1
000573  000777  //       : BUS_1 is pin 25 of J1
000574  000778  //       : BUS_2 is pin 23 of J1
000575  000779  //       : BUS_3 is pin 21 of J1
000576  000780  //       : BUS_4 is pin 19 of J1
000577  000781  //       : BUS_5 is pin 17 of J1
000578  000782  //       : BUS_6 is pin 13 of J2
000579  000783  //       : BUS_7 is pin 11 of J2
000580  000784        
000581  000785  func bus_Set("var"), 0;
000582  000786  // Syntax: bus_Set(var);
000583  000787  // Usage : bus_Set(arg1);
000584  000788  // Notes : The lower 8 bits of arg1 are placed in the BUS direction register.
000585  000789  //       : a '1' sets a pin to be an input, a '0' sets a pin to be output.
000586  000790  //       : The upper 8 bits of arg1 are ignored.
000587  000791  //       : the BUS_RD and BUS_WR pins are not affected.
000588  000792  //       :
000589  000793  //       : BUS_0 is pin 27 of J1
000590  000794  //       : BUS_1 is pin 25 of J1
000591  000795  //       : BUS_2 is pin 23 of J1
000592  000796  //       : BUS_3 is pin 21 of J1
000593  000797  //       : BUS_4 is pin 19 of J1
000594  000798  //       : BUS_5 is pin 17 of J1
000595  000799  //       : BUS_6 is pin 13 of J2
000596  000800  //       : BUS_7 is pin 11 of J2
000597  000801        
000598  000802  func bus_Write("var"), 0;
000599  000803  // Syntax: bus_Write(var);
000600  000804  // Usage : bus_Write(arg1);
000601  000805  // Notes : The lower 8 bits of arg1 are placed on the BUS, then, after
000602  000806  //       : a settling delay of approx 50nsec, the BUS_WR pin is strobed
000603  000807  //       : LO for approx 50nsec then set back HI.
000604  000808  //       : The upper 8 bits of arg1 are ignored.
000605  000809  //       : NB:- the BUS_WR pin is automatically pre-set to an output to
000606  000810  //       : ensure BUS write integrity.
000607  000811  //       :
000608  000812  //       : BUS_0 is pin 27 of J1
000609  000813  //       : BUS_1 is pin 25 of J1
000610  000814  //       : BUS_2 is pin 23 of J1
000611  000815  //       : BUS_3 is pin 21 of J1
000612  000816  //       : BUS_4 is pin 19 of J1
000613  000817  //       : BUS_5 is pin 17 of J1
000614  000818  //       : BUS_6 is pin 13 of J2
000615  000819  //       : BUS_7 is pin 11 of J2
000616  000820        
000617  000821  func bus_Read(), 1;
000618  000822  // Syntax: bus_Read();
000619  000823  // Usage : arg1 := bus_Read();
000620  000824  // Notes : The BUS_RD pin set to LO, then, after a settling delay
000621  000825  //       : of approx 50nsec, the BUS is read into the lower 8 bits of arg
000622  000826  //       : (the upper 8 bits being set to 0)
000623  000827  //       : the BUS_RD pin is then set back to a HI level.
000624  000828  //       : NB:- the BUS_RD pin is automatically pre-set to an output to
000625  000829  //       : ensure BUS write integrity.
000626  000830  //       :
000627  000831  //       : BUS_0 is pin 27 of J1
000628  000832  //       : BUS_1 is pin 25 of J1
000629  000833  //       : BUS_2 is pin 23 of J1
000630  000834  //       : BUS_3 is pin 21 of J1
000631  000835  //       : BUS_4 is pin 19 of J1
000632  000836  //       : BUS_5 is pin 17 of J1
000633  000837  //       : BUS_6 is pin 13 of J2
000634  000838  //       : BUS_7 is pin 11 of J2
000635  000839        
000636  000840        
000637  000841  //------------------------------------------------------------------//
000638  000842  //   Graphics Functions
000639  000843  //------------------------------------------------------------------//
000640  000844  func gfx_Set("mode", "value"), 0;            // set various graphics functions
000641  000845  // Syntax: gfx_Set(mode, value);
000642  000846  // Usage : gfx_Set(arg1, arg2);
000643  000847  // Notes : Sets various graphics parameters used by other functions
000644  000848  //       : This allows the features to be set programatically with a
000645  000849  //       : single function call.It is strongly recommended to use the
000646  000850  //       : pre-defined constants rather than the mode numbers.
000647  000851  //       : NB:- Although it is often required to be able to set graphics
000648  000852  //       : functions with a single function call for graphics engine
000649  000853  //       : related functions, there is a complete set of single parameter
000650  000854  //       : shortcut functions that have exactly the same function as
000651  000855  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
000652  000856  //       :
000653  000857  //       : mode = PEN_SIZE (mode 16)
000654  000858  //       : gfx_Set(PEN_SIZE, value);
000655  000859  //       : value = SOLID (value 0) rectangle and circle objects are solid
000656  000860  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
000657  000861  //       : Sets the mode of the Pen used by most graphics objects
000658  000862  //       :
000659  000863  //       : mode = BACKGROUND_COLOUR (mode 17)
000660  000864  //       : gfx_Set(BACKGROUND_COLOUR, value);
000661  000865  //       : value = 0 to 0xFFFF, Black to White
000662  000866  //       : Sets the Background colour of the screen
000663  000867  //       :
000664  000868  //       : mode = OBJECT_COLOUR (mode 18)
000665  000869  //       : gfx_Set(OBJECT_COLOUR, value);
000666  000870  //       : value = 0 to 0xFFFF, Black to White
000667  000871  //       : Sets the Object colour used in various functions
000668  000872  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
000669  000873  //       :
000670  000874  //       : mode = CLIPPING (mode 19)
000671  000875  //       : gfx_Set(CLIPPING, value);
000672  000876  //       : value = OFF (value 0) Clipping disabled
000673  000877  //       : value = ON (value 1) Clipping enabled
000674  000878  //       : Enables/Disables the Clipping feature
000675  000879  //       :
000676  000880  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
000677  000881  //       : gfx_Set(TRANSPARENT_COLOUR, value);
000678  000882  //       : value = 0 to 0xFFFF Black to White
000679  000883  //       : Sets Bitmap, Image or Animation Transparency Colour.
000680  000884  //       : NB not implemented
000681  000885  //       :
000682  000886  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
000683  000887  //       : gfx_Set(5, value);
000684  000888  //       : value = OFF (value 0) Transparency disabled
000685  000889  //       : value = ON (value 1) Transparency enabled
000686  000890  //       : Enables/Disables the Transparency feature
000687  000891  //       : NB not implemented
000688  000892  //       :
000689  000893  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
000690  000894  //       : gfx_Set(FRAME_DELAY, value);
000691  000895  //       : value = 0 to 65535 ms
000692  000896  //       : Sets the Video/Animation clip inter-frame delay. This setting will
000693  000897  //       : over-ride the embedded frame delay of the clip. After the event,
000694  000898  //       : the setting will auto disable and if further inter-frame delays need
000695  000899  //       : overriding the setting must be re-issued.
000696  000900  //       :
000697  000901  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
000698  000902  //       : gfx_Set(SCREEN_MODE, value);
000699  000903  //       : value = LANDSCAPE   (value 0)
000700  000904  //       : value = LANDSCAPE_R (value 1)
000701  000905  //       : value = PORTRAIT    (value 2)
000702  000906  //       : value = PORTRAIT_R  (value 3)
000703  000907  //       :
000704  000908  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
000705  000909  //       : gfx_Set(OUTLINE_COLOUR, value);
000706  000910  //       : value = 1 to 0xFFFF, if 0, featre is OFF
000707  000911  //       : Sets the filled Rectangle or Circle objects outline colour
000708  000912  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
000709  000913  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
000710  000914  //       :
000711  000915  //       : Only supports variable contrast for uOLED Modules
000712  000916  //       : mode = CONTRAST (mode 25) : Contrast
000713  000917  //       : gfx_Set(CONTRAST, value);
000714  000918  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
000715  000919  //       : when contrast=0, display is placed in low power mode.
000716  000920  //       : This function should be called with contrast=0 when
000717  000921  //       : powering down the module.
000718  000922  //       :
000719  000923  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
000720  000924  //       : gfx_Set(LINE_PATTERN, value);
000721  000925  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
000722  000926  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
000723  000927  //       : a value of 0 turns the feature off
000724  000928  //       :
000725  000929  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
000726  000930  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
000727  000931  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
000728  000932  //       : NB not implemented, default is COLOUR16
000729  000933  //       :
000730  000934  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
000731  000935  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
000732  000936  //       : sets the button and slider objects bevel width
000733  000937  //       :
000734  000938  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
000735  000939  //       : gfx_Set(BEVEL_SHADOW , 5);
000736  000940  //       : sets the button and slider objects darken and lighten depth for the bevel colour
000737  000941  //       :
000738  000942  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
000739  000943  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
000740  000944  //       : sets the origin of drawn objects to a position other than 0,0
000741  000945  //       :
000742  000946  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
000743  000947  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
000744  000948  //       : sets the origin of drawn objects to a position other than 0,0
000745  000949        
000746  000950        
000747  000951  func gfx_Cls(), 0;                    // clear the screen
000748  000952  // Syntax: gfx_Cls();
000749  000953  // Usage : gfx_Cls();
000750  000954  // Notes : Clears the screen with current background colour
000751  000955        
000752  000956  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
000753  000957  // Syntax: gfx_MoveTo(x, y);
000754  000958  // Usage : gfx_MoveTo(arg1, arg2);
000755  000959  // Notes : Moves the origin to a new x,y position
000756  000960        
000757  000961  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
000758  000962  // Syntax: gfx_MoveRel(x, y);
000759  000963  // Usage : gfx_MoveRel(arg1, arg2);
000760  000964  // Notes : Moves the origin to a new x,y position
000761  000965  //       : relative to the current origing
000762  000966        
000763  000967  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
000764  000968  // Syntax: gfx_LineTo(x1, y1);
000765  000969  // Usage : gfx_LineTo(arg1, arg2);
000766  000970  // Notes : Draws a Line from the origin x,y to x1,y1.
000767  000971  //       : The new origin is then set to x1, y1. Line colour needs
000768  000972  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000769  000973        
000770  000974  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
000771  000975  // Syntax: gfx_LineRel(x1, y1);
000772  000976  // Usage : gfx_LineRel(arg1, arg2);
000773  000977  // Notes : Draws a Line from the origin x,y to x1,y1.
000774  000978  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
000775  000979  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
000776  000980        
000777  000981  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
000778  000982  // Syntax: gfx_Line(x1, x2, y2, colr);
000779  000983  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
000780  000984  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
000781  000985        
000782  000986  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
000783  000987  // Syntax: gfx_Line(x1, x2, y, colr);
000784  000988  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000785  000989  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
000786  000990        
000787  000991  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
000788  000992  // Syntax: gfx_Line(y1, y2, x, colr);
000789  000993  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000790  000994  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
000791  000995        
000792  000996  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
000793  000997  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
000794  000998  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000795  000999  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
000796  001000  //       : bottom corner (x2,y2) on the screen.
000797  001001        
000798  001002  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
000799  001003  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
000800  001004  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000801  001005  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
000802  001006  //       : bottom corner (x2,y2) on the screen.
000803  001007        
000804  001008  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
000805  001009  // Syntax: gfx_Circle(x, y, rad, colr);
000806  001010  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000807  001011  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
000808  001012        
000809  001013  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
000810  001014  // Syntax: gfx_Circle(x, y, rad, colr);
000811  001015  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000812  001016  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
000813  001017        
000814  001018  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
000815  001019  // Syntax: gfx_PutPixel(x, y, colr);
000816  001020  // Usage : gfx_PutPixel(arg1, arg2, arg3);
000817  001021  // Notes : Plots a coloured pixel on the screen at x,y location
000818  001022        
000819  001023  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
000820  001024  // Syntax: gfx_GetPixel(x, y);
000821  001025  // Usage : var := gfx_GetPixel(arg1, arg2);
000822  001026  // Notes : Reads and returns the colour value of a pixel at location x,y
000823  001027        
000824  001028  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
000825  001029  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
000826  001030  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000827  001031  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000828  001032  //       : Vertices must be specified in an anti-clockwise fashion
000829  001033        
000830  001034  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
000831  001035  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
000832  001036  // Usage : gfx_OrbitInit(&arg1, &arg2);
000833  001037  // Notes : Sets up the Orbit function parameters.
000834  001038  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
000835  001039  //       : variables that get updated after calling gfx_Orbit(,,) function.
000836  001040  //       : The coordiantaes are calculated relative to the origin
000837  001041  //       : obtained by using the gfx_MoveTo(x, y) function.
000838  001042        
000839  001043  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
000840  001044  // Syntax: gfx_Orbit(angle, distance);
000841  001045  // Usage : gfx_Orbit(arg1, arg2);
000842  001046  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
000843  001047  //       : only known parameters are the angle and the distance from the current origin.
000844  001048        
000845  001049  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
000846  001050  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
000847  001051  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
000848  001052  // Notes : This function is very similar to the Ploygon function
000849  001053  //       : with the exception of the 1st and the last vertices not joined.
000850  001054        
000851  001055  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
000852  001056  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
000853  001057  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
000854  001058  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000855  001059  //       : Vertices must be minimum of 3 and can be specified in any fashion
000856  001060        
000857  001061  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
000858  001062  // Syntax: gfx_Dot();
000859  001063  // Usage : gfx_Dot();
000860  001064  // Notes : Places a coloured dot at the origin
000861  001065        
000862  001066        
000863  001067  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
000864  001068  // Syntax: gfx_Bullet();
000865  001069  // Usage : gfx_Bullet();
000866  001070  // Notes : Places a coloured circle at the origin
000867  001071  //       : filled or unfilled state is controlled by PenSize
000868  001072        
000869  001073  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
000870  001074  // Syntax: gfx_IncX();
000871  001075  // Usage : var := gfx_IncX();
000872  001076  // Notes : Increments the x coordinate of the origin
000873  001077        
000874  001078  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
000875  001079  // Syntax: gfx_IncY();
000876  001080  // Usage : var := gfx_IncY();
000877  001081  // Notes : Increments the y coordinate of the origin
000878  001082        
000879  001083  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
000880  001084  // Syntax: gfx_BoxTo(x1, y1);
000881  001085  // Usage : gfx_BoxTo(arg1, arg2);
000882  001086  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
000883  001087  //       : The new origin is then set to x1,y1. Rectangle colour needs
000884  001088  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000885  001089  //       : and the PenSize setting determines if Box is solid or outline.
000886  001090        
000887  001091  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
000888  001092  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
000889  001093  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
000890  001094  // Notes : Specifies a clipping window region on the screen such that any objects
000891  001095  //       : and text placed onto the screen will be clipped and displayed only
000892  001096  //       : within that region. For the clipping window to take effect, "Clipping"
000893  001097  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
000894  001098        
000895  001099        
000896  001100  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
000897  001101  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
000898  001102  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
000899  001103  // *Notes:
000900  001104        
000901  001105  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
000902  001106  // Syntax: gfx_SetClipRegion();
000903  001107  // Usage : var := gfx_SetClipRegion();
000904  001108  // *Notes:
000905  001109        
000906  001110  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
000907  001111  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
000908  001112  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
000909  001113  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000910  001114  //       : with xradius = xrad and yradius = yrad.
000911  001115  //       : if PenSize = 0 Ellipse is Solid
000912  001116  //       : if PenSize = 1 Ellipse is Outline
000913  001117        
000914  001118        
000915  001119  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
000916  001120  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
000917  001121  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
000918  001122  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000919  001123  //       : with xradius = xrad and yradius = yrad.
000920  001124        
000921  001125  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
000922  001126  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
000923  001127  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
000924  001128  // Notes : Draws a 3 dimensional Text Button at screen location defined by
000925  001129  //       : x,y arguments (top left corner). The size of the button depends on
000926  001130  //       : the font, width, height and length of the text.
000927  001131  //       : The button appearance will depend on the state parameter setting:
000928  001132  //       :         state = 0 : Button Pressed
000929  001133  //       :         state = 1 : Button Raised
000930  001134        
000931  001135  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
000932  001136  // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
000933  001137  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
000934  001138  // Notes : Draws a panel (groupbox) at screen location defined by
000935  001139  //       : x, y, width and height with colour "colour".
000936  001140  //       :         state = 0 : recessed
000937  001141  //       :         state = 1 : raised
000938  001142        
000939  001143  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
000940  001144  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
000941  001145  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
000942  001146  // Notes : Draws a 3 dimensional Slider Bar on the screen.
000943  001147  //       : Slider parameters are as follows:
000944  001148  //       :         mode = 0 : Slider recessed
000945  001149  //       :         mode = 1 : Slider raised
000946  001150  //       :         x1, y1 = top left corner
000947  001151  //       :         x2, y2 = bottom right corner
000948  001152  //       :         scale = n : sets the full scale range from 0 to n
000949  001153  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
000950  001154  //       : returns:-
000951  001155        
000952  001156        
000953  001157  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
000954  001158  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
000955  001159  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
000956  001160  // Notes : Copies an area of a screen from xs,ys of size given by width and height
000957  001161  //       : and pastes it to another location determined by xd, yd.
000958  001162        
000959  001163  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
000960  001164  // Syntax: gfx_RGBto565(red, green, blue);
000961  001165  // Usage : gfx_RGBto565(arg1, arg2, arg3);
000962  001166  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
000963  001167        
000964  001168  func gfx_332to565("COLOUR8BIT"), 1;
000965  001169  // Syntax: gfx_332to565(colour);
000966  001170  // Usage : gfx_332to565(arg);
000967  001171  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
000968  001172        
000969  001173  func gfx_Selection("index", "backcolor", "textcolor"), 0;
000970  001174  // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
000971  001175  // Usage : gfx_Selection(1, RED, YELLOW);
000972  001176  // Notes : Called prior to drawing a button, this function
000973  001177  //       : hilites the required text line on a multiline button.
000974  001178        
000975  001179  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
000976  001180  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
000977  001181  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000978  001182  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000979  001183  //       : Vertices must be specified in an anti-clockwise fashion
000980  001184        
000981  001185        
000982  001186  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
000983  001187  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
000984  001188  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
000985  001189  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000986  001190  //       : Vertices must be minimum of 3 and can be specified in any fashion
000987  001191        
000988  001192        
000989  001193  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
000990  001194  // Syntax: gfx_Offset(x, y);
000991  001195  // Usage : gfx_Offset(arg1, arg2);
000992  001196  // Notes : Set the screen offset
000993  001197        
000994  001198        
000995  001199        
000996  001200  func gfx_Get("mode"), 1;
000997  001201  // Syntax: gfx_Get(mode);
000998  001202  // Usage : arg1 := gfx_Get(arg);
000999  001203  // Notes : Returns various parameters to caller
001000  001204  //       :
001001  001205  //       : mode = X_MAX (mode 0) : current orientations maximum X value
001002  001206  //       : var := gfx_Get(X_MAX);
001003  001207  //       : Returns the maximum horizontal value of the display
001004  001208  //       :
001005  001209  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
001006  001210  //       : var := gfx_Get(Y_MAX);
001007  001211  //       : Returns the maximum vertical value of the display
001008  001212  //       :
001009  001213  //       : mode = LEFT_POS (mode 2) : Left location of last Object
001010  001214  //       : var := gfx_Get(LEFT_POS);
001011  001215  //       : Returns the left location of the last drawn object
001012  001216  //       : such as a slider or button or an image/video
001013  001217  //       :
001014  001218  //       : mode = TOP_POS (mode 3) : Top location of Object
001015  001219  //       : var := gfx_Get(TOP_POS);
001016  001220  //       : Returns the top location of the last drawn object
001017  001221  //       : such as a slider or button or an image/video
001018  001222  //       :
001019  001223  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
001020  001224  //       : var := gfx_Get(RIGHT_POS);
001021  001225  //       : Returns the right location of the last drawn object
001022  001226  //       : such as a slider or button or an image/video
001023  001227  //       :
001024  001228  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
001025  001229  //       : var := gfx_Get(BOTTOM_POS );
001026  001230  //       : Returns the bottom location of the last drawn object
001027  001231  //       : such as a slider or button or an image/video
001028  001232  //       :
001029  001233        
001030  001234        
001031  001235  //==================================================//
001032  001236  // Single parameter short-cuts                      //
001033  001237  // for the gfx_Set functions                        //
001034  001238  // These functions return the existing value before //
001035  001239  // the change is made.                              //
001036  001240  //==================================================//
001037  001241  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
001038  001242  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
001039  001243  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
001040  001244  func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
001041  001245  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
001042  001246  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
001043  001247  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
001044  001248  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
001045  001249  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
001046  001250  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
001047  001251  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
001048  001252  func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
001049  001253  func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
001050  001254  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
001051  001255  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
001052  001256  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
001053  001257        
001054  001258        
001055  001259  //==================================================//
001056  001260  // uSD/FLASH Function Prototypes                    //
001057  001261  //==================================================//
001058  001262  func media_Video("x", "y"), 0;                      // display movie at position x y
001059  001263  // Syntax: media_Video(x, y);
001060  001264  // Usage : media_Video(arg1, arg2);
001061  001265  // Notes : Play a Video/Animation clip from the uSD card at screen location
001062  001266  //       : specified by x,y (top left corner). The location of the clip in the
001063  001267  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
001064  001268        
001065  001269  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
001066  001270  // Syntax: media_VideoFrame(Frame_number);
001067  001271  // Usage : arg1 := media_VideoFrame();
001068  001272  // Notes : After a pointer to a valid video has been set with media_SetSector,
001069  001273  //       : calling this function shows each fram sequentially, returning
001070  001274  //       : the number of frames remaining. The position of the image is
001071  001275  //     : at the current origin as set with gfx_MoveTo(...);
001072  001276        
001073  001277  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
001074  001278  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
001075  001279  // Usage : media_SetAdd(arg1, arg2);
001076  001280  // Notes : Set uSD internal Address pointer for bytewise access
001077  001281        
001078  001282  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
001079  001283  // Syntax: media_SetSector(SectHiWord, SectLoWord);
001080  001284  // Usage : media_SetSector(arg1, arg2);
001081  001285  // Notes : Set uSD internal Sector pointer for sector block access
001082  001286        
001083  001287  func media_RdSector("*destination"), 1;
001084  001288  // Syntax: media_RdSector(*destination);
001085  001289  // Usage : media_RdSector(rdblock);
001086  001290  // Notes : Reads and Returns 512 bytes (256 words) into a destination
001087  001291  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
001088  001292  //       : After the read the Sector pointer is automatically incremented by 1.
001089  001293  //       : Returns TRUE if uSD response was TRUE
001090  001294        
001091  001295  func media_WrSector("*source"), 1;
001092  001296  // Syntax: media_WrSector(*source);
001093  001297  // Usage : media_WrSector(wrblock);
001094  001298  // Notes : Writes 512 bytes (256 words) from a source memory block
001095  001299  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
001096  001300  //       : pointer is automatically incremented by 1.
001097  001301  //       : Returns TRUE if uSD response was TRUE
001098  001302        
001099  001303  func media_ReadByte(), 1;                // read a byte at the current stream position
001100  001304  // Syntax: media_RdByte();
001101  001305  // Usage : var := media_RdByte();
001102  001306  // Notes : Reads and Returns a single byte of data from the
001103  001307  //       : uSD card pointed to by the internal Address pointer.
001104  001308  //       : After the read the Address pointer is automatically
001105  001309  //       : incremented by 1.
001106  001310        
001107  001311  func media_ReadWord(), 1;                // read a word at the current stream position
001108  001312  // Syntax: media_ReadWord();
001109  001313  // Usage : var := media_ReadWord();
001110  001314  // *Notes : Reads and Returns a single word of data from the
001111  001315  //       : uSD card pointed to by the internal Address pointer.
001112  001316  //       : After the read the Address pointer is automatically
001113  001317  //       : incremented by 2.
001114  001318        
001115  001319  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
001116  001320  // Syntax: media_WriteByte(arg1);
001117  001321  // Usage : var := media_WriteByte(arg1);
001118  001322  // *Notes : Writes and Returns xxxxx
001119  001323  //       : After the write the Address pointer is automatically
001120  001324  //       : incremented by 1.
001121  001325        
001122  001326  func media_WriteWord("word"), 1;            // write a word to the current stream position
001123  001327  // Syntax: media_WriteWord(arg1);
001124  001328  // Usage : var := media_WriteWord(arg1);
001125  001329  // *Notes : Writes and Returns xxxxx
001126  001330  //       : After the write the Address pointer is automatically
001127  001331  //       : incremented by 2.
001128  001332        
001129  001333  func media_Image("x", "y"), 0;            // display image at position x y
001130  001334  // Syntax: media_Image(x, y);
001131  001335  // Usage : media_Image(arg1, arg2);
001132  001336  // Notes : Display an image from the uSD card at screen location
001133  001337  //       : specified by x,y (top left corner). The location of the
001134  001338  //       : Image in the uSD card must be specified by
001135  001339  //       : media_setSector(Image_Sector_Add) function.
001136  001340        
001137  001341  func media_Flush(), 1;                    // after writing to media, flush the sector and write
001138  001342  // Syntax: media_Flush();
001139  001343  // Usage : var := media_Flush();
001140  001344  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
001141  001345  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
001142  001346        
001143  001347  func media_Init(), 1;                    // initialize uSD card
001144  001348  // Usage : media_Init();
001145  001349  // Notes : Initialise uSD CARD
001146  001350  //       : Response: 0 = No Card
001147  001351  //       :           1 = Card Initialised
001148  001352        
001149  001353        
001150  001354  //==============================================//
001151  001355  // Communications Function Prototypes           //
001152  001356  //==============================================//
001153  001357  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
001154  001358  // Syntax: com_Init(buffer, bufsize, qualifier);
001155  001359  // Usage1: com_Init(mybuf, 20, 0);
001156  001360  // Usage2: com_Init(mybuf, 20, ':');
001157  001361  // Notes : initialize a serial capture buffer for the comms input
001158  001362  //       : The program must declare a var array as a circular buffer.
001159  001363  //       : Usage1 declares a circular buffer which will continually
001160  001364  //       : buffer characters.
001161  001365  //       : Usage2 must receive ':' before any characters will
001162  001366  //       : accumulate in the buffer.
001163  001367        
001164  001368  func com_Reset(), 0;                 // reset the comms receiver
001165  001369  // Syntax: com_Reset();
001166  001370  // Usage : com_Reset();
001167  001371  // Notes : reset comms to default polled mode
001168  001372        
001169  001373  func com_Count(), 1;                // return count of characters in receive buffer
001170  001374  // Syntax: com_Count();
001171  001375  // Usage : arg := com_Count();
001172  001376  // Notes : return count of buffered characters in buffer attachment
001173  001377        
001174  001378  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
001175  001379  // Syntax: com_Full();
001176  001380  // Usage : if (com_Full() ,,,, go read buffer;
001177  001381  // Notes : return true if buffer full (not necessarily an error if
001178  001382  //       : buffer is sized to a packet size)
001179  001383        
001180  001384  func com_Error(), 1;                // return comms errors comms error occurred
001181  001385  // Syntax: com_Error();
001182  001386  // Usage : if (com_Error() ) ...... take recovery action;
001183  001387  // Notes : return non zero if any errors low level comms errors occured
001184  001388  // returns :
001185  001389  // bit0 = Receiver Overflow Error
001186  001390  // bit1 = Receiver Framing Error
001187  001391  // bit2 = Transmit Buffer Overflow
001188  001392        
001189  001393  func com_Sync(), 1;                // returns TRUE if qualifier has been received
001190  001394  // Syntax: com_Sync();
001191  001395  // Usage : com_Sync();
001192  001396  // return true if sync character has been received in com_Init("...") mode
001193  001397        
001194  001398        
001195  001399  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001196  001400  // Syntax: com_TXbuffer("buf", "bufsize", "pin");
001197  001401  // Usage : com_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001198  001402  // Usage : com_TXbuffer(0, 0, 0);              // revert to non buffered service
001199  001403  // Notes : initialize a serial buffer for the COM0 output.
001200  001404  //       : The program must declare a var array as a circular buffer.
001201  001405  //       : When a TX buffer is declared for comms, the transmission
001202  001406  //       : of characters becomes non blocking. The only time
001203  001407  //       : blocking will occur is if the buffer has insufficient space
001204  001408  //       : to accept the next character, in which case the function
001205  001409  //       : will wait for buffer space to become available. If the
001206  001410  //       : TX buffer is no longer required, just set the buffer pointer
001207  001411  //       : to zero, the size in this case doesnt matter and is ignored.
001208  001412  //       : The function can resize or reallocated to another buffer at
001209  001413  //       : any time. The buffer is flushed before any changes are made.
001210  001414  //       : "pin" designates an IO pin to control a bi-directional 
001211  001415  //       : control device for half duplex mode. "pin" will go HI at the
001212  001416  //       : start of a transmission, and will return low after the final
001213  001417  //       : byte is transmitted. If not required, just set "pin" to zero.
001214  001418        
001215  001419        
001216  001420  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
001217  001421  // Syntax: com_TXcount();
001218  001422  // Usage : arg := com_Count();
001219  001423  // Notes : return count of characters remaining in COM0 transmit buffer
001220  001424  //       : that was previously allocated with com_TXbuffer(...);
001221  001425        
001222  001426        
001223  001427  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
001224  001428  // Syntax: com_TXemptyEvent(function);
001225  001429  // Usage : arg := com_TXemptyEvent();
001226  001430  // Notes : If a comms TX buffer that was previously allocated with
001227  001431  //       : com_TXbuffer(...);, this function can be used to set up
001228  001432  //       : a function to be called when the COM0 TX buffer is empty.
001229  001433  //       : This is useful for either reloading the TX buffer, setting
001230  001434  //       : or clearing a pin to change the direction of eg a RS485
001231  001435  //       : line driver, or any other form of traffic control.
001232  001436  //       : The event function must not have any parameters.
001233  001437  //       : To disable the event, simply call com_TXemptyEvent(0).
001234  001438  //       : com_TXbuffer(...); also resets any active event.
001235  001439  //       : com_TXemptyEvent returns any previous event function
001236  001440  //       : address, or zero if there was no previous function.
001237  001441        
001238  001442        
001239  001443  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
001240  001444  // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
001241  001445  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
001242  001446  // Notes : Expecting that a comms TX buffer that was previously allocated with
001243  001447  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
001244  001448  //       : the buffer being sent wile it is being loaded. Mormally, when
001245  001449  //       : using buffered comms, the transmit process will begin
001246  001450  //       : immediately. This is often undesirable for 2 reasons,
001247  001451  //       : 1] you may wish to build a packet then send it later
001248  001452  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001249  001453  //       : as the FIFO buffer is constantly trying to empty while
001250  001454  //       : you are busy tring to fill it.
001251  001455  // return -1 if function is called illegally when TX comms is not buffered.
001252  001456  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
001253  001457  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
001254  001458        
001255  001459        
001256  001460  //=============================================================//
001257  001461  // Auxilliary Communications Function Prototypes
001258  001462  //=============================================================//
001259  001463  func com1_Init("buffer", "bufsize", "qualifier"), 0;
001260  001464  // Syntax: com_Init(buffer, bufsize, qualifier);
001261  001465  // Usage1: com_Init(mybuf, 20, 0);
001262  001466  // Usage2: com_Init(mybuf, 20, ':');
001263  001467  // Notes : initialize a serial capture buffer for the comms input
001264  001468  //       : The program must declare a var array as a circular buffer.
001265  001469  //       : Usage1 declares a circular buffer which will continually
001266  001470  //       : buffer characters.
001267  001471  //       : Usage2 must receive ':' before any characters will
001268  001472  //       : accumulate in the buffer.
001269  001473        
001270  001474  func com1_Reset(), 0;
001271  001475  // Syntax: com_Reset();
001272  001476  // Usage : com_Reset();
001273  001477  // Notes : reset comms receiver to default polled mode
001274  001478        
001275  001479  func com1_Count(), 1;
001276  001480  // Syntax: com_Count();
001277  001481  // Usage : arg := com_Count();
001278  001482  // Notes : return count of characters in receive buffer
001279  001483        
001280  001484  func com1_Full(), 1;
001281  001485  // Syntax: com_Full();
001282  001486  // Usage : if (com_Full() ,,,, go read buffer;
001283  001487  // Notes : return true if receive buffer full
001284  001488        
001285  001489  func com1_Error(), 1;
001286  001490  // Syntax: com_Error();
001287  001491  // Usage : if (com_Error() ) ...... take recovery action;
001288  001492  // Notes : return non zero if any level comms errors occured
001289  001493  // returns :
001290  001494  // bit0 = Receiver Overflow Error
001291  001495  // bit1 = Receiver Framing Error
001292  001496  // bit2 = Transmit Buffer Overflow
001293  001497        
001294  001498  func com1_Sync(), 1;
001295  001499  // Syntax: com_Sync();
001296  001500  // Usage : com_Sync();
001297  001501  // Notes : return true if sync character has been received in com_Init("...") mode
001298  001502        
001299  001503        
001300  001504  func com1_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001301  001505  // Syntax: com1_TXbuffer("buf", "bufsize", "pin");
001302  001506  // Usage : com1_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001303  001507  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
001304  001508  // Notes : initialize a serial buffer for the COM1 output.
001305  001509  //       : The program must declare a var array as a circular buffer.
001306  001510  //       : When a TX buffer is declared for comms, the transmission
001307  001511  //       : of characters becomes non blocking. The only time
001308  001512  //       : blocking will occur is if the buffer has insufficient space
001309  001513  //       : to accept the next character, in which case the function
001310  001514  //       : will wait for buffer space to become available. If the
001311  001515  //       : TX buffer is no longer required, just set the buffer pointer
001312  001516  //       : to zero, the size in this case doesnt matter and is ignored.
001313  001517  //       : The function can resize or reallocated to another buffer at
001314  001518  //       : any time. The buffer is flushed before any changes are made.
001315  001519  //       : "pin" designates an IO pin to control a bi-directional 
001316  001520  //       : control device for half duplex mode. "pin" will go HI at the
001317  001521  //       : start of a transmission, and will return low after the final
001318  001522  //       : byte is transmitted. If not required, just set "pin" to zero.
001319  001523        
001320  001524        
001321  001525  func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
001322  001526  // Syntax: com1_TXcount();
001323  001527  // Usage : arg := com1_Count();
001324  001528  // Notes : return count of characters remaining in COM1 transmit buffer
001325  001529  //       : that was previously allocated with com1_TXbuffer(...);
001326  001530        
001327  001531        
001328  001532  func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
001329  001533  // Syntax: com1_TXemptyEvent(function);
001330  001534  // Usage : arg := com1_TXemptyEvent();
001331  001535  // Notes : If a comms TX buffer that was previously allocated with
001332  001536  //       : com1_TXbuffer(...);, this function can be used to set up
001333  001537  //       : a function to be called when the COM1 TX buffer is empty.
001334  001538  //       : This is useful for either reloading the TX buffer, setting
001335  001539  //       : or clearing a pin to change the direction of eg a RS485
001336  001540  //       : line driver, or any other form of traffic control.
001337  001541  //       : The event function must not have any parameters.
001338  001542  //       : To disable the event, simply call com1_TXemptyEvent(0).
001339  001543  //       : com1_TXbuffer(...); also resets any active event.
001340  001544  //       : com1_TXemptyEvent returns any previous event function
001341  001545  //       : address, or zero if there was no previous function.
001342  001546        
001343  001547        
001344  001548  func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
001345  001549  // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
001346  001550  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
001347  001551  // Notes : Expecting that a comms TX buffer that was previously allocated with
001348  001552  //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
001349  001553  //       : the buffer being sent wile it is being loaded. Mormally, when
001350  001554  //       : using buffered comms, the transmit process will begin
001351  001555  //       : immediately. This is often undesirable for 2 reasons,
001352  001556  //       : 1] you may wish to build a packet then send it later
001353  001557  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001354  001558  //       : as the FIFO buffer is constantly trying to empty while
001355  001559  //       : you are busy tring to fill it.
001356  001560  // return -1 if function is called illegally when TX comms is not buffered.
001357  001561  // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
001358  001562  // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
001359  001563        
001360  001564  func serin1(), 1;
001361  001565  // Syntax: serin1();
001362  001566  // Usage : char := serin1();
001363  001567  // Notes : return the next available character from COM1
001364  001568        
001365  001569  func serout1("char"), 0;
001366  001570  // Syntax: serout1("char");
001367  001571  // Usage : serout1(ch);
001368  001572  // Notes : send character to COM1
001369  001573        
001370  001574  func com_SetBaud("comport","baudrate/10"), 1;
001371  001575  // Syntax: com_SetBaud("comport","baudrate/10");
001372  001576  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
001373  001577  // Notes : sets to any viable baud rate from 160 to 655350
001374  001578  // return true if baud rate was acceptable
001375  001579        
001376  001580        
001377  001581        
001378  001582  //==============================================//
001379  001583  // Display Access                               //
001380  001584  //==============================================//
001381  001585  func disp_Init(), 0;                            // initialize display with required tables
001382  001586  // Syntax: disp_Init();
001383  001587  // Usage : disp_Init();
001384  001588  // Notes : Initialises or reinitialises the display.
001385  001589  //       : Normally used after restoration of peripheral power
001386  001590  //       : and after DeepSleep.
001387  001591        
001388  001592  func disp_SetReg("register", "data"), 0;
001389  001593  // Syntax: display_SetReg(register, data);
001390  001594  // Usage : display_SetReg(arg1, arg2);
001391  001595  // Notes : Sets uLCD specific display driver registers. Refer
001392  001596  //       : to appropriate display driver data sheet.
001393  001597        
001394  001598  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
001395  001599  // Syntax: disp_setGRAM(x1, y1, x2, y2);
001396  001600  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
001397  001601  // Notes : Prepares the GRAM area for user access.
001398  001602  //       : Data can now be written with disp_GRAM.
001399  001603  //       : GRAM will be set accordingly for the correct screen mode.
001400  001604  //       : the LO word of the 32 bit pixel count is returned. This is
001401  001605  //       : usually all that is needed unlse GRAM area exceeds 256^2
001402  001606  //       : A copy of the 32bit value can be found in
001403  001607  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
001404  001608        
001405  001609  func disp_WrGRAM("colour"), 0;
001406  001610  // Syntax: display_WrGRAM(colour);
001407  001611  // Usage : display_WrGRAM(arg);
001408  001612  // Notes : Data can be written to the GRAM consecutively using
001409  001613  //       : this function once the GRAM access window has been setup.
001410  001614        
001411  001615  func disp_WriteControl("value"), 0;             // write a control byte to the display
001412  001616  func disp_WriteWord("value"), 0;                // write a word to the display
001413  001617        
001414  001618        
001415  001619  func disp_ReadWord(), 1;                        // read a word from the display
001416  001620  // Syntax: disp_ReadWord();
001417  001621  // Usage : x:=disp_ReadWord();
001418  001622  // Notes : Read a word from the controller
001419  001623  // Eg:   : disp_WriteControl(0);         // select Ilitek ID register
001420  001624  //       : print(disp_ReadWord());        // print ID
001421  001625  //       : (Many displays are write only)
001422  001626        
001423  001627                                                  //
001424  001628  //==============================================//
001425  001629  // unadorned SPI functions                      //
001426  001630  //==============================================//
001427  001631  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
001428  001632  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
001429  001633  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
001430  001634  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
001431  001635                                                  //
001432  001636  //==============================================//
001433  001637  // flash device specific functions              //
001434  001638  //==============================================//
001435  001639  func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
001436  001640  func flash_ID(), 1;                             // read ID code from FLASH device
001437  001641  func flash_BulkErase(), 0;                      // erase the entire FLASH device
001438  001642  func flash_BlockErase("block"), 1;              // erase the required 64k flash block
001439  001643                                                  //
001440  001644                                                  //
001441  001645  //==============================================//
001442  001646  // string and character size function           //
001443  001647  //==============================================//
001444  001648  func charwidth("char"), 1;                      // return width of a character in pixel units
001445  001649  func charheight("char"), 1;                     // return height of a character in pixel units
001446  001650  func strwidth("pointer"), 1;                    // return width of a string in pixel units
001447  001651  func strheight(), 1;                            // return height of a string in pixel units
001448  001652        
001449  001653        
001450  001654  //------------------------------------------------------------------//
001451  001655  //        I2C Function Prototypes
001452  001656  //------------------------------------------------------------------//
001453  001657  func I2C_Open("speed"), 0;
001454  001658  // Syntax: I2C_Open(speed),
001455  001659  // Usage : I2C_Open(I2C_MED);
001456  001660  // Notes : configures the I2C module
001457  001661  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
001458  001662        
001459  001663  func I2C_Close(), 0;
001460  001664  // Syntax: I2C_Close();
001461  001665  // Usage : I2C_Close();
001462  001666  // Notes : disables the I2C1 module.
001463  001667        
001464  001668  func I2C_Start(), 1;
001465  001669  // Syntax: I2C_Start();
001466  001670  // Usage : I2C_Start();
001467  001671  // Notes : generates a Start condition.
001468  001672  //       : returns true if successful (usually ignored)
001469  001673        
001470  001674  func I2C_Stop(), 1;
001471  001675  // Syntax: I2C_Stop();
001472  001676  // Usage : I2C_Stop();
001473  001677  // Notes : generates a Stop condition.
001474  001678  //       : returns true if successful (usually ignored)
001475  001679        
001476  001680  func I2C_Restart(), 1;
001477  001681  // Syntax: I2C_Restart();
001478  001682  // Usage : I2C_Restart();
001479  001683  // Notes : generates a Restart condition.
001480  001684  //       : returns true if successful (usually ignored)
001481  001685        
001482  001686  func I2C_Read(), 1;
001483  001687  // Syntax: I2C_Read();
001484  001688  // Usage : ch := I2C_Read();
001485  001689  // Notes : reads a single byte from the I2C Bus.
001486  001690        
001487  001691  func I2C_Write("byte"), 1;
001488  001692  // Syntax: I2C_Write(byte);
001489  001693  // Usage : r := I2C_Write(ch);
001490  001694  // Notes : is used to write a byte to the I2C bus.
001491  001695  //       : Returns 0 if failed, 1 if no ack, 2 if ack
001492  001696        
001493  001697  func I2C_Ack(), 0;
001494  001698  // Syntax: I2C_Ack();
001495  001699  // Usage : I2C_Ack();
001496  001700  // Notes : generates the acknowledge condition.
001497  001701        
001498  001702  func I2C_Nack(), 0;
001499  001703  // Syntax: I2C_Nack();
001500  001704  // Usage : I2C_Nack();
001501  001705  // Notes : generates the negative acknowledge condition.
001502  001706        
001503  001707  func I2C_AckStatus(), 0;
001504  001708  // Syntax: I2C_AckStatus();
001505  001709  // Usage : r := I2C_AckStatus();
001506  001710  // Notes : returns the ACK status from the device.
001507  001711        
001508  001712  func I2C_AckPoll("control"), 1;
001509  001713  // Syntax: I2C_AckPoll();
001510  001714  // Usage : r := I2C_AckPoll(0xA0);
001511  001715  // Notes : waits for a device to return from ACK polling.
001512  001716        
001513  001717  func I2C_Idle(), 0;
001514  001718  // Syntax: I2C_Idle();
001515  001719  // Usage : I2C_Idle();
001516  001720  // Notes : waits until the I2C Bus is Inactive.
001517  001721        
001518  001722  func I2C_Gets("buffer", "size"), 1;
001519  001723  // Syntax: I2C_Gets("buffer", "size");
001520  001724  // Usage : r := I2C_Gets(mybuf, 16);
001521  001725  // Notes : only reads up to "size" characters into "buffer"
001522  001726  //       : Reads up to asciiz terminator including terminator
001523  001727        
001524  001728  func I2C_Getn("buffer", "size"), 1;
001525  001729  // Syntax: I2C_Gets("buffer", "size");
001526  001730  // Usage : r := I2C_Gets(mybuf, 16);
001527  001731  // Notes : reads "size" bytes into "buffer"
001528  001732  //       :
001529  001733        
001530  001734  func I2C_Puts("buffer"), 1;
001531  001735  // Syntax: I2C_Puts("buffer");
001532  001736  // Usage : r := I2C_Puts(mybuf);
001533  001737  // Notes : writes an asciiz string to the I2C device
001534  001738  //       : returns count of characters written
001535  001739        
001536  001740  func I2C_Putn("buffer", "count"), 1;
001537  001741  // Syntax: I2C_Putn("buffer","count");
001538  001742  // Usage : r := I2C_Puts(mybuf,10);
001539  001743  // Notes : writes up to "size" bytes to the I2C device
001540  001744  //       : returns number of bytes written
001541  001745        
001542  001746        
001543  001747  //------------------------------------------------------------------//
001544  001748  //        Image Control Function Prototypes
001545  001749  //------------------------------------------------------------------//
001546  001750  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
001547  001751  // Syntax: img_SetPosition(handle, index, xpos, ypos);
001548  001752  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
001549  001753  // Notes : set the position where the image will be displayed
001550  001754  //       : returns true if index was ok and function was successful.
001551  001755  //       : you may turn off an image so when img_Refresh is called,
001552  001756  //       : the image will not be shown
001553  001757        
001554  001758  func img_Enable("handle", "index"), 1;
001555  001759  // Syntax: img_Enable(handle, index);
001556  001760  // Usage : r := img_Enable(hImageList, imagenum);
001557  001761  // Notes : enable image in a image list
001558  001762  //       : returns true if index was ok and function was successful.
001559  001763  //       : this is the default state so when img_Refresh is called,
001560  001764  //       : all the images in the list will be shown
001561  001765  //       : if index is set to -1, all of the images are enabled
001562  001766        
001563  001767  func img_Disable("handle", "index"), 1;
001564  001768  // Syntax: img_Disable(handle, index);
001565  001769  // Usage : r := img_Disable(hImageList, imagenum);
001566  001770  // Notes : disable image in a image list
001567  001771  //       : returns true if index was ok and function was successful.
001568  001772  //       : you must turn off an image so when img_Refresh is called,
001569  001773  //       : the image will not be shown.
001570  001774  //       : if index is set to -1, all of the images are disabled
001571  001775        
001572  001776        
001573  001777  func img_Darken("handle", "index"), 1;
001574  001778  // Syntax: img_Darken(handle, index);
001575  001779  // Usage : r := img_Darken(hImageList, imagenum);
001576  001780  // Notes : darken image in a image list
001577  001781  //       : returns true if index was ok and function was successful.
001578  001782  //       : if index is set to -1, all of the images are darkened
001579  001783  //       : NB:- this feature will only work for the next refresh, then
001580  001784  //       : the image reverts back to normal when displayed again.
001581  001785        
001582  001786        
001583  001787  func img_Lighten("handle", "index"), 1;
001584  001788  // Syntax: img_Lighten(handle, index);
001585  001789  // Usage : r := img_Lighten(hImageList, imagenum);
001586  001790  // Notes : lighten image in a image list
001587  001791  //       : returns true if index was ok and function was successful.
001588  001792  //       : if index is set to -1, all of the images are lightened
001589  001793  //       : NB:- this feature will only work for the next refresh, then
001590  001794  //       : the image reverts back to normal when displayed again.
001591  001795        
001592  001796  func img_SetWord("handle", "index", "offset", "word"), 1;
001593  001797  // Syntax: img_SetWord(handle, index, offset, word);
001594  001798  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
001595  001799  // Notes : set specified word (0-7) in a image entry
001596  001800  //       : returns TRUE if successful, return value usually ignored.
001597  001801        
001598  001802  func img_GetWord("handle", "index", "offset"), 1;
001599  001803  // Syntax: myvar := img_GetWord("handle", "index", "offset");
001600  001804  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
001601  001805  // Notes : returns specified word (0-14) from an image entry
001602  001806  //       : refer to image control entry offsets.
001603  001807        
001604  001808  func img_Show("handle", "index"), 1;
001605  001809  // Syntax: img_Show(handle, index);
001606  001810  // Usage : display image entry (regardless of enable/disable)
001607  001811  //       : returns TRUE if successful, return value usually ignored.
001608  001812        
001609  001813  func img_SetAttributes("handle", "index","value"), 1;
001610  001814  // Syntax: img_SetAttributes("handle", "index","offset");
001611  001815  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
001612  001816  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
001613  001817  //       : of an image control entry. "value" refers to various bits in
001614  001818  //       : the image control entry (see image attribute flags).
001615  001819  //       : A '1' bit in the "value" field SETS the respective bit
001616  001820  //       : in the IMAGE_FLAGS field of the image control entry.
001617  001821  //       : returns TRUE if successful, return value usually ignored.
001618  001822        
001619  001823  func img_ClearAttributes("handle", "index","value"), 1;
001620  001824  // Syntax: img_ClearAttributes("handle", "index","offset");
001621  001825  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
001622  001826  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
001623  001827  //       : of an image control entry. "value" refers to various bits in
001624  001828  //       : the image control entry (see image attribute flags)
001625  001829  //       : a '1' bit in the "value" field CLEARS the respective bit
001626  001830  //       : in the IMAGE_FLAGS field of the image control entry.
001627  001831  //       : returns TRUE if successful, return value usually ignored.
001628  001832        
001629  001833  func img_Touched("handle", "index"), 1;
001630  001834  // Syntax: r := img_Touched(handle, index);
001631  001835  // Usage : img_Touched(hndl, 17);
001632  001836  //       : returns -1 if image not touched, or returns index
001633  001837  // Notes : if index is passed as -1, function tests all images,
001634  001838  //       : and returns -1 if image not touched, or returns index.
001635  001839        
001636  001840        
001637  001841        
001638  001842        
001639  001843  //------------------------------------------------------------------//
001640  001844  //        Timer Function Prototypes
001641  001845  //------------------------------------------------------------------//
001642  001846  func sys_T(), 1;
001643  001847  // Syntax: sys_T();
001644  001848  // Usage : t := sys_T();
001645  001849  // Notes : return the current value of the rolling system timer (1msec) LO word
001646  001850        
001647  001851  func sys_T_HI(), 1;
001648  001852  // Syntax: sys_T_HI();
001649  001853  // Usage : t := sys_T_HI();
001650  001854  // Notes : return the current value of the rolling system timer (1msec) HI word
001651  001855        
001652  001856  func sys_SetTimer("timernum","value"), 0;
001653  001857  // Syntax: sys_SetTimer("timernum", "value");
001654  001858  // Usage : sys_SetTimer(TIMER5, 10000);
001655  001859  // Notes : set a countdown on the selected timer, or 'top up' if required.
001656  001860  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001657  001861  //       : Maximum timeout period is 65.535 seconds
001658  001862  //       : A timer can be read with the sys_GetTimer("timernum") function
001659  001863        
001660  001864  func sys_GetTimer("timernum"), 1;
001661  001865  // Syntax: t := sys_GetTimer("timernum");
001662  001866  // Usage : t := sys_GetTimer(TIMER3);
001663  001867  // Notes : returns 0 if timer has expired, or the current countdown value.
001664  001868  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001665  001869  //       : Maximum timeout period is 65.535 seconds
001666  001870  //       : A timer must be set with the sys_SetTimer("timernum","value") function
001667  001871        
001668  001872  func sys_SetTimerEvent("timernum","function"), 1;
001669  001873  // Syntax: sys_SetTimerFunction("timernum", "function");
001670  001874  // Usage : sys_SetTimer(TIMER5, myfunc);
001671  001875  // Notes : set a function to be called for selected timer.
001672  001876  //       : When the timer reaches zero, the function is called.
001673  001877  //       : The called function must not have any parameters
001674  001878  //       : sys_SetTimerEvent returns any previous event function
001675  001879  //       : address, or zero if there was no previous function.
001676  001880        
001677  001881  func sys_EventQueue(), 1;
001678  001882  // Syntax: sys_EventQueue();
001679  001883  // Usage : tasks := sys_EventQueue();
001680  001884  // Notes : returns the max number of events that were pending
001681  001885  //       : in the timer queue since the last call to this function.
001682  001886  //       : This can be used to assess timer event overhead burden,
001683  001887  //       : especially after or during a sys_EventsPostpone action.
001684  001888        
001685  001889  func sys_EventsPostpone(), 0;
001686  001890  // Syntax: sys_EventPostpone();
001687  001891  // Usage : sys_EventPostpone();   // postpone the event queue
001688  001892  // Notes : postpone any events until the sys_EventResume function is executed
001689  001893  //       : The timer event queue will continue to queue events, but no action
001690  001894  //       : will take place untill a sys_EventResume function is encountered.
001691  001895  //       : The queue will continue to receive up to 32 events before discarding
001692  001896  //       : any further events. This function is required to allow a sequence of
001693  001897  //       : instructions or functions to occur that would otherwise be corrupted
001694  001898  //       : by an event occuring during the sequence of instructions or functions.
001695  001899  //       : A good example of this is when you set a position to print, if there
001696  001900  //       : was no way of locking the current sequence, an event may occur which
001697  001901  //       : does a similar thing, and a contention would occur - printing to
001698  001902  //       : the wrong position. This function should be used wisely, if any action
001699  001903  //       : that is required would take considerable time, it is better to disable
001700  001904  //       : any conflicting event functions with a bypass flag, then restart the
001701  001905  //       : conflicting event by re-issuing a timer value.
001702  001906        
001703  001907  func sys_EventsResume(), 0;
001704  001908  // Syntax: sys_EventsResume();
001705  001909  // Usage : sys_EventsResume();   // resume the event queue
001706  001910  // Notes : resume any postponed events. The queue will try to execute any timer
001707  001911  //       : events that were incurred during the postponed period.
001708  001912        
001709  001913        
001710  001914  func sys_Sleep("units"), 1;
001711  001915  // Syntax: t := sys_Sleep("units");
001712  001916  // Usage : t := sys_Sleep(10);
001713  001917  // Notes : sets the display into low power mode for a period of time.
001714  001918  //       : Touching the touch screen will also wake from sleep.
001715  001919  //       : Returns remaining sleep units.
001716  001920        
001717  001921  func iterator("offset"), 0;
001718  001922  // Syntax: t :=  iterator("offset");
001719  001923  // Usage : t :=  iterator(10);
001720  001924  // Notes : set the iterator size for ++/--
001721  001925  //       : The next postinc,postdec,preinc of predec will alter
001722  001926  //       : by the specified value.
001723  001927  //       : The offset will return to 1 after the next operation.
001724  001928        
001725  001929        
001726  001930        
001727  001931        
001728  001932  //------------------------------------------------------------------//
001729  001933  //         Touch Screen Function Prototypes
001730  001934  //------------------------------------------------------------------//
001731  001935        
001732  001936  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
001733  001937  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
001734  001938  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
001735  001939  // Notes : Specifies a new touch detect region on the screen
001736  001940  //       : such that only touch activity in that region will
001737  001941  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
001738  001942        
001739  001943  func touch_Set("mode"), 0;
001740  001944  // Syntax: touch_Set(mode);
001741  001945  // Usage : touch_Set(arg);
001742  001946  // Notes : Sets various Touch Screen related parameters
001743  001947  //       :
001744  001948  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
001745  001949  //       : touch_Set(TOUCH_ENABLE);
001746  001950  //       : Enables and initialises Touch Screen hardware
001747  001951  //       :
001748  001952  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
001749  001953  //       : touch_Set(TOUCH_DISABLE );
001750  001954  //       : Disables the Touch Screen
001751  001955  //       : Note: Touch Screen runs in the background and disabling
001752  001956  //       : it when not in use will free up extra resources
001753  001957  //       : such as 4DVM CPU cycles.
001754  001958  //       :
001755  001959  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
001756  001960  //       : touch_Set(TOUCH_REGIONDEFAULT);
001757  001961  //       : This will reset the current active region to default
001758  001962  //       : to the full screen without the application having to
001759  001963  //       : set a new active region for the full screen.
001760  001964  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
001761  001965  //       : that requre to be interfaced with an external pointing
001762  001966  //       : device, values that are poked into TOUCH_DRIVE will be
001763  001967  //       : read with the touch_Get() function)
001764  001968        
001765  001969        
001766  001970  func touch_Get("mode"), 1;
001767  001971  // Syntax: touch_Get(mode);
001768  001972  // Usage : arg1 := touch_Get(arg);
001769  001973  // Notes : Returns various Touch Screen parameters to caller
001770  001974  //       :
001771  001975  //       : mode = TOUCH_STATUS  (mode 0)
001772  001976  //       : var := touch_Get(TOUCH_STATUS);
001773  001977  //       : Returns the various states of the touch screen
001774  001978  //       : 0 = NOTOUCH
001775  001979  //       : 1 = TOUCH_PRESSED
001776  001980  //       : 2 = TOUCH_RELEASED
001777  001981  //       : 3 = TOUCH_MOVING
001778  001982  //       :
001779  001983  //       : mode = TOUCH_GETX   (mode 1)
001780  001984  //       : var := touch_Get(TOUCH_GETX);
001781  001985  //       : Returns the X coordinates of the touch
001782  001986  //       :
001783  001987  //       : mode = TOUCH_GETY   (mode 2)
001784  001988  //       : var := touch_Get(TOUCH_GETY);
001785  001989  //       : Returns the Y coordinates of the touch
001786  001990        
001787  001991  //------------------------------------------------------------------//
001788  001992  //        CTYPE Function Prototypes
001789  001993  //------------------------------------------------------------------//
001790  001994        
001791  001995  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
001792  001996  // Syntax: isdigit("char");
001793  001997  // Usage : Var := isdigit(ch);
001794  001998  // Notes : char specifies the ascii character for the test
001795  001999  //     : 0 : char is not an ascii digit.
001796  002000  //     : 1 : char is an ascii digit..
001797  002001  //     : Valid range is "0123456789"
001798  002002        
001799  002003  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
001800  002004  // Syntax: isxdigit("char");
001801  002005  // Usage : Var := isxdigit(ch);
001802  002006  // Notes : char specifies the ascii character for the test
001803  002007  //     : 0 : char is not an ascii hexadecimal digit.
001804  002008  //     : 1 : char is an ascii hexadecimal digit..
001805  002009  //     : Valid range is "0123456789ABCDEF"
001806  002010        
001807  002011  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
001808  002012  // Syntax: isupper("char");
001809  002013  // Usage : Var := isupper(ch);
001810  002014  // Notes : char specifies the ascii character for the test
001811  002015  //     : 0 : char is not an ascii upper-case letter.
001812  002016  //     : 1 : char is an ascii upper-case letter.
001813  002017  //     : Valid range is "ABCD....WXYZ"
001814  002018        
001815  002019  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
001816  002020  // Syntax: islower("char");
001817  002021  // Usage : Var := islower(ch);
001818  002022  // Notes : char specifies the ascii character for the test
001819  002023  //     : 0 : char is not an ascii lower-case letter.
001820  002024  //     : 1 : char is an ascii lower-case letter.
001821  002025  //     : Valid range is "abcd....wxyz"
001822  002026        
001823  002027  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
001824  002028  // Syntax: isalpha("char");
001825  002029  // Usage : Var := isalpha(ch);
001826  002030  // Notes : char specifies the ascii character for the test
001827  002031  //     : 0 : char is not an ascii lower or upper case letter.
001828  002032  //     : 1 : char is an ascii lower or upper case letter.
001829  002033  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
001830  002034        
001831  002035  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
001832  002036  // Syntax: isalnum("char");
001833  002037  // Usage : Var := isalnum(ch);
001834  002038  // Notes : char specifies the ascii character for the test
001835  002039  //     : 0 : char is not an ascii alphanumeric character.
001836  002040  //     : 1 : char is an ascii alphanumeric character.
001837  002041  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
001838  002042        
001839  002043  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
001840  002044  // Syntax: isprint("char");
001841  002045  // Usage : Var := isprint(ch);
001842  002046  // Notes : char specifies the ascii character for the test
001843  002047  //     : 0 : char is not a printable ascii character.
001844  002048  //     : 1 : char is a printable ascii character.
001845  002049  //     : Valid range is "0x20...0x7F"
001846  002050        
001847  002051  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
001848  002052  // Syntax: isspace("char");
001849  002053  // Usage : Var := isspace(ch);
001850  002054  // Notes : char specifies the ascii character for the test
001851  002055  //     : 0 : char is not a space type character.
001852  002056  //     : 1 : char is a space type character.
001853  002057  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
001854  002058        
001855  002059  //unformatted
001856  002060  func iswhite("char"), 1;    //
001857  002061  // Syntax: iswhite("char");
001858  002062  // Usage : Var := iswhite(ch);
001859  002063  // Notes : char specifies the ascii character for the test
001860  002064  //     : 0 : char is not a space or tab character.
001861  002065  //     : 1 : char is not a space or tab character.
001862  002066  //     : Valid range is space or tab
001863  002067        
001864  002068  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
001865  002069  // Syntax: toupper("char");
001866  002070  // Usage : Var := toupper(ch);
001867  002071  // Notes : char specifies the ascii character for the test
001868  002072  //     : "ABCD....XYZ" : if character is a lower case letter.
001869  002073  //     : char : if character is not a lower case letter.
001870  002074  //     : Valid range is "abcd....wxyz"
001871  002075        
001872  002076  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
001873  002077  // Syntax: tolower("char");
001874  002078  // Usage : Var := tolower(ch);
001875  002079  // Notes : char specifies the ascii character for the test
001876  002080  //     : "abcd....xyz" : if character is an upper case letter.
001877  002081  //     : char : if character is not an upper case letter.
001878  002082  //     : Valid range is "ABCD....WXYZ"
001879  002083        
001880  002084  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
001881  002085  // Syntax: LObyte(var);
001882  002086  // Usage : myVar := LObyte(myvar2);
001883  002087  // Notes : var specifies the user variable
001884  002088  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
001885  002089        
001886  002090  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
001887  002091  // Syntax: HIbyte(var);
001888  002092  // Usage : myVar := HIbyte(myvar2);
001889  002093  // Notes : var specifies the user variable
001890  002094  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
001891  002095        
001892  002096        
001893  002097  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
001894  002098  // Syntax: ByteSwap(var);
001895  002099  // Usage : myVar := ByteSwap(myvar2);
001896  002100  // Notes : var specifies the user variable
001897  002101  //     : Returns the endian swapped value of a 16 bit variable
001898  002102        
001899  002103        
001900  002104  //------------------------------------------------------------------//
001901  002105  //        Memory Allocation Function Prototypes
001902  002106  //------------------------------------------------------------------//
001903  002107        
001904  002108  func mem_Alloc("size"), 1;
001905  002109  // Syntax: mem_Alloc(bytesize);
001906  002110  // Usage : myvar := mem_Alloc(100);
001907  002111  // Notes : Allocate a block of memory to pointer myvar
001908  002112  //       : The allocated memory contains garbage but is a fast allocation.
001909  002113  //       : The block must later be released with mem_Free();
001910  002114  //       : returns 0 if function fails
001911  002115        
001912  002116  func mem_AllocV("size"), 1;
001913  002117  // Syntax: mem_AllocV(bytesize);
001914  002118  // Usage : myvar := mem_AllocV(100);
001915  002119  // Notes : Allocate a block of memory to pointer myvar
001916  002120  //       : The block of memory is filled with signature values
001917  002121  //       : the block starts with A5,5A then fills with incrementing
001918  002122  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
001919  002123  //       : This can be helpful when debugging
001920  002124  //       : The block must later be released with mem_Free();
001921  002125  //       : returns 0 if function fails
001922  002126        
001923  002127  func mem_AllocZ("size"), 1;
001924  002128  // Syntax: mem_AllocZ(bytesize);
001925  002129  // Usage : myvar := mem_AllocC(100);
001926  002130  // Notes : Allocate a zeroed block of memory to pointer myvar
001927  002131  //       : The block of memory is filled with zeroes
001928  002132  //       : The block must later be released with mem_Free();
001929  002133  //       : returns 0 if function fails
001930  002134        
001931  002135  func mem_Realloc("ptr", "size"), 1;
001932  002136  // Syntax: myvar := mem_Realloc("ptr", "size");
001933  002137  // Usage : myvar := mem_Realloc(ptr, size);
001934  002138  // Notes : The function may move the memory block to a new location,
001935  002139  //       : in which case the new location is returned.
001936  002140  //       : The content of the memory block is preserved up to the lesser
001937  002141  //       : of the new and old sizes, even if the block is moved.
001938  002142  //       : If the new size is larger, the value of the newly allocated
001939  002143  //       : portion is indeterminate. In case that ptr is NULL,
001940  002144  //       : the function behaves exactly as mem_Alloc, assigning a new block
001941  002145  //       : of size bytes and returning a pointer to the beginning of it.
001942  002146  //       : In case that the size is 0, the memory previously allocated in
001943  002147  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
001944  002148  //       : pointer is returned.
001945  002149        
001946  002150  func mem_Free("allocation"), 1;
001947  002151  // Syntax: myvar := mem_Free(allocation);
001948  002152  // Usage : myvar := mem_Free(myvar);
001949  002153  // Notes : De-allocate a block of memory previously created with
001950  002154  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
001951  002155  //       : returns 0 if function fails
001952  002156        
001953  002157  func mem_Heap(), 1;
001954  002158  // Syntax: myvar := mem_Heap();
001955  002159  // Usage : myvar := mem_Heap();
001956  002160  // Notes : returns bytecount available in heap
001957  002161  //       :
001958  002162        
001959  002163  func mem_Set("ptr","char","size"), 1;
001960  002164  // Syntax: mem_Set(ptr,char,bytesize);
001961  002165  // Usage : mem_Set(p, 'A', 100);
001962  002166  // Notes : fill a block of memory with a byte value
001963  002167  //       : returns ptr
001964  002168        
001965  002169  func mem_Copy("src", "dest", "bytecount"), 1;
001966  002170  // Syntax: myvar := mem_Copy(src, dest, bytesize);
001967  002171  // Usage : myvar := mem_Copy(p1, p2, 100);
001968  002172  // Notes : copy a word aligned block of memory from src to dest
001969  002173  //       : Note that count is a byte count, this facilitates
001970  002174  //       : copying word aligned byte arrays when using word
001971  002175  //       : aliggned packed strings.
001972  002176  //       : returns src
001973  002177        
001974  002178  func mem_Compare("ptr1","ptr2","count"), 1;
001975  002179  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
001976  002180  // Usage : myvar := mem_Compare(p1, p2, 100);
001977  002181  // Notes : compare blocks of memory at src, dest
001978  002182  //       : returns 0 if we have a match
001979  002183        
001980  002184  //------------------------------------------------------------------//
001981  002185  //        FAT16 Function Prototypes
001982  002186  //------------------------------------------------------------------//
001983  002187        
001984  002188  func file_Error(), 1;
001985  002189  // Syntax: myvar := file_Error();
001986  002190  // Usage : e := file_Error();
001987  002191  // Notes : return the most recent file error.
001988  002192  //       :
001989  002193        
001990  002194  func file_Count("filename"), 1;
001991  002195  // Syntax: count := file_Count("filename");
001992  002196  // Usage : count := file_Count("*.4dg");
001993  002197  // Notes : returns number of files found that match the criteria
001994  002198        
001995  002199  func file_Dir("filename"), 1;
001996  002200  // Syntax: count := file_Dir("filename");
001997  002201  // Usage : count := file_Dir("*.4dg");
001998  002202  // Notes : streams a string of filenames that agree with the search key
001999  002203  //       : returns number of files found that match the criteria
002000  002204        
002001  002205  func file_FindFirst("fname"), 1;
002002  002206  // Syntax: res := file_FindFirst("fname");
002003  002207  // Usage : if (file_FindFirst("*.4xe") ....
002004  002208  // Notes : returns true if at least 1 file exists
002005  002209  //       : that satisfies the file argument.
002006  002210  //       : Wildcards are usually used so if
002007  002211  //       : file_FindFirst returns true, further
002008  002212  //       : tests can be made using file_FindNext();
002009  002213  //       : to find all the files that match the
002010  002214  //       : wildcard class. Note that the stream behaviour
002011  002215  //       : is the same as file_Dir.
002012  002216  //       :
002013  002217        
002014  002218  func file_FindNext(), 1;
002015  002219  // Syntax: res := file_FindNext();
002016  002220  // Usage : while ((file_FindNext()) ....
002017  002221  // Notes : returns true if more file exists
002018  002222  //       : that satisfies the file argument
002019  002223  //       : that was given for  file_FindFirst.
002020  002224  //       : Wildcards must be used for
002021  002225  //       : file_FindFirst, else this function will
002022  002226  //       : always return zero as the only occurence
002023  002227  //       : will have already been found.
002024  002228  //       : Note that the stream behaviour
002025  002229  //       : is the same as file_Dir.
002026  002230  //       :
002027  002231        
002028  002232  func file_Exists("fname"), 1;
002029  002233  // Syntax: res := file_Exists("fname"),
002030  002234  // Usage : if(file_Exists("myfile") ....
002031  002235  // Notes : returns true if file exists
002032  002236  //       :
002033  002237        
002034  002238  func file_Open("fname", "mode"), 1;
002035  002239  // Syntax: handle := file_Open("fname","mode"),
002036  002240  // Usage : handle := file_Open("myfile.txt", 'r');
002037  002241  // Notes : returns handle if file exists
002038  002242  //       :
002039  002243        
002040  002244  func file_Close("handle"), 1;
002041  002245  // Syntax: res := file_Close("handle");
002042  002246  // Usage : res := file_Close(hnd1);
002043  002247  // Notes : returns true if file closed ok
002044  002248  //       :
002045  002249        
002046  002250  func file_Read("*dest", "size", "handle"), 1;
002047  002251  // Syntax: res := file_Read("*dest", "size", "handle"),
002048  002252  // Usage : res := file_Read(memblock,20,hnd1);
002049  002253  // Notes : returns number of characters read
002050  002254  //       : if "dest" is zero, data is read direct to GRAM window
002051  002255  //       :
002052  002256        
002053  002257        
002054  002258  func file_Seek("handle", "HiWord", "LoWord"), 1;
002055  002259  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
002056  002260  // Usage : res := file_Seek(hSource, 0, 0x1234);
002057  002261  // Notes : set file position to 0x00001234 (byte position 4660)
002058  002262  //       : for the file handle so subsequent data may be read
002059  002263  //       : from that position onwards with file_GetC(...),
002060  002264  //       : file_GetW(...) or file_GetS(...), or an image
002061  002265  //       : can be displayed with file_Image(...)
002062  002266  // Notes : returns true if ok, usually ignored
002063  002267        
002064  002268  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002065  002269  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002066  002270  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
002067  002271  // Notes : set file seek position to 123000
002068  002272  //       : for the file handle so subsequent data may be read
002069  002273  //       : from that record position onwards with file_GetC(...),
002070  002274  //       : file_GetW(...) or file_GetS(...), or an image
002071  002275  //       : can be displayed with file_Image(...)
002072  002276  // Notes : returns true if ok, usually ignored
002073  002277        
002074  002278  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
002075  002279  // Syntax: file_Tell("handle", &HiWord, &LoWord);
002076  002280  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
002077  002281  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
002078  002282  //       : returns true if function succeeded
002079  002283        
002080  002284  func file_Write("*source", "size", "handle"), 1;
002081  002285  // Syntax: res := fwrite("*source", "size", "handle"),
002082  002286  // Usage : res := fwrite(memblock, 20, hnd1);
002083  002287  // Notes : returns number of bytes written
002084  002288  //       :
002085  002289        
002086  002290  func file_Size("handle", "&HiWord", "&LoWord"), 1;
002087  002291  // Syntax: file_Size("handle", &HiWord, &LoWord);
002088  002292  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
002089  002293  // Notes : Reads the 32 bit file size and stores it into 2 variables.
002090  002294  //       : returns true if function succeeded
002091  002295        
002092  002296  func file_Image("x", "y", "handle"), 1;
002093  002297  // Syntax: file_Image(x, y, handle);
002094  002298  // Usage : file_Image(10, 10, hnd1);
002095  002299  // Notes : Display an image from a file at the current file position.
002096  002300  //       : The image is displayed at x,y (with respect to top left corner).
002097  002301  //       : If there is more than 1 image in the file, it can be
002098  002302  //       : accessed with file_Seek(...)
002099  002303        
002100  002304  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
002101  002305  // Syntax: file_ScreenCapture(x, y, w, h, handle);
002102  002306  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
002103  002307  // Notes : Save a image from screen to file at the current file position.
002104  002308  //       : The image can later be displayed with file_Image(...);
002105  002309  //       : The file may be opened in append mode to accumulate multiple
002106  002310  //       : images. Later, the images can be accessed with file_Seek(...);
002107  002311  //       : Note that the image will be sector aligned.
002108  002312  //       : All image headers must start on a sector boundary.
002109  002313  //       : The image is saved from x, y (with respect to top left corner)
002110  002314  //       : and the capture area is determined by "width" and "height".
002111  002315  //       : returns 0 if function succeeded
002112  002316        
002113  002317  func file_PutC("char","handle"), 1;
002114  002318  // Syntax: file_PutC("char", "handle");
002115  002319  // Usage : file_PutC('x', hndl);
002116  002320  // Notes : returns true if function succeeded
002117  002321        
002118  002322  func file_GetC("handle"), 1;
002119  002323  // Syntax: file_GetC("handle");
002120  002324  // Usage : mychar := fgetC("handle");
002121  002325  // Notes : returns next char from file
002122  002326        
002123  002327  func file_PutW("word","handle"), 1;
002124  002328  // Syntax: file_PutW("word","handle");
002125  002329  // Usage : file_PutW(0x1234, hndl);
002126  002330  // Notes : returns true if function succeeded
002127  002331        
002128  002332  func file_GetW("handle"), 1;
002129  002333  // Syntax: file_GetW("handle");
002130  002334  // Usage : myword := fgetW("handle");
002131  002335  // Notes : returns next word in file
002132  002336        
002133  002337  func file_PutS("*source", "handle"), 1;
002134  002338  // Syntax: res := file_Puts("*source", "handle"),
002135  002339  // Usage : res := file_Puts(mystring, hnd1);
002136  002340  // Notes : returns number of characters written
002137  002341  //       :
002138  002342        
002139  002343  func file_GetS("*string", "size", "handle"), 1;
002140  002344  // Syntax: res := file_Gets("*string", "size", "handle");
002141  002345  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
002142  002346  // Notes : get a string from a file
002143  002347  //       : returns pointer to string or null if failed.
002144  002348  //       : file_GetS(...) automatically appends a null-terminator to the data read.
002145  002349  //       : NB:- only reads up to "size-1" characters into "string"
002146  002350  //       : file_GetS(...) will stop reading when any of the following conditions are true:
002147  002351  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
002148  002352  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
002149  002353  //       : C] It reaches the end of file
002150  002354  //       : D] A read error occurs.
002151  002355        
002152  002356        
002153  002357  func file_Erase("fname"), 1;
002154  002358  // Syntax: res := file_Erase("fname");
002155  002359  // Usage : res := file_Erase("myfile.txt");
002156  002360  // Notes : returns true if successful
002157  002361  //       :
002158  002362        
002159  002363  func file_Rewind("handle"), 1;
002160  002364  // Syntax: res := file_Rewind("handle");
002161  002365  // Usage : res := file_Rewind(hnd1);
002162  002366  // Notes : returns true if file rewound ok (usually ignored)
002163  002367  //       : resets the file pointer the the beginning of the open file.
002164  002368        
002165  002369  func file_LoadFunction("fname.4xe"), 1;
002166  002370  // Syntax: res := file_LoadFunction("fname.4fn");
002167  002371  // Usage : myfunc := file_LoadFunction(myfuncname);
002168  002372  // Notes : Load a function or program from disk and
002169  002373  //       : return a function pointer to the allocation.
002170  002374  //       : The function can then be invoked just like any other
002171  002375  //       : function would be called via a function pointer.
002172  002376  //       : Parameters may be passed to it in a conventional way.
002173  002377  //       : The function may be discarded at any time when no
002174  002378  //       : longer required, thus freeing its memory resources.
002175  002379  //       : The loaded function can be discarded with mem_Free(..)
002176  002380  //       : eg:
002177  002381  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
002178  002382  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
002179  002383  //       : then elsewhere in your program:-
002180  002384  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
002181  002385  //       : if(res == QUIT_APPLICATION) goto exitApp;
002182  002386  //       : Later in your program, when popupWindow is no longer
002183  002387  //       : required for the application:-
002184  002388  //       : res := mem_Free(popupWindow);
002185  002389  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
002186  002390  //       : The callers stack is shared by the loaded function,
002187  002391  //       : however any global variables in the loaded function
002188  002392  //       : are private to that function.
002189  002393  //
002190  002394        
002191  002395  func file_Run("fname.4xe", "arglistptr"), 1;
002192  002396  // Syntax: res := file_Run("fname.4xe","arglistptr");
002193  002397  // Usage : res := file_Run(fname, argptr);
002194  002398  // Notes : current program releases any allocated memory but
002195  002399  //       : retains the stack and global memory.
002196  002400  //       : If arglistptr is 0, no arguments are passed, else
002197  002401  //       : arglist points to an array, the first element being
002198  002402  //       : the number of elements in the array.
002199  002403  //       : func 'main' in the called program accepts
002200  002404  //       : the arguments, if any. THe arguments can only
002201  002405  //       : be passed by value, no pointers or references can be
002202  002406  //       : used as all memory is cleared before the file
002203  002407  //       : is loaded. Refer to file_Exec and file_LoadFunction
002204  002408  //       : for functions that can pass by reference.
002205  002409        
002206  002410  func file_Exec("fname.4xe", "arglistptr"), 1;
002207  002411  // Syntax: res := file_Exec("fname.4xe","arglistptr");
002208  002412  // Usage : res := file_Exec("fname.4xe","arglistptr");
002209  002413  // Notes : returns like a function, current program
002210  002414  //       : calling program is kept active and control returns to it.
002211  002415  //       : If arglistptr is 0, no arguments are passed, else
002212  002416  //       : arglist points to an array, the first element being
002213  002417  //       : the number of elements in the array.
002214  002418  //       : func 'main' in the called program accepts the arguments.
002215  002419  //       : This function is similar to file_LoadFunction(...), however,
002216  002420  //       : the function argument list is passed by pointer, and
002217  002421  //       : the memory consumed by the function is released as
002218  002422  //       : soon as the function completes.
002219  002423        
002220  002424  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
002221  002425  // Syntax: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
002222  002426  // Usage : hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
002223  002427  // Notes : Reads a control file to create an image list.
002224  002428  //       : Returns NULL if function fails.
002225  002429  //       : Returns a handle (pointer to the memory allocation) to the
002226  002430  //       : image control list that has been created.
002227  002431  //       : "fname1" is the control list filename "*.dat"
002228  002432  //       : "fname2" is the image filename "*.gci"
002229  002433        
002230  002434  // Notes : This function Calculates the size of a chunk of memory required for
002231  002435  //       : a image list and populates it from the image control file ("*.dat")
002232  002436  //       : therefore, when imagelist is no longer required, you must de-allocate
002233  002437  //       : the image list memory by using eg:- mem_Free(hImagelist);
002234  002438  //       : to restore the heap.
002235  002439  //       :
002236  002440  //       : mode 0:- it is assumed that there is a graphics file with the
002237  002441  //       : file extension "fname2.gci". In this case, the images have been stored
002238  002442  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
002239  002443  //       : "fname1.dat" file are saved in the image control so that the image control
002240  002444  //       : can open the file (*.gci) and us file_Seek to get to the position of the
002241  002445  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
002242  002446  //       : mode 0 builds the image control quickly as it only scans the *.dat file
002243  002447  //       : for the file offsets and save them in the relevant entries in the image control.
002244  002448  //       : The penalty is that images take longer to find when displayed due to file_Seek
002245  002449  //       : overheads.
002246  002450  //
002247  002451  //       : mode 1:- it is assumed that there is a graphics file with the
002248  002452  //       : file extension "fname2.gci". In this case, the images have been stored
002249  002453  //       : in a FAT16 file concurrently, and the offset of the images are saved
002250  002454  //       : in the image control so that image file (*.gci) can be mapped to directly.
002251  002455  //       : The absolute cluster/sector is mapped so file seek does not need to be called
002252  002456  //       : internally. This means that there is no seek time penalty, however, the
002253  002457  //       : image list takes a lot longer to build, as all the seeking is done at control
002254  002458  //       : build time.
002255  002459        
002256  002460  //       : mode 2:- the graphics file with the is placed in a partitioned area
002257  002461  //       : In this case, the images have been stored in a in a known raw area of the FAT16
002258  002462  //       : disk, and the absolute address of the images are saved in the DAT file
002259  002463  //       : This is the fastest operation of the image control as there is no seeking
002260  002464  //       : or other disk activity taking place.
002261  002465        
002262  002466  func file_Mount(), 1;
002263  002467  // Syntax: r := file_Mount();
002264  002468  // Usage : r := file_Mount();
002265  002469  // Notes : Create a control block for FAT16 and mount the File System
002266  002470        
002267  002471  func file_Unmount(), 0;
002268  002472  // Syntax: file_Unmount();
002269  002473  // Usage : file_Unmount();
002270  002474  // Notes : release any control block and buffers for FAT16
002271  002475  //       : and unmount the File System
002272  002476        
002273  002477  func file_PlayWAV("fname1"), 1;
002274  002478  // Syntax: file_PlayWAV("fname1");
002275  002479  // Usage : file_PlayWAV("ding.wav");
002276  002480  // Notes : Play a wave file with filename "fname1"
002277  002481  //       : This function automatically grabs a chunk
002278  002482  //       : of memory for a file buffer, and a wave
002279  002483  //       : buffer. The minimum memory requirement is
002280  002484  //       : about 580 bytes for the disk io service and
002281  002485  //       : a minimum wave buffer size of 1024. The siz
002282  002486  //       : of the wave buffer allocation
002283  002487  //       : can be increased by the snd_BufSize function.
002284  002488  //       : The default size 1024 bytes.
002285  002489  //       : NB the memory is only required during the
002286  002490  //       : duration of play, and is automatically
002287  002491  //       : released while not in use.
002288  002492  //       : See the Sound Class services for other associated controls.
002289  002493  //       : If there are no errors, returns number of blocks to play (1 to 32767)
002290  002494  //       : If errors occured, the folling is returned
002291  002495  //       : -7  : Insufficient memory available for WAV buffer and file
002292  002496  //       : -6  : cant play this rate
002293  002497  //       : -5  : no data chunk found in first rsector
002294  002498  //       : -4  : no format data
002295  002499  //       : -3  : no wave chunk signature
002296  002500  //       : -2  : bad wave file format
002297  002501  //       : -1  : file not found
002298  002502        
002299  002503        
002300  002504        
002301  002505  //------------------------------------------------------------------//
002302  002506  //        Sound Class Services
002303  002507  //------------------------------------------------------------------//
002304  002508        
002305  002509  func snd_Volume("var"), 0;
002306  002510  // Syntax: snd_Volume("var");
002307  002511  // Usage : snd_Volume(30);
002308  002512  // Notes : set sound playback volume.  Var must
002309  002513  //       : be in the range from 8 (min volume)
002310  002514  //       : to 127 (max volume). If var is less
002311  002515  //       : than 8 volume is set to 8, and if
002312  002516  //       : var > 127 it is set to 127.
002313  002517        
002314  002518  func snd_Pitch("pitch"), 1;
002315  002519  // func snd_Pitch("freq"), 1;
002316  002520  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
002317  002521  // Notes : sets the samples playback rate to a different frequency
002318  002522  //       : The minimum value is 4khz
002319  002523  //       : Setting the pitch to zero restores the original sample rate
002320  002524  //       : Return value is the samples original sample rate.
002321  002525        
002322  002526  func snd_BufSize("var"), 0;
002323  002527  // Syntax: snd_BufSize("var");
002324  002528  // Usage : snd_BufSize(2);
002325  002529  // Notes : specify the a memory chunk size for the wavefile buffer.
002326  002530  //       : default size 1024 bytes.
002327  002531  //       : 0 = 1024 bytes (default)
002328  002532  //       : 1 = 2048 bytes
002329  002533  //       : 2 = 4096 bytes
002330  002534  //       : 3 = 8192 bytes
002331  002535        
002332  002536  func snd_Stop(), 0;
002333  002537  // Syntax: snd_Stop();
002334  002538  // Usage : snd_Stop();
002335  002539  // Notes : stop any sound that is playing, releasing
002336  002540  //       : buffers and closes any open wav file.
002337  002541        
002338  002542  func snd_Pause(), 0;
002339  002543  // Syntax: snd_Pause();
002340  002544  // Usage : snd_Pause();
002341  002545  // Notes : pauses any sound that is playing, does nothing
002342  002546  //       : until sound is resumed with snd_Continue().
002343  002547  //       : The sample cam be terminated with snd_Stop.
002344  002548  //       : buffers and closes any open wav file.
002345  002549        
002346  002550  func snd_Continue(), 0;
002347  002551  // Syntax: snd_Continue();
002348  002552  // Usage : snd_Continue();
002349  002553  // Notes : resume any sound that is paused by snd_Pause.
002350  002554        
002351  002555  func snd_Playing(), 1;
002352  002556  // Syntax: snd_Playing();
002353  002557  // Usage : r := snd_Playing();
002354  002558  // Notes : returns 0 if sound has finished playing,
002355  002559  //       : else return number of 512 byte blocks to go.
002356  002560        
002357  002561        
002358  002562        
002359  002563  //------------------------------------------------------------------//
002360  002564  //        String Class Services
002361  002565  //------------------------------------------------------------------//
002362  002566        
002363  002567  func str_Ptr("&var"), 1;
002364  002568  // Syntax: str_Ptr(&var);
002365  002569  // Usage : p := str_Ptr(&var);
002366  002570  // Notes : return a byte pointer to a word region
002367  002571        
002368  002572  func str_GetD("&ptr", "&var"), 1;
002369  002573  // Syntax: str_GetD(&ptr, &var);
002370  002574  // Usage : ok := str_GetD(&ptr, &var);
002371  002575  // Notes : convert number in a string to DWORD ( myvar[2] )
002372  002576  //       : returns true if function succeeds, advancing ptr
002373  002577        
002374  002578  func str_GetW("&ptr", "&var"), 1;
002375  002579  // Syntax: str_GetW(&ptr, &var);
002376  002580  // Usage : ok := str_GetW(&ptr, &var);
002377  002581  // Notes : convert number in a string to WORD ( myvar )
002378  002582  //       : returns true if function succeeds, advancing ptr
002379  002583        
002380  002584  func str_GetHexW("&ptr", "&var"), 1;
002381  002585  // Syntax: str_GetHexW(&ptr, &var);
002382  002586  // Usage : ok := str_GetHexW(&ptr, &var);
002383  002587  // Notes : convert HEX number in a string to WORD ( myvar )
002384  002588  //       : returns true if function succeeds, advancing ptr
002385  002589        
002386  002590  func str_GetC("&ptr", "&var"), 1;
002387  002591  // Syntax: str_GetC(&ptr, &var);
002388  002592  // Usage : ok := str_GetC(&ptr, &var);
002389  002593  // Notes : get a valid ascii char in a string to WORD ( myvar )
002390  002594  //       : returns true if function succeeds, advancing ptr
002391  002595        
002392  002596  func str_GetByte("ptr"), 1;
002393  002597  // Syntax: str_GetByte(ptr);
002394  002598  // Usage : myvar := str_GetByte(ptr);
002395  002599  // Notes : get a byte to myvar
002396  002600  //       : returns value
002397  002601        
002398  002602  func str_GetWord("ptr"), 1;
002399  002603  // Syntax: GetWord(ptr);
002400  002604  // Usage : GetWord(ptr);
002401  002605  // Notes : get a word to myvar
002402  002606  //       : returns value
002403  002607        
002404  002608  func str_PutByte("ptr","val"), 0;
002405  002609  // Syntax: str_PutByte(ptr);
002406  002610  // Usage : myvar := str_PutByte(ptr);
002407  002611  // Notes : put a byte at ptr
002408  002612  //       : returns value
002409  002613        
002410  002614  func str_PutWord("ptr","val"), 0;
002411  002615  // Syntax: str_PutWord("ptr","val");
002412  002616  // Usage : str_PutWord(p,100);
002413  002617  // Notes : put word 100 at current pointer location
002414  002618  //       : returns value
002415  002619        
002416  002620  func str_Match("&ptr", "*str"), 1;
002417  002621  // Syntax: str_Match(&ptr, *str);
002418  002622  // Usage : r := str_Match(&p, "hello");
002419  002623  // Notes : Case sensitive match
002420  002624  //       : returns true if function succeded, andvancing pointer to position past
002421  002625  //       : the matched item. Note that any whitespace characters are skipped
002422  002626  //       : in the source string prior to the test.
002423  002627        
002424  002628  func str_MatchI("&ptr", "*str"), 1;
002425  002629  // Syntax: str_MatchI(&ptr, *str);
002426  002630  // Usage : r := str_MatchI(&p, "hello");
002427  002631  // Notes : Case insensitive match
002428  002632  //       : returns true if function succeded, andvancing pointer to position past
002429  002633  //       : the matched item. Note that any whitespace characters are skipped
002430  002634  //       : in the source string prior to the test.
002431  002635        
002432  002636  func str_Find("&ptr", "*str"), 1;
002433  002637  // Syntax: str_Find(&ptr, *str);
002434  002638  // Usage : n := str_Find(&p, "hello");
002435  002639  // Notes : given the address of a pointer to a source string as the
002436  002640  //       : first argument, and a pointer to a test string as the second
002437  002641  //       : argument, attempt to find the position of the matching string
002438  002642  //       : in the source string. The test is performed with case sensitivity.
002439  002643  //       : return 0 if not found, else returns the address of the first
002440  002644  //       : character of the match. NB:- The source pointer is not altered.
002441  002645        
002442  002646  func str_FindI("&ptr", "*str"), 1;
002443  002647  // Syntax: str_Find(&ptr, *str);
002444  002648  // Usage : n := str_Find(&p, "hello");
002445  002649  // Notes : given the address of a pointer to a source string as the
002446  002650  //       : first argument, and a pointer to a test string as the second
002447  002651  //       : argument, attempt to find the position of the matching string
002448  002652  //       : in the source string. The test is performed with no case
002449  002653  //       : sensitivity, eg upper and lower case chars are accepted.
002450  002654  //       : return 0 if not found, else returns the address of the first
002451  002655  //       : character of the match. NB:- The source pointer is not altered.
002452  002656        
002453  002657  func str_Length("ptr"), 1;
002454  002658  // Syntax: str_Length(ptr);
002455  002659  // Usage : len := str_Ptr(mystring);
002456  002660  // Notes : return the length of a byte aligned string excluding terminator
002457  002661        
002458  002662  func str_Printf("&ptr", "*format"), 1;
002459  002663  // Syntax: str_Printf("&ptr", "*format");
002460  002664  // Usage : r := str_Printf(&p, "%8s");
002461  002665  // Notes : refer to documentation
002462  002666  //       :
002463  002667        
002464  002668  func str_Cat("dest","src"), 1;
002465  002669  // Syntax: str_Append("&dest","&src");
002466  002670  // Usage : str_Append(&buf,"Hello");
002467  002671  // Notes : Appends a copy of the source string to the destination string.
002468  002672  //       : The terminating null character in destination is overwritten by
002469  002673  //       : the first character of source, and a new null-character is appended
002470  002674  //       : at the end of the new string formed by the concatenation of both in destination.
002471  002675  //       : returns destination.
002472  002676        
002473  002677  func str_CatN("dest","src","count"), 1;
002474  002678  // Syntax: str_Append("&dest","&src","count");
002475  002679  // Usage : str_Append(&buf,"Monday",3);
002476  002680  // Notes : Appends a copy of the source string to the destination string.
002477  002681  //       : The number of characters copied is limited by "count".
002478  002682  //       : The terminating null character in destination is overwritten by
002479  002683  //       : the first character of source, and a new null-character is appended
002480  002684  //       : at the end of the new string formed by the concatenation of both in destination.
002481  002685  //       : returns destination.
002482  002686        
002483  002687        
002484  002688  func sys_StoreTouchCalibration(), 1;
002485  002689  // Syntax: sys_StoreTouchCalibration();
002486  002690  // Usage : r := sys_StoreTouchCalibration();
002487  002691  // Notes : Store the touch calibration values in non-volatile memory.
002488  002692  //       : Returns true if the values have been accepted and stored,
002489  002693  //       : else returns false if write could not be performed, or
002490  002694  //       : touch calibration values are improbable.
002491  002695  //       : The values that are stored are obtained from:-
002492  002696  //     : TOUCH_XMINCAL             78  // touch calibration value
002493  002697  //     : TOUCH_YMINCAL             79  // touch calibration value
002494  002698  //       : TOUCH_XMAXCAL             80  // touch calibration value
002495  002699  //       : TOUCH_YMAXCAL             81  // touch calibration value
002496  002700  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
002497  002701  //       : This function is not supported on uVGA, Capicitive touch
002498  002702  //       : and 4.3" resistive touch modules.
002499  002703        
002500  002704        
002501  002705  func unicode_page("charbeg","charend","charoffset"), 1;
002502  002706  // Syntax: unicode_page("charbeg","charend","charoffset");
002503  002707  // Usage : eg:  F_Traditional_0x20_0xFF
002504  002708  // Notes : After selecting a unicode image control with txt_FontID,
002505  002709  //       : this function is called to set the required font within the
002506  002710  //       : unicode set. The file "Unicode.inc" contains wrappers for
002507  002711  //       : this function, and it is not normally called directly.
002508  002712  //       : Returns count of characters in the set.
002509  002713  //       : Refer to "Unicode.inc" for further information.
002510  002714        
002511  002715        
002512  002716  func EVE_SP(), 1;
002513  002717  // Syntax: EVE_SP();
002514  002718  // Usage : eg:  print(EVE_SP());
002515  002719  // Notes : Used for debugging to assess the current stack level,
002516  002720  //       : mainly for checking stack leaks
002517  002721        
002518  002722  func EVE_SSIZE(), 1;
002519  002723  // Syntax: EVE_SSIZE();
002520  002724  // Usage : eg:  print(EVE_SSIZE());
002521  002725  // Notes : Used to get the stack size,
002522  002726  //       : mainly for debugging purposes
002523  002727        
002524  002728        
002525  002729  // uVGAII extended functions
002526  002730  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
002527  002731  // Syntax: disp_Sync(line);
002528  002732  // Usage : disp_Sync(480);
002529  002733  // Notes : Waits till the hardware gets to a certain line.
002530  002734  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
002531  002735  //       : Some experimentation may be needed to find an optimum line for disp_Sync
002532  002736  //       : depending on the graphics operation. The higher the value, the slower
002533  002737  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
002534  002738  //       : within the vertical retrace period) where it will just 'hang up' stopping the
002535  002739  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
002536  002740  //       : be slowest (as its actually right at the end of the blanking period) and 508
002537  002741  //       : will cause a hangup situation as it is above the highes scanline value.
002538  002742  //       : Currently, this function is only supported on displays with SSD1963 driver.
002539  002743        
002540  002744        
002541  002745  // New functions added to PmmC v2.8
002542  002746  //================================================================
002543  002747  func CY(), 1;
002544  002748  // Syntax: CY();
002545  002749  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
002546  002750  //       : print(myvar," "CY(),"\n");           // carry = 1
002547  002751  // Notes : This function returns the carry status of an
002548  002752  // unsigned overflow from any 16 or 32bit additions or sutractions.
002549  002753  //================================================================
002550  002754        
002551  002755        
002552  002756  //================================================================
002553  002757  func str_ByteMove("src", "dest", "count"), 1;
002554  002758  // func str_ByteMove("src", "dest", "count"), 1;
002555  002759  // Syntax   : str_ByteMove(src, dest, bytecount);
002556  002760  // Input    : STR *source points to byte aligned source.
002557  002761  //          : STR *dest   points to byte aligned destination.
002558  002762  //          : VAR count   number of bytes to transfer.
002559  002763  // Usage    : nextpos := str_ByteMove(s, d, 100);
002560  002764  // Notes    : copy bytes from "src" to "dest", stopping only
002561  002765  //          : when "count" is exhausted.
002562  002766  //          : No terminator is appended, it is purely a
002563  002767  //          : byte copy, and any zeroes encountered will
002564  002768  //          : also be copied.
002565  002769  // Returns  : returns a pointer to the end of the destination
002566  002770  //          : (which is "dest" + "count")
002567  002771  //================================================================
002568  002772        
002569  002773        
002570  002774  //================================================================
002571  002775  func str_Copy("dest", "src"), 1;
002572  002776  // Syntax   : str_Copy(dest, src);
002573  002777  // Input    : STR *dest   points to byte aligned destination.
002574  002778  //          : STR *source points to byte aligned source.
002575  002779  // Usage    : nextplace := str_Copy(d, s);
002576  002780  // Notes    : copy a string from "src" to "dest", stopping only
002577  002781  //          : when the end of source string "src" is encountered
002578  002782  //          : (0x00 terminator).
002579  002783  //          : The terminator is always appended, even if "src" is
002580  002784  //          : an empty string.
002581  002785  // Returns  : returns a pointer to the 0x00 string terminator at
002582  002786  //          : end of "dest" (which is "dest" + str_Length(src); )
002583  002787  //================================================================
002584  002788        
002585  002789  //================================================================
002586  002790  func str_CopyN("dest", "src", "count"), 1;
002587  002791  // Syntax   : str_CopyN(dest, src, bytecount);
002588  002792  // Input    : STR *dest   points to byte aligned destination.
002589  002793  //          : STR *source points to byte aligned source.
002590  002794  //          : VAR count   max number of chars to copy.
002591  002795  // Usage    : nextplace := str_CopyN(d, s, 100);
002592  002796  // Notes    : copy a string from "src" to "dest", stopping only
002593  002797  //          : when "count" is exhausted, or end of source
002594  002798  //          : string "str" is encountered (0x00 string terminator).
002595  002799  //          : The terminator is always appended, even if
002596  002800  //          : "count" is zero, or "src" is a null string.
002597  002801  // Returns  : returns a pointer to the 0x00 string terminator
002598  002802  //          : (which is "dest" + whatever was copied)
002599  002803  //================================================================
002600  002804        
002601  002805  //================================================================
002602  002806  func umul_1616("&res32", "val1", "val2"), 1;
002603  002807  // Syntax   : umul_1616(&res32, varA, varB);
002604  002808  // Input    : DWORD *result   points to 32bit result register.
002605  002809  //          : VAR   val1  16bit register or constant
002606  002810  //          : VAR   val2  16bit register or constant
002607  002811  // Usage    : var res32[2];
002608  002812  //          : umul_1616(&res32, myvar, 50000);
002609  002813  // Notes    : performs an unsigned multiply of 2 x 16bit values
002610  002814  //          : placing the 32bit result in a 2 word array.
002611  002815  // Returns  : the pointer to the 32bit result.
002612  002816  //          : carry and overflow are not affected.
002613  002817  //================================================================
002614  002818        
002615  002819  //================================================================
002616  002820  func uadd_3232("&res32", "&val1", "&val2"), 1;
002617  002821  // Syntax   : cmp_3232(&res32, &varA, &varB);
002618  002822  // Input    : DWORD *res32 points to optional result (or zero for compare)
002619  002823  //          : DWORD *val1 points to 32bit augend
002620  002824  //          : DWORD *val2 points to 32bit addend
002621  002825  // Usage    : var res32[2];
002622  002826  //          : res := cmp_3232(res32, val1, val2);
002623  002827  // Notes    : performs an unsigned addition of 2 x 32bit values
002624  002828  //          : placing the 32bit result in a 2 word array.
002625  002829  // Returns  : returns 1 on 32bit unsigned overflow (carry).
002626  002830  //          ; carry flag is also set on 32bit unsigned overflow
002627  002831  //          ; and can be read with the CY() function.
002628  002832  //================================================================
002629  002833        
002630  002834  //================================================================
002631  002835  func usub_3232("&res32", "&val1", "&val2"), 1;
002632  002836  // Syntax   : cmp_3232(&res32, &varA, &varB);
002633  002837  // Input    : DWORD *res32 points to optional result (or zero for compare)
002634  002838  //          : DWORD *val1 points to first 32bit minuend
002635  002839  //          : DWORD *val2 points to 32bit subtrahend
002636  002840  // Usage    : var res32[2];
002637  002841  //          : res := cmp_3232(res32, val1, val2);
002638  002842  // Notes    : performs an unsigned subtraction of 2 x 32bit values
002639  002843  //          : placing the 32bit result in a 2 word array.
002640  002844  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
002641  002845  //          ; carry flag is also set on 32bit unsigned underflow
002642  002846  //          ; and can be read with the CY() function.
002643  002847  //================================================================
002644  002848        
002645  002849  //================================================================
002646  002850  func ucmp_3232("&val1", "&val2"), 1;
002647  002851  // Syntax   : cmp_3232(&varA, &varB);
002648  002852  // Input    : DWORD *val1 points to 32bit minuend
002649  002853  //          : DWORD *val2 points to 32bit sutrahend
002650  002854  // Usage    : res := cmp_3232(val1, val2);
002651  002855  // Notes    : performs an unsigned comparison of 2 x 32bit values.
002652  002856  //          : The result of the subtraction is returned.
002653  002857  // Returns  : 0  if equal
002654  002858  //          : 1  if val1 > val2
002655  002859  //          : -1 if val1 < val2
002656  002860  //          : This function does not affect the carry flag.
002657  002861  //================================================================
002658  002862        
002659  002863  func disp_Disconnect(), 0;                     // Disconnect display to ensure reduced power after disabling peripheral power. New in v3.8
002660  002864  // Syntax: disp_Disconnect();                  New in v3.8
002661  002865  // Usage : disp_Disconnect();
002662  002866  // Notes : Disconnects the display driver pins and/or reconfigures it to achieve
002663  002867  //       : its lowest possible power consumption. Use after disabling peripheral power
002664  002868  //       : to ensure the minimal power usage by the display.
002665  002869  //       : disp_Init() should be used to reinitialise the display.
002666  002870        
002667  002871  func reserved(), 0;                            
002668  002872        
002669  002873  func sys_DeepSleep("units"), 1;
002670  002874  // Syntax: t := sys_DeepSleep("units");       New in v3.8
002671  002875  // Usage : t := sys_DeepSleep(10);
002672  002876  // Notes : sets the display and processor into lowest power mode for a period of time.
002673  002877  //       : When returning from DeepSleep the display should be reinitialised
002674  002878  //       : with disp_Init().
002675  002879  //       : Touching the touch screen will also wake from sleep.
002676  002880  //       : Returns remaining sleep units.
002677  002881        
002678  002882  //------------------------------------------------------------------//
002679  002883  // CONSTANTS
002680  002884  //------------------------------------------------------------------//
002681  002885        
002682  002886  // generic constants
002683  002887  #CONST
002684  002896  #END
002685  002897        
002686  002898  //------------------------------------------------------------------------------
002687  002899  // Pin related constants
002688  002900  //------------------------------------------------------------------------------
002689  002901  #CONST
002690  002919  #END
002691  002920        
002692  002921  //------------------------------------------------------------------------------
002693  002922  //gfx_Set() related constants
002694  002923  //------------------------------------------------------------------------------
002695  002924  #CONST
002696  002941  #END
002697  002942        
002698  002943        
002699  002944  //gfx_Get() related constants
002700  002945  #CONST
002701  002954  #END
002702  002955        
002703  002956        
002704  002957        
002705  002958        
002706  002959  #CONST
002707  002972  #END
002708  002973        
002709  002974        
002710  002975  #CONST
002711  002998  #END
002712  002999        
002713  003000  //------------------------------------------------------------------------------
002714  003001  //txt_Set() related constants
002715  003002  //------------------------------------------------------------------------------
002716  003003  #CONST
002717  003022  #END
002718  003023        
002719  003024        
002720  003025        
002721  003026  //------------------------------------------------------------------------------
002722  003027  //txt_Set() related arguments
002723  003028  // NB:- FONT4 must be inherited if required,
002724  003029  // eg #inherit "FONT4.fnt"
002725  003030  //------------------------------------------------------------------------------
002726  003031  #CONST
002727  003043  #END
002728  003044        
002729  003045        
002730  003046        
002731  003047  //touch_Set() related constants
002732  003048  #CONST
002733  003052  #END
002734  003053        
002735  003054  //touch_Get() related constants
002736  003055  #CONST
002737  003063  #END
002738  003064        
002739  003065  // image control offset related constants
002740  003066  #CONST
002741  003073  #END
002742  003074        
002743  003075  // image attribute flags
002744  003076  // for img_SetAttributes(...) and img_ClearAttributes(...)
002745  003077  #CONST
002746  003091  #END
002747  003092        
002748  003093        
002749  003094  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002750  003094  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002751  003095        
002752  003096  // image control entry offsets
002753  003097  #CONST
002754  003112  #END
002755  003113        
002756  003114  #CONST
002757  003132  #END
002758  003133        
002759  003134        
002760  003135        
002761  003136        
002762  003137  #CONST
002763  003157  #END
002764  003158        
002765  003159        
002766  003160        
002767  003161  // timer control  related constants
002768  003162  #CONST
002769  003171  #END
002770  003172        
002771  003173  // I2C timing related constants
002772  003174  #CONST
002773  003178  #END
002774  003179        
002775  003180        
002776  003181  // spi_Init(...)  mode arguments
002777  003182  #CONST
002778  003192  #END
002779  003193        
002780  003194  //------------------------------------------------------------------------------
002781  003195  // system WORD variables accesible with peekW and pokeW or pointer access
002782  003196  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
002783  003197  // can also be accessed with peekW and pokeW
002784  003198  //------------------------------------------------------------------------------
002785  003199        
002786  003200  #CONST
002787  003294  #END
002788  003295        
002789  003296  //------------------------------------------------------------------------------
002790  003297  // FILEIO Error Code Constants
002791  003298  //------------------------------------------------------------------------------
002792  003299  #CONST
002793  003325  #END
002794  003326        
002795  003327  //==================================================================================================
002796  003328        
002797  003329        
002798  003330        
002799  000013      #ENDIF
002800  000014        
002801  000015        
002802  000016         #CONST
002803  000102      #END
002804  000103        
002805  000104  #constant TOUCH_DRIVE 78      // external pointing device control for gfx_Set(TOUCH_DRIVE, command);
002806  000104  #constant TOUCH_DRIVE 78      // external pointing device control for gfx_Set(TOUCH_DRIVE, command);
002807  000105        
002808  000106        
002809  000107        
002810  000108        
002811  000109        
002812  000110  //===========================================================================================
002813  000111        
002814  000112        
002815  000002        
002816  000003        
002817  000004  // generated 18/06/2021 14:14:18
002818  000005        
002819  000006  #MODE RUNFLASH
002820  000007        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

002821  000008  #inherit "4DGL_16bitColours.fnc"
002822  000008  #inherit "4DGL_16bitColours.fnc"
002823  000004  */
002824  000005        
002825  000006        
002826  000007        
002827  000008  #CONST
002828  000149  #END
002829  000150        
002830  000009        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

002831  000010  #inherit "VisualConst.inc"
002832  000010  #inherit "VisualConst.inc"
002833  000001  // Line Patterns
002834  000002  #constant  LPCOARSE    0xF0F0
002835  000002  #constant  LPCOARSE    0xF0F0
002836  000003  #constant  LPMEDIUM    0x3333
002837  000003  #constant  LPMEDIUM    0x3333
002838  000004  #constant  LPFINE      0xAAAA
002839  000004  #constant  LPFINE      0xAAAA
002840  000005  #constant  LPDASHDOT   0x03CF
002841  000005  #constant  LPDASHDOT   0x03CF
002842  000006  #constant  LPDASHDOTDOT 0x0333
002843  000006  #constant  LPDASHDOTDOT 0x0333
002844  000007  #constant  LPSOLID     0x0000
002845  000007  #constant  LPSOLID     0x0000
002846  000011        
002847  000012        
file G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\PrototipConst.inc

002848  000013  #inherit "PrototipConst.inc"
002849  000013  #inherit "PrototipConst.inc"
002850  000001  // File generated 18/06/2021 14:12:53
002851  000002  // Warning! This is a generated file, any manual changes will be
002852  000003  // lost during the next generation.
002853  000004        
002854  000005  #constant  Strings8Count    0
002855  000005  #constant  Strings8Count    0
002856  000006  #constant  Strings8Size     1
002857  000006  #constant  Strings8Size     1
002858  000007  #constant  Strings10Count    0
002859  000007  #constant  Strings10Count    0
002860  000008  #constant  Strings10Size     1
002861  000008  #constant  Strings10Size     1
002862  000009  #constant  Strings0Count    0
002863  000009  #constant  Strings0Count    0
002864  000010  #constant  Strings0Size     1
002865  000010  #constant  Strings0Size     1
002866  000011  #constant  Strings1Count    0
002867  000011  #constant  Strings1Count    0
002868  000012  #constant  Strings1Size     1
002869  000012  #constant  Strings1Size     1
002870  000013  #constant  Strings7Count    0
002871  000013  #constant  Strings7Count    0
002872  000014  #constant  Strings7Size     1
002873  000014  #constant  Strings7Size     1
002874  000015  #constant  Strings4Count    0
002875  000015  #constant  Strings4Count    0
002876  000016  #constant  Strings4Size     1
002877  000016  #constant  Strings4Size     1
002878  000017  #constant  Strings5Count    0
002879  000017  #constant  Strings5Count    0
002880  000018  #constant  Strings5Size     1
002881  000018  #constant  Strings5Size     1
002882  000019  #constant  Strings6Count    0
002883  000019  #constant  Strings6Count    0
002884  000020  #constant  Strings6Size     1
002885  000020  #constant  Strings6Size     1
002886  000021  #constant  Strings2Count    0
002887  000021  #constant  Strings2Count    0
002888  000022  #constant  Strings2Size     1
002889  000022  #constant  Strings2Size     1
002890  000023  #constant  Strings3Count    0
002891  000023  #constant  Strings3Count    0
002892  000024  #constant  Strings3Size     1
002893  000024  #constant  Strings3Size     1
002894  000025  #constant  IFONT_OFFSET     0
002895  000025  #constant  IFONT_OFFSET     0
002896  000026  // object indexes into ImageControl
002897  000027  #CONST
002898  000247  #END
002899  000248        
002900  000249  #constant  Strings9Size     0
002901  000249  #constant  Strings9Size     0
002902  000250  #constant  Strings9StartH   0
002903  000250  #constant  Strings9StartH   0
002904  000251  #constant  Strings9StartL   0
002905  000251  #constant  Strings9StartL   0
002906  000252        
002907  000253  #constant  Strings8StartH   0x0
002908  000253  #constant  Strings8StartH   0x0
002909  000254  #constant  Strings8StartL   0x0
002910  000254  #constant  Strings8StartL   0x0
002911  000255  #constant  Strings10StartH   0x0
002912  000255  #constant  Strings10StartH   0x0
002913  000256  #constant  Strings10StartL   0x200
002914  000256  #constant  Strings10StartL   0x200
002915  000257  #constant  Strings0StartH   0x0
002916  000257  #constant  Strings0StartH   0x0
002917  000258  #constant  Strings0StartL   0x400
002918  000258  #constant  Strings0StartL   0x400
002919  000259  #constant  Strings1StartH   0x0
002920  000259  #constant  Strings1StartH   0x0
002921  000260  #constant  Strings1StartL   0x600
002922  000260  #constant  Strings1StartL   0x600
002923  000261  #constant  Strings7StartH   0x0
002924  000261  #constant  Strings7StartH   0x0
002925  000262  #constant  Strings7StartL   0x800
002926  000262  #constant  Strings7StartL   0x800
002927  000263  #constant  Strings4StartH   0x0
002928  000263  #constant  Strings4StartH   0x0
002929  000264  #constant  Strings4StartL   0xA00
002930  000264  #constant  Strings4StartL   0xA00
002931  000265  #constant  Strings5StartH   0x0
002932  000265  #constant  Strings5StartH   0x0
002933  000266  #constant  Strings5StartL   0xC00
002934  000266  #constant  Strings5StartL   0xC00
002935  000267  #constant  Strings6StartH   0x0
002936  000267  #constant  Strings6StartH   0x0
002937  000268  #constant  Strings6StartL   0xE00
002938  000268  #constant  Strings6StartL   0xE00
002939  000269  #constant  Strings2StartH   0x0
002940  000269  #constant  Strings2StartH   0x0
002941  000270  #constant  Strings2StartL   0x1000
002942  000270  #constant  Strings2StartL   0x1000
002943  000271  #constant  Strings3StartH   0x0
002944  000271  #constant  Strings3StartH   0x0
002945  000272  #constant  Strings3StartL   0x1200
002946  000272  #constant  Strings3StartL   0x1200
002947  000273        
002948  000274  #IFNOT EXISTS NOGLOBALS
002949  000275  var hndl ;
002950  000276  var hFonts[11] ;
002951  000277  #ENDIF
002952  000014        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\CLPrintStrings.inc

002953  000015  #inherit "CLPrintStrings.inc"
002954  000015  #inherit "CLPrintStrings.inc"
002955  000001  func PrintStrings(var ID, var *msgid, var String)
002956  000002      var StringID, i, ch, offs32[2], res32[2];
002957  000003      StringID := oStringss[1+ID] ;
002958  000004      if (String)
002959  000005          stringsCV[ID] := -1 ;
002960  000006      else
002961  000007          stringsCV[ID] := msgid ;
002962  000008      endif
002963  000009      if ((StringID == -1) || (*(StringID + Ofs_String_Form) != CurrentForm)) return ;
002964  000010      txt_FontID(hFonts[ID]) ;
002965  000011      txt_Attributes(*(StringID + Ofs_String_FontAttribs)) ; // >> 4 fix for r25,6,7,8 PmmC
002966  000012  //    txt_Opacity(*(StringID + STTransparent)) ;
002967  000013        
002968  000014      if (*(StringID + Ofs_String_Transparent))
002969  000015          gfx_RectangleFilled(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2), *(StringID + Ofs_String_BGColor));
002970  000016      else if (FormBGcolors[CurrentForm] != ColorBGimage)
002971  000017          gfx_RectangleFilled(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2), FormBGcolors[CurrentForm]);
002972  000018      else
002973  000019          gfx_ClipWindow(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2)) ;
002974  000020          gfx_Clipping(ON) ;
002975  000021          img_Show(hndl,FormStartIndex[CurrentForm]) ;
002976  000022          gfx_Clipping(OFF) ;
002977  000023        
002978  000024      endif
002979  000025        
002980  000026      txt_FGcolour(*(StringID + Ofs_String_FGColor)) ;
002981  000027      txt_BGcolour(*(StringID + Ofs_String_BGColor)) ;
002982  000028      txt_Opacity(TRANSPARENT);                // 8  text OPAQUE or TRANSPARENT
002983  000029        
002984  000030      gfx_MoveTo(*(StringID + Ofs_String_x1) , *(StringID + Ofs_String_y1)) ;
002985  000031        
002986  000032      if (String)
002987  000033          i := 0 ;
002988  000034          ch := msgid[i++] ;
002989  000035          while (ch != 0)
002990  000036              putch(ch) ;
002991  000037              ch := msgid[i++] ;
002992  000038          wend
002993  000039      else
002994  000040          umul_1616(offs32, *(StringID + Ofs_String_Size), msgid);
002995  000041          res32[1] := *(StringID + Ofs_String_StartH) ;
002996  000042          res32[0] := *(StringID + Ofs_String_StartL) ;
002997  000043          uadd_3232(res32,res32,offs32) ;
002998  000044          file_Seek(hstrings, res32[1], res32[0]);
002999  000045          repeat
003000  000046              if (*(StringID + Ofs_String_Ansi))
003001  000047                  ch := file_GetC(hstrings) ;
003002  000048              else
003003  000049                  ch := file_GetW(hstrings) ;
003004  000050              endif
003005  000051              putch(ch) ;
003006  000052          until (ch == 0) ;
003007  000053      endif
003008  000054        
003009  000055  endfunc
003010  000056        
003011  000016        
003012  000017  #constant IPDatasize 22
003013  000017  #constant IPDatasize 22
003014  000018        
003015  000019  #CONST
003016  000023  #END
003017  000024        
003018  000025        
003019  000026        
003020  000027  #CONST
003021  000133  #END
003022  000134        
003023  000305  #END
3024  0F5E
3025  0F5F
3026  0F60
3027  0F61
3028  0F62
3029  0F63
3030  0F64
3031  0F65
3032  0F66
3033  0F67
3034  0F68
3035  0F69
3036  0F6A
3037  0F6B
3038  0F6C
3039  0F6D
3040  0F6E
3041  0F6F
3042  0F70
3043  0F71
3044  0F72
3045  0F73
3046  0F74
3047  0F75
3048  0F76
3049  0F77
3050  0F78
3051  0F79
3052  0F7A
3053  0F7B
3054  0F7C
3055  0F7D
3056  0F7E
3057  0F7F
3058  0F80
3059  0F81
3060  0F82
3061  0F83
3062  0F84
3063  0F85
3064  0F86
3065  0F87
3066  0F88
3067  0F89
3068  0F8A
3069  0F8B
3070  0F8C
3071  0F8D
3072  0F8E
3073  0F8F
3074  0F90
3075  0F91
3076  0F92
3077  0F93
3078  0F94
3079  0F95
3080  0F96
3081  0F97
3082  0F98
3083  0F99
3084  0F9A
3085  0F9B
3086  0F9C
3087  0F9D
3088  0F9E
3089  0F9F
3090  0FA0
3091  0FA1
3092  0FA2
3093  0FA3
3094  0FA4
3095  0FA5
3096  0FA6
3097  0FA7
3098  0FA8
3099  0FA9
3100  0FAA
3101  0FAB
3102  0FAC
3103  0FAD
3104  0FAE
3105  0FAF
3106  0FB0
3107  0FB1
3108  0FB2
3109  0FB3
3110  0FB4
3111  0FB5
3112  0FB6
3113  0FB7
3114  0FB8
3115  0FB9
3116  0FBA
3117  0FBB
3118  0FBC
3119  0FBD
3120  0FBE
3121  0FBF
3122  0FC0
3123  0FC1
3124  0FC2
3125  0FC3
3126  0FC4
3127  0FC5
3128  0FC6
3129  0FC7
3130  0FC8
3131  0FC9
3132  0FCA
3133  0FCB
3134  0FCC
3135  0FCD
3136  0FCE
3137  0FCF
3138  0FD0
3139  0FD1
3140  0FD2
3141  0FD3
3142  0FD4
3143  0FD5
3144  0FD6
3145  0FD7
3146  0FD8
3147  0FD9
3148  0FDA
3149  0FDB
3150  0FDC
3151  0FDD
3152  0FDE
3153  0FDF
3154  0FE0
3155  0FE1
3156  0FE2
3157  0FE3
3158  0FE4
3159  0FE5
3160  0FE6
3161  0FE7
3162  0FE8
3163  0FE9
3164  0FEA
3165  0FEB
3166  0FEC
3167  0FED
3168  0FEE
3169  0FEF
3170  0FF0
3171  0FF1
3172  0FF2
3173  0FF3
3174  0FF4
3175  0FF5
3176  0FF6
3177  0FF7
3178  0FF8
3179  0FF9
3180  0FFA
3181  0FFB
3182  0FFC
3183  0FFD
3184  0FFE
3185  0FFF
3186  1000
3187  1001
3188  1002
3189  1003
3190  1004
3191  1005
3192  1006
3193  1007
3194  1008
3195  1009
3196  100A
3197  100B
3198  100C
3199  100D
3200  100E
3201  100F
3202  1010
3203  1011
3204  1012
3205  1013
3206  1014
3207  1015
3208  1016
3209  1017
3210  1018
3211  1019
3212  101A
3213  101B
3214  101C
3215  101D
3216  101E
3217  101F
3218  1020
3219  1021
3220  1022
3221  1023
3222  1024
3223  1025
3224  1026
3225  1027
3226  1028
3227  1029
3228  102A
3229  102B
3230  102C
3231  102D
3232  102E
3233  102F
3234  1030
3235  1031
3236  1032
3237  1033
3238  1034
3239  1035
3240  1036
3241  1037
3242  1038
3243  1039
3244  103A
3245  103B
3246  103C
3247  103D
3248  103E
3249  103F
3250  1040
3251  1041
3252  1042
3253  1043
3254  1044
3255  1045
3256  1046
3257  1047
3258  1048
3259  1049
3260  104A
3261  104B
3262  104C
3263  104D
3264  104E
3265  104F
3266  1050
3267  1051
3268  1052
3269  1053
3270  1054
3271  1055
3272  1056
3273  1057
3274  1058
3275  1059
3276  105A
3277  105B
3278  105C
3279  105D
3280  105E
3281  105F
3282  1060
3283  1061
3284  1062
3285  1063
3286  1064
3287  1065
3288  1066
3289  1067
3290  1068
3291  1069
3292  106A
3293  106B
3294  106C
3295  106D
3296  106E
3297  106F
3298  1070
3299  1071
3300  1072
3301  1073
3302  1074
3303  1075
3304  1076
3305  1077
3306  1078
3307  1079
3308  107A
3309  107B
3310  107C
3311  107D
3312  107E
3313  107F
3314  1080
3315  1081
3316  1082
3317  1083
3318  1084
3319  1085
3320  1086
3321  1087
3322  1088
3323  1089
3324  108A
3325  108B
3326  108C
3327  108D
3328  108E
3329  108F
3330  1090
3331  1091
3332  1092
3333  1093
3334  1094
3335  1095
3336  1096
3337  1097
3338  1098
3339  1099
3340  109A
3341  109B
3342  109C
3343  109D
3344  109E
3345  109F
3346  10A0
3347  10A1
3348  10A2
3349  10A3
3350  10A4
3351  10A5
3352  10A6
3353  10A7
3354  10A8
3355  10A9
3356  10AA
3357  10AB
3358  10AC
3359  10AD
3360  10AE
3361  10AF
3362  10B0
3363  10B1
3364  10B2
3365  10B3
3366  10B4
3367  10B5
3368  10B6
3369  10B7
3370  10B8
3371  10B9
3372  10BA
3373  10BB
3374  10BC
3375  10BD
3376  10BE
3377  10BF
3378  10C0
3379  10C1
3380  10C2
3381  10C3
3382  10C4
3383  10C5
3384  10C6
3385  10C7
3386  10C8
3387  10C9
3388  10CA
3389  10CB
3390  10CC
3391  10CD
3392  10CE
3393  10CF
3394  10D0
3395  10D1
3396  10D2
3397  10D3
3398  10D4
3399  10D5
3400  10D6
3401  10D7
3402  10D8
3403  10D9
3404  10DA
3405  10DB
3406  10DC
3407  10DD
3408  10DE
3409  10DF
3410  10E0
3411  10E1
3412  10E2
3413  10E3
3414  10E4
3415  10E5
3416  10E6
3417  10E7
3418  10E8
3419  10E9
3420  10EA
3421  10EB
3422  10EC
3423  10ED
3424  10EE
3425  10EF
3426  10F0
3427  10F1
3428  10F2
3429  10F3
3430  10F4
3431  10F5
3432  10F6
3433  10F7
3434  10F8
3435  10F9
3436  10FA
3437  10FB
3438  10FC
3439  10FD
3440  10FE
3441  10FF
3442  1100
3443  1101
3444  1102
3445  1103
3446  1104
3447  1105
3448  1106
3449  1107
3450  1108
3451  1109
3452  110A
3453  110B
3454  110C
3455  110D
3456  110E
3457  110F
3458  1110
3459  1111
3460  1112
3461  1113
3462  1114
3463  1115
3464  1116
3465  1117
3466  1118
3467  1119
3468  111A
3469  111B
3470  111C
3471  111D
3472  111E
3473  111F
3474  1120
3475  1121
3476  1122
3477  1123
3478  1124
3479  1125
3480  1126
3481  1127
3482  1128
3483  1129
3484  112A
3485  112B
3486  112C
3487  112D
3488  112E
3489  112F
3490  1130
3491  1131
3492  1132
3493  1133
3494  1134
3495  1135
3496  1136
3497  1137
3498  1138
3499  1139
3500  113A
3501  113B
3502  113C
3503  113D
3504  113E
3505  113F
3506  1140
3507  1141
3508  1142
3509  1143
3510  1144
3511  1145
3512  1146
3513  1147
3514  1148
3515  1149
3516  114A
3517  114B
3518  114C
3519  114D
3520  114E
3521  114F
3522  1150
3523  1151
3524  1152
3525  1153
3526  1154
3527  1155
3528  1156
3529  1157
3530  1158
3531  1159
3532  115A
3533  115B
3534  115C
3535  115D
3536  115E
3537  115F
3538  1160
3539  1161
3540  1162
3541  1163
3542  1164
3543  1165
3544  1166
3545  1167
3546  1168
3547  1169
3548  116A
3549  116B
3550  116C
3551  116D
3552  116E
3553  116F
3554  1170
3555  1171
3556  1172
3557  1173
3558  1174
3559  1175
3560  1176
3561  1177
3562  1178
3563  1179
3564  117A
3565  117B
3566  117C
3567  117D
3568  117E
3569  117F
3570  1180
3571  1181
3572  1182
3573  1183
3574  1184
3575  1185
3576  1186
3577  1187
3578  1188
3579  1189
3580  118A
3581  118B
3582  118C
3583  118D
3584  118E
3585  118F
3586  1190
3587  1191
3588  1192
3589  1193
3590  1194
3591  1195
3592  1196
3593  1197
3594  1198
3595  1199
3596  119A
3597  119B
3598  119C
3599  119D
3600  119E
3601  119F
3602  11A0
3603  11A1
3604  11A2
3605  11A3
3606  11A4
3607  11A5
3608  11A6
3609  11A7
3610  11A8
3611  11A9
3612  11AA
3613  11AB
3614  11AC
3615  11AD
3616  11AE
3617  11AF
3618  11B0
3619  11B1
3620  11B2
3621  11B3
3622  11B4
3623  11B5
3624  11B6
3625  11B7
3626  11B8
3627  11B9
3628  11BA
3629  11BB
3630  11BC
3631  11BD
3632  11BE
3633  11BF
3634  11C0
3635  11C1
3636  11C2
3637  11C3
3638  11C4
3639  11C5
3640  11C6
3641  11C7
3642  11C8
3643  11C9
3644  11CA
3645  11CB
3646  11CC
3647  11CD
3648  11CE
3649  11CF
3650  11D0
3651  11D1
3652  11D2
3653  11D3
3654  11D4
3655  11D5
3656  11D6
3657  11D7
3658  11D8
3659  11D9
3660  11DA
3661  11DB
3662  11DC
3663  11DD
3664  11DE
3665  11DF
3666  11E0
3667  11E1
3668  11E2
3669  11E3
3670  11E4
3671  11E5
3672  11E6
3673  11E7
3674  11E8
3675  11E9
3676  11EA
3677  11EB
3678  11EC
3679  11ED
3680  11EE
3681  11EF
3682  11F0
3683  11F1
3684  11F2
3685  11F3
3686  11F4
3687  11F5
3688  11F6
3689  11F7
3690  11F8
3691  11F9
3692  11FA
3693  11FB
3694  11FC
3695  11FD
3696  11FE
3697  11FF
3698  1200
3699  1201
3700  1202
3701  1203
3702  1204
3703  1205
3704  1206
3705  1207
3706  1208
3707  1209
3708  120A
3709  120B
3710  120C
3711  120D
3712  120E
3713  120F
3714  1210
3715  1211
3716  1212
3717  1213
3718  1214
3719  1215
3720  1216
3721  1217
3722  1218
3723  1219
3724  121A
3725  121B
3726  121C
3727  121D
3728  121E
3729  121F
3730  1220
3731  1221
3732  1222
3733  1223
3734  1224
3735  1225
3736  1226
3737  1227
3738  1228
3739  1229
3740  122A
3741  122B
3742  122C
3743  122D
3744  122E
3745  122F
3746  1230
3747  1231
3748  1232
3749  1233
3750  1234
3751  1235
3752  1236
3753  1237
3754  1238
3755  1239
3756  123A
3757  123B
3758  123C
3759  123D
3760  123E
3761  123F
3762  1240
3763  1241
3764  1242
3765  1243
3766  1244
3767  1245
3768  1246
3769  1247
3770  1248
3771  1249
3772  124A
3773  124B
3774  124C
3775  124D
3776  124E
3777  124F
3778  1250
3779  1251
3780  1252
3781  1253
3782  1254
3783  1255
3784  1256
3785  1257
3786  1258
3787  1259
3788  125A
3789  125B
3790  125C
3791  125D
3792  125E
3793  125F
3794  1260
3795  1261
3796  1262
3797  1263
3798  1264
3799  1265
3800  1266
3801  1267
3802  1268
3803  1269
3804  126A
3805  126B
3806  126C
3807  126D
3808  126E
3809  126F
3810  1270
3811  1271
3812  1272
3813  1273
3814  1274
3815  1275
3816  1276
3817  1277
3818  1278
3819  1279
3820  127A
3821  127B
3822  127C
3823  127D
3824  127E
3825  127F
3826  1280
3827  1281
3828  1282
3829  1283
3830  1284
3831  1285
3832  1286
3833  1287
3834  1288
3835  1289
3836  128A
3837  128B
3838  128C
3839  128D
3840  128E
3841  128F
3842  1290
3843  1291
3844  1292
3845  1293
3846  1294
3847  1295
3848  1296
3849  1297
3850  1298
3851  1299
3852  129A
3853  129B
3854  129C
3855  129D
3856  129E
3857  129F
3858  12A0
3859  12A1
3860  12A2
3861  12A3
3862  12A4
3863  12A5
3864  12A6
3865  12A7
3866  12A8
3867  12A9
3868  12AA
3869  12AB
3870  12AC
3871  12AD
3872  12AE
3873  12AF
3874  12B0
3875  12B1
3876  12B2
3877  12B3
3878  12B4
3879  12B5
3880  12B6
3881  12B7
3882  12B8
3883  12B9
3884  12BA
3885  12BB
3886  12BC
3887  12BD
3888  12BE
3889  12BF
3890  12C0
3891  12C1
3892  12C2
3893  12C3
3894  12C4
3895  12C5
3896  12C6
3897  12C7
3898  12C8
3899  12C9
3900  12CA
3901  12CB
3902  12CC
3903  12CD
3904  12CE
3905  12CF
3906  12D0
3907  12D1
3908  12D2
3909  12D3
3910  12D4
3911  12D5
3912  12D6
3913  12D7
3914  12D8
3915  12D9
3916  12DA
3917  12DB
3918  12DC
3919  12DD
3920  12DE
3921  12DF
3922  12E0
3923  12E1
3924  12E2
3925  12E3
3926  12E4
3927  12E5
3928  12E6
3929  12E7
3930  12E8
3931  12E9
3932  12EA
3933  12EB
3934  12EC
3935  12ED
3936  12EE
3937  12EF
3938  12F0
3939  12F1
3940  12F2
3941  12F3
3942  12F4
3943  12F5
3944  12F6
3945  12F7
3946  12F8
3947  12F9
3948  12FA
3949  12FB
3950  12FC
3951  12FD
3952  12FE
3953  12FF
3954  1300
3955  1301
3956  1302
3957  1303
3958  1304
3959  1305
3960  1306
3961  1307
3962  1308
3963  1309
3964  130A
3965  130B
3966  130C
3967  130D
3968  130E
3969  130F
3970  1310
3971  1311
3972  1312
3973  1313
3974  1314
3975  1315
3976  1316
3977  1317
3978  1318
3979  1319
3980  131A
3981  131B
3982  131C
3983  131D
3984  131E
3985  131F
3986  1320
3987  1321
3988  1322
3989  1323
3990  1324
3991  1325
3992  1326
3993  1327
3994  1328
3995  1329
3996  132A
3997  132B
3998  132C
3999  132D
4000  132E
4001  132F
4002  1330
4003  1331
4004  1332
4005  1333
4006  1334
4007  1335
4008  1336
4009  1337
4010  1338
4011  1339
4012  133A
4013  133B
4014  133C
4015  133D
4016  133E
4017  133F
4018  1340
4019  1341
4020  1342
4021  1343
4022  1344
4023  1345
4024  1346
4025  1347
4026  1348
4027  1349
4028  134A
4029  134B
4030  134C
4031  134D
4032  134E
4033  134F
4034  1350
4035  1351
4036  1352
4037  1353
4038  1354
4039  1355
4040  1356
4041  1357
4042  1358
4043  1359
4044  135A
4045  135B
4046  135C
4047  135D
4048  135E
4049  135F
4050  1360
4051  1361
4052  1362
4053  1363
4054  1364
4055  1365
4056  1366
4057  1367
4058  1368
4059  1369
4060  136A
4061  136B
4062  136C
4063  136D
4064  136E
4065  136F
4066  1370
4067  1371
4068  1372
4069  1373
4070  1374
4071  1375
4072  1376
4073  1377
4074  1378
4075  1379
4076  137A
4077  137B
4078  137C
4079  137D
4080  137E
4081  137F
4082  1380
4083  1381
4084  1382
4085  1383
4086  1384
4087  1385
4088  1386
4089  1387
4090  1388
4091  1389
4092  138A
4093  138B
4094  138C
4095  138D
4096  138E
4097  138F
4098  1390
4099  1391
4100  1392
4101  1393
4102  1394
4103  1395
4104  1396
4105  1397
4106  1398
4107  1399
4108  139A
4109  139B
4110  139C
4111  139D
4112  139E
4113  139F
4114  13A0
4115  13A1
4116  13A2
4117  13A3
4118  13A4
4119  13A5
4120  13A6
4121  13A7
4122  13A8
4123  13A9
4124  13AA
4125  13AB
4126  13AC
4127  13AD
4128  13AE
4129  13AF
4130  13B0
4131  13B1
4132  13B2
4133  13B3
4134  13B4
4135  13B5
4136  13B6
4137  13B7
4138  13B8
4139  13B9
4140  13BA
4141  13BB
4142  13BC
4143  13BD
4144  13BE
4145  13BF
4146  13C0
4147  13C1
4148  13C2
4149  13C3
4150  13C4
4151  13C5
4152  13C6
4153  13C7
4154  13C8
4155  13C9
4156  13CA
4157  13CB
4158  13CC
4159  13CD
4160  13CE
4161  13CF
4162  13D0
4163  13D1
4164  13D2
4165  13D3
4166  13D4
4167  13D5
4168  13D6
4169  13D7
4170  13D8
4171  13D9
4172  13DA
4173  13DB
4174  13DC
4175  13DD
4176  13DE
4177  13DF
4178  13E0
4179  13E1
4180  13E2
4181  13E3
4182  13E4
4183  13E5
4184  13E6
4185  13E7
4186  13E8
4187  13E9
4188  13EA
4189  13EB
4190  13EC
4191  13ED
4192  13EE
4193  13EF
4194  13F0
4195  13F1
4196  13F2
4197  13F3
4198  13F4
4199  13F5
4200  13F6
4201  13F7
4202  13F8
4203  13F9
4204  13FA
4205  13FB
4206  13FC
4207  13FD
4208  13FE
4209  13FF
4210  1400
4211  1401
4212  1402
4213  1403
4214  1404
4215  1405
4216  1406
4217  1407
4218  1408
4219  1409
4220  140A
4221  140B
4222  140C
4223  140D
4224  140E
4225  140F
4226  1410
4227  1411
4228  1412
4229  1413
4230  1414
4231  1415
4232  1416
4233  1417
4234  1418
4235  1419
4236  141A
4237  141B
4238  141C
4239  141D
4240  141E
4241  141F
4242  1420
4243  1421
4244  1422
4245  1423
4246  1424
4247  1425
4248  1426
4249  1427
4250  1428
4251  1429
4252  142A
4253  142B
4254  142C
4255  142D
4256  142E
4257  142F
4258  1430
4259  1431
4260  1432
4261  1433
4262  1434
4263  1435
4264  1436
4265  1437
4266  1438
4267  1439
4268  143A
4269  143B
4270  143C
4271  143D
4272  143E
4273  143F
4274  1440
4275  1441
4276  1442
4277  1443
4278  1444
4279  1445
4280  1446
4281  1447
4282  1448
4283  1449
4284  144A
4285  144B
4286  144C
4287  144D
4288  144E
4289  144F
4290  1450
4291  1451
4292  1452
4293  1453
4294  1454
4295  1455
4296  1456
4297  1457
4298  1458
4299  1459
4300  145A
4301  145B
4302  145C
4303  145D
4304  145E
4305  145F
4306  1460
4307  1461
4308  1462
4309  1463
4310  1464
4311  1465
4312  1466
4313  1467
4314  1468
4315  1469
4316  146A
4317  146B
4318  146C
4319  146D
4320  146E
4321  146F
4322  1470
4323  1471
4324  1472
4325  1473
4326  1474
4327  1475
4328  1476
4329  1477
4330  1478
4331  1479
4332  147A
4333  147B
4334  147C
4335  147D
4336  147E
4337  147F
4338  1480
4339  1481
4340  1482
4341  1483
4342  1484
4343  1485
4344  1486
4345  1487
4346  1488
4347  1489
4348  148A
4349  148B
4350  148C
4351  148D
4352  148E
4353  148F
4354  1490
4355  1491
4356  1492
4357  1493
4358  1494
4359  1495
4360  1496
4361  1497
4362  1498
4363  1499
4364  149A
4365  149B
4366  149C
4367  149D
4368  149E
4369  149F
4370  14A0
4371  14A1
4372  14A2
4373  14A3
4374  14A4
4375  14A5
4376  14A6
4377  14A7
4378  14A8
4379  14A9
4380  14AA
4381  14AB
4382  14AC
4383  14AD
4384  14AE
4385  14AF
4386  14B0
4387  14B1
4388  14B2
4389  14B3
4390  14B4
4391  14B5
4392  14B6
4393  14B7
4394  14B8
4395  14B9
4396  14BA
4397  14BB
4398  14BC
4399  14BD
4400  14BE
4401  14BF
4402  14C0
4403  14C1
4404  14C2
4405  14C3
4406  14C4
4407  14C5
4408  14C6
4409  14C7
4410  14C8
4411  14C9
4412  14CA
4413  14CB
4414  14CC
4415  14CD
4416  14CE
4417  14CF
4418  14D0
4419  14D1
4420  14D2
4421  14D3
4422  14D4
4423  14D5
4424  14D6
4425  14D7
4426  14D8
4427  14D9
4428  14DA
4429  14DB
4430  14DC
4431  14DD
4432  14DE
4433  14DF
4434  14E0
4435  14E1
4436  14E2
4437  14E3
4438  14E4
4439  14E5
4440  14E6
4441  14E7
4442  14E8
4443  14E9
4444  14EA
4445  14EB
4446  14EC
4447  14ED
4448  14EE
4449  14EF
4450  14F0
4451  14F1
4452  14F2
4453  14F3
4454  14F4
4455  14F5
4456  14F6
4457  14F7
4458  14F8
4459  14F9
4460  14FA
4461  14FB
4462  14FC
4463  14FD
4464  14FE
4465  14FF
4466  1500
4467  1501
4468  1502
4469  1503
4470  1504
4471  1505
4472  1506
4473  1507
4474  1508
4475  1509
4476  150A
4477  150B
4478  150C
4479  150D
4480  150E
4481  150F
4482  1510
4483  1511
4484  1512
4485  1513
4486  1514
4487  1515
4488  1516
4489  1517
4490  1518
4491  1519
4492  151A
4493  151B
4494  151C
4495  151D
4496  151E
4497  151F
4498  1520
4499  1521
4500  1522
4501  1523
4502  1524
4503  1525
4504  1526
4505  1527
4506  1528
4507  1529
4508  152A
4509  152B
4510  152C
4511  152D
4512  152E
4513  152F
4514  1530
4515  1531
4516  1532
4517  1533
4518  1534
4519  1535
4520  1536
4521  1537
4522  1538
4523  1539
4524  153A
4525  153B
4526  153C
4527  153D
4528  153E
4529  153F
4530  1540
4531  1541
4532  1542
4533  1543
4534  1544
4535  1545
4536  1546
4537  1547
4538  1548
4539  1549
4540  154A
4541  154B
4542  154C
4543  154D
4544  154E
4545  154F
4546  1550
4547  1551
4548  1552
4549  1553
4550  1554
4551  1555
4552  1556
4553  1557
4554  1558
4555  1559
4556  155A
4557  155B
4558  155C
4559  155D
4560  155E
4561  155F
4562  1560
4563  1561
4564  1562
4565  1563
4566  1564
4567  1565
4568  1566
4569  1567
4570  1568
4571  1569
4572  156A
4573  156B
4574  156C
4575  156D
4576  156E
4577  156F
4578  1570
4579  1571
4580  1572
4581  1573
4582  1574
4583  1575
4584  1576
4585  1577
4586  1578
4587  1579
4588  157A
4589  157B
4590  157C
4591  157D
4592  157E
4593  157F
4594  1580
4595  1581
4596  1582
4597  1583
4598  1584
4599  1585
4600  1586
4601  1587
4602  1588
4603  1589
4604  158A
4605  158B
4606  158C
4607  158D
4608  158E
4609  158F
4610  1590
4611  1591
4612  1592
4613  1593
4614  1594
4615  1595
4616  1596
4617  1597
4618  1598
4619  1599
4620  159A
4621  159B
4622  159C
4623  159D
4624  159E
4625  159F
4626  15A0
4627  15A1
4628  15A2
4629  15A3
4630  15A4
4631  15A5
4632  15A6
4633  15A7
4634  15A8
4635  15A9
4636  15AA
4637  15AB
4638  15AC
4639  15AD
4640  15AE
4641  15AF
4642  15B0
4643  15B1
4644  15B2
4645  15B3
4646  15B4
4647  15B5
4648  15B6
4649  15B7
4650  15B8
4651  15B9
4652  15BA
4653  15BB
4654  15BC
4655  15BD
4656  15BE
4657  15BF
4658  15C0
4659  15C1
4660  15C2
4661  15C3
4662  15C4
4663  15C5
4664  15C6
4665  15C7
4666  15C8
4667  15C9
4668  15CA
4669  15CB
4670  15CC
4671  15CD
4672  15CE
4673  15CF
4674  15D0
4675  15D1
4676  15D2
4677  15D3
4678  15D4
4679  15D5
4680  15D6
4681  15D7
4682  15D8
4683  15D9
4684  15DA
4685  15DB
4686  15DC
4687  15DD
4688  15DE
4689  15DF
4690  15E0
4691  15E1
4692  15E2
4693  15E3
4694  15E4
4695  15E5
4696  15E6
4697  15E7
4698  15E8
4699  15E9
4700  15EA
4701  15EB
4702  15EC
4703  15ED
4704  15EE
4705  15EF
4706  15F0
4707  15F1
4708  15F2
4709  15F3
4710  15F4
4711  15F5
4712  15F6
4713  15F7
4714  15F8
4715  15F9
4716  15FA
4717  15FB
4718  15FC
4719  15FD
4720  15FE
4721  15FF
4722  1600
4723  1601
4724  1602
4725  1603
4726  1604
4727  1605
4728  1606
4729  1607
4730  1608
4731  1609
4732  160A
4733  160B
4734  160C
4735  160D
4736  160E
4737  160F
4738  1610
4739  1611
4740  1612
4741  1613
4742  1614
4743  1615
4744  1616
4745  1617
4746  1618
4747  1619
4748  161A
4749  161B
4750  161C
4751  161D
4752  161E
4753  161F
4754  1620
4755  1621
4756  1622
4757  1623
4758  1624
4759  1625
4760  1626
4761  1627
4762  1628
4763  1629
4764  162A
4765  162B
4766  162C
4767  162D
4768  162E
4769  162F
4770  1630
4771  1631
4772  1632
4773  1633
4774  1634
4775  1635
4776  1636
4777  1637
4778  1638
4779  1639
4780  163A
4781  163B
4782  163C
4783  163D
4784  163E
4785  163F
4786  1640
4787  1641
4788  1642
4789  1643
4790  1644
4791  1645
4792  1646
4793  1647
4794  1648
4795  1649
4796  164A
4797  164B
4798  164C
4799  164D
4800  164E
4801  164F
4802  1650
4803  1651
4804  1652
4805  1653
4806  1654
4807  1655
4808  1656
4809  1657
4810  1658
4811  1659
4812  165A
4813  165B
4814  165C
4815  165D
4816  165E
4817  165F
4818  1660
4819  1661
4820  1662
4821  1663
4822  1664
4823  1665
4824  1666
4825  1667
4826  1668
4827  1669
4828  166A
4829  166B
4830  166C
4831  166D
4832  166E
4833  166F
4834  1670
4835  1671
4836  1672
4837  1673
4838  1674
4839  1675
4840  1676
4841  1677
4842  1678
4843  1679
4844  167A
4845  167B
4846  167C
4847  167D
4848  167E
4849  167F
4850  1680
4851  1681
4852  1682
4853  1683
4854  1684
4855  1685
4856  1686
4857  1687
4858  1688
4859  1689
4860  168A
4861  168B
4862  168C
4863  168D
4864  168E
4865  168F
4866  1690
4867  1691
4868  1692
4869  1693
4870  1694
4871  1695
4872  1696
4873  1697
4874  1698
4875  1699
4876  169A
4877  169B
4878  169C
4879  169D
4880  169E
4881  169F
4882  16A0
4883  16A1
4884  16A2
4885  16A3
4886  16A4
4887  16A5
4888  16A6
4889  16A7
4890  16A8
4891  16A9
4892  16AA
4893  16AB
4894  16AC
4895  16AD
4896  16AE
4897  16AF
4898  16B0
4899  16B1
4900  16B2
4901  16B3
4902  16B4
4903  16B5
4904  16B6
4905  16B7
4906  16B8
4907  16B9
4908  16BA
4909  16BB
4910  16BC
4911  16BD
4912  16BE
4913  16BF
4914  16C0
4915  16C1
4916  16C2
4917  16C3
4918  16C4
4919  16C5
4920  16C6
4921  16C7
4922  16C8
4923  16C9
4924  16CA
4925  16CB
4926  16CC
4927  16CD
4928  16CE
4929  16CF
4930  16D0
4931  16D1
4932  16D2
4933  16D3
4934  16D4
4935  16D5
4936  16D6
4937  16D7
4938  16D8
4939  16D9
4940  16DA
4941  16DB
4942  16DC
4943  16DD
4944  16DE
4945  16DF
4946  16E0
4947  16E1
4948  16E2
4949  16E3
4950  16E4
4951  16E5
4952  16E6
4953  16E7
4954  16E8
4955  16E9
4956  16EA
4957  16EB
4958  16EC
4959  16ED
4960  16EE
4961  16EF
4962  16F0
4963  16F1
4964  16F2
4965  16F3
4966  16F4
4967  16F5
4968  16F6
4969  16F7
4970  16F8
4971  16F9
4972  16FA
4973  16FB
4974  16FC
4975  16FD
4976  16FE
4977  16FF
4978  1700
4979  1701
4980  1702
4981  1703
4982  1704
4983  1705
4984  1706
4985  1707
4986  1708
4987  1709
4988  170A
4989  170B
4990  170C
4991  170D
4992  170E
4993  170F
4994  1710
4995  1711
4996  1712
4997  1713
4998  1714
4999  1715
5000  1716
5001  1717
5002  1718
5003  1719
5004  171A
5005  171B
5006  171C
5007  171D
5008  171E
5009  171F
5010  1720
5011  1721
5012  1722
5013  1723
5014  1724
5015  1725
5016  1726
5017  1727
5018  1728
5019  1729
5020  172A
5021  172B
5022  172C
5023  172D
5024  172E
5025  172F
5026  1730
5027  1731
5028  1732
5029  1733
5030  1734
5031  1735
5032  1736
5033  1737
5034  1738
5035  1739
5036  173A
5037  173B
5038  173C
5039  173D
5040  173E
5041  173F
5042  1740
5043  1741
5044  1742
5045  1743
5046  1744
5047  1745
5048  1746
5049  1747
5050  1748
5051  1749
5052  174A
5053  174B
5054  174C
5055  174D
5056  174E
5057  174F
5058  1750
5059  1751
5060  1752
5061  1753
5062  1754
5063  1755
5064  1756
5065  1757
5066  1758
5067  1759
5068  175A
5069  175B
5070  175C
5071  175D
5072  175E
5073  175F
5074  1760
5075  1761
5076  1762
5077  1763
5078  1764
5079  1765
5080  1766
5081  1767
5082  1768
5083  1769
5084  176A
5085  176B
5086  176C
5087  176D
5088  176E
5089  176F
5090  1770
5091  1771
5092  1772
5093  1773
5094  1774
5095  1775
5096  1776
5097  1777
5098  1778
5099  1779
5100  177A
5101  177B
5102  177C
5103  177D
5104  177E
5105  177F
5106  1780
5107  1781
5108  1782
5109  1783
5110  1784
5111  1785
5112  1786
5113  1787
5114  1788
5115  1789
5116  178A
5117  178B
5118  178C
5119  178D
5120  178E
5121  178F
5122  1790
5123  1791
5124  1792
5125  1793
5126  1794
5127  1795
5128  1796
5129  1797
5130  1798
5131  1799
5132  179A
5133  179B
5134  179C
5135  179D
5136  179E
5137  179F
5138  17A0
5139  17A1
5140  17A2
5141  17A3
5142  17A4
5143  17A5
5144  17A6
5145  17A7
5146  17A8
5147  17A9
5148  17AA
5149  17AB
5150  17AC
5151  17AD
5152  17AE
5153  17AF
5154  17B0
5155  17B1
5156  17B2
5157  17B3
5158  17B4
5159  17B5
5160  17B6
5161  17B7
5162  17B8
5163  17B9
5164  17BA
5165  17BB
5166  17BC
5167  17BD
5168  17BE
5169  17BF
5170  17C0
5171  17C1
5172  17C2
5173  17C3
5174  17C4
5175  17C5
5176  17C6
5177  17C7
5178  17C8
5179  17C9
5180  17CA
5181  17CB
5182  17CC
5183  17CD
5184  17CE
5185  17CF
5186  17D0
5187  17D1
5188  17D2
5189  17D3
5190  17D4
5191  17D5
5192  17D6
5193  17D7
5194  17D8
5195  17D9
5196  17DA
5197  17DB
5198  17DC
5199  17DD
5200  17DE
5201  17DF
5202  17E0
5203  17E1
5204  17E2
5205  17E3
5206  17E4
5207  17E5
5208  17E6
5209  17E7
5210  17E8
5211  17E9
5212  17EA
5213  17EB
5214  17EC
5215  17ED
5216  17EE
5217  17EF
5218  17F0
5219  17F1
5220  17F2
5221  17F3
5222  17F4
5223  17F5
5224  17F6
5225  17F7
5226  17F8
5227  17F9
5228  17FA
5229  17FB
5230  17FC
5231  17FD
5232  17FE
5233  17FF
5234  1800
5235  1801
5236  1802
5237  1803
5238  1804
5239  1805
5240  1806
5241  1807
5242  1808
5243  1809
5244  180A
5245  180B
5246  180C
5247  180D
5248  180E
5249  180F
5250  1810
5251  1811
5252  1812
5253  1813
5254  1814
5255  1815
5256  1816
5257  1817
5258  1818
5259  1819
5260  181A
5261  181B
5262  181C
5263  181D
5264  181E
5265  181F
5266  1820
5267  1821
5268  1822
5269  1823
5270  1824
5271  1825
5272  1826
5273  1827
5274  1828
5275  1829
5276  182A
5277  182B
5278  182C
5279  182D
5280  182E
5281  182F
5282  1830
5283  1831
5284  1832
5285  1833
5286  1834
5287  1835
5288  1836
5289  1837
5290  1838
5291  1839
5292  183A
5293  183B
5294  183C
5295  183D
5296  183E
5297  183F
5298  1840
5299  1841
5300  1842
5301  1843
5302  1844
5303  1845
5304  1846
5305  1847
5306  1848
5307  1849
5308  184A
5309  184B
5310  184C
5311  184D
5312  184E
5313  184F
5314  1850
5315  1851
5316  1852
5317  1853
5318  1854
5319  1855
5320  1856
5321  1857
5322  1858
5323  1859
5324  185A
5325  185B
5326  185C
5327  185D
5328  185E
5329  185F
5330  1860
5331  1861
5332  1862
5333  1863
5334  1864
5335  1865
5336  1866
5337  1867
5338  1868
5339  1869
5340  186A
5341  186B
5342  186C
5343  186D
5344  186E
5345  186F
5346  1870
5347  1871
5348  1872
5349  1873
5350  1874
5351  1875
5352  1876
5353  1877
5354  1878
5355  1879
5356  187A
5357  187B
5358  187C
5359  187D
5360  187E
5361  187F
5362  1880
5363  1881
5364  1882
5365  1883
5366  1884
5367  1885
5368  1886
5369  1887
5370  1888
5371  1889
5372  188A
5373  188B
5374  188C
5375  188D
5376  188E
5377  188F
5378  1890
5379  1891
5380  1892
5381  1893
5382  1894
5383  1895
5384  1896
5385  1897
5386  1898
5387  1899
5388  189A
5389  189B
5390  189C
5391  189D
5392  189E
5393  189F
5394  18A0
5395  18A1
5396  18A2
5397  18A3
5398  18A4
5399  18A5
5400  18A6
5401  18A7
5402  18A8
5403  18A9
5404  18AA
5405  18AB
5406  18AC
5407  18AD
5408  18AE
5409  18AF
5410  18B0
5411  18B1
5412  18B2
5413  18B3
5414  18B4
5415  18B5
5416  18B6
5417  18B7
5418  18B8
5419  18B9
5420  18BA
5421  18BB
5422  18BC
5423  18BD
5424  18BE
5425  18BF
5426  18C0
5427  18C1
5428  18C2
5429  18C3
5430  18C4
5431  18C5
5432  18C6
5433  18C7
5434  18C8
5435  18C9
5436  18CA
5437  18CB
5438  18CC
5439  18CD
5440  18CE
5441  18CF
5442  18D0
5443  18D1
5444  18D2
5445  18D3
5446  18D4
5447  18D5
5448  18D6
5449  18D7
5450  18D8
5451  18D9
5452  18DA
5453  18DB
5454  18DC
5455  18DD
5456  18DE
5457  18DF
5458  18E0
5459  18E1
5460  18E2
5461  18E3
5462  18E4
5463  18E5
5464  18E6
5465  18E7
5466  18E8
5467  18E9
5468  18EA
5469  18EB
5470  18EC
5471  18ED
5472  18EE
5473  18EF
5474  18F0
5475  18F1
5476  18F2
5477  18F3
5478  18F4
5479  18F5
5480  18F6
5481  18F7
5482  18F8
5483  18F9
5484  18FA
5485  18FB
5486  18FC
5487  18FD
5488  18FE
5489  18FF
5490  1900
5491  1901
5492  1902
5493  1903
5494  1904
5495  1905
5496  1906
5497  1907
5498  1908
5499  1909
5500  190A
5501  190B
5502  190C
5503  190D
5504  190E
5505  190F
5506  1910
5507  1911
5508  1912
5509  1913
5510  1914
5511  1915
5512  1916
5513  1917
5514  1918
5515  1919
5516  191A
5517  191B
5518  191C
5519  191D
5520  191E
5521  191F
5522  1920
5523  1921
5524  1922
5525  1923
5526  1924
5527  1925
5528  1926
5529  1927
5530  1928
5531  1929
5532  192A
5533  192B
5534  192C
5535  192D
5536  192E
5537  192F
5538  1930
5539  1931
5540  1932
5541  1933
5542  1934
5543  1935
5544  1936
5545  1937
5546  1938
5547  1939
5548  193A
5549  193B
5550  193C
5551  193D
5552  193E
5553  193F
5554  1940
5555  1941
5556  1942
5557  1943
5558  1944
5559  1945
5560  1946
5561  1947
5562  1948
5563  1949
5564  194A
5565  194B
5566  194C
5567  194D
5568  194E
5569  194F
5570  1950
5571  1951
5572  1952
5573  1953
5574  1954
5575  1955
5576  1956
5577  1957
5578  1958
5579  1959
5580  195A
5581  195B
5582  195C
5583  195D
5584  195E
5585  195F
5586  1960
5587  1961
5588  1962
5589  1963
5590  1964
5591  1965
5592  1966
5593  1967
5594  1968
5595  1969
5596  196A
5597  196B
5598  196C
5599  196D
5600  196E
5601  196F
5602  1970
5603  1971
5604  1972
5605  1973
5606  1974
5607  1975
5608  1976
5609  1977
5610  1978
5611  1979
5612  197A
5613  197B
5614  197C
5615  197D
5616  197E
5617  197F
5618  1980
5619  1981
5620  1982
5621  1983
5622  1984
5623  1985
5624  1986
5625  1987
5626  1988
5627  1989
5628  198A
5629  198B
5630  198C
5631  198D
5632  198E
5633  198F
5634  1990
5635  1991
5636  1992
5637  1993
5638  1994
5639  1995
5640  1996
5641  1997
5642  1998
5643  1999
5644  199A
5645  199B
5646  199C
5647  199D
5648  199E
5649  199F
5650  19A0
5651  19A1
5652  19A2
5653  19A3
5654  19A4
5655  19A5
5656  19A6
5657  19A7
5658  19A8
5659  19A9
5660  19AA
5661  19AB
5662  19AC
5663  19AD
5664  19AE
5665  19AF
5666  19B0
5667  19B1
5668  19B2
5669  19B3
5670  19B4
5671  19B5
5672  19B6
5673  19B7
5674  19B8
5675  19B9
5676  19BA
5677  19BB
5678  19BC
5679  19BD
5680  19BE
5681  19BF
5682  19C0
5683  19C1
5684  19C2
5685  19C3
5686  19C4
5687  19C5
5688  19C6
5689  19C7
5690  19C8
5691  19C9
5692  19CA
5693  19CB
5694  19CC
5695  19CD
5696  19CE
5697  19CF
5698  19D0
5699  19D1
5700  19D2
5701  19D3
5702  19D4
5703  19D5
5704  19D6
5705  19D7
5706  19D8
5707  19D9
5708  19DA
5709  19DB
5710  19DC
5711  19DD
5712  19DE
5713  19DF
5714  19E0
5715  19E1
5716  19E2
5717  19E3
5718  19E4
5719  19E5
5720  19E6
5721  19E7
5722  19E8
5723  19E9
5724  19EA
5725  19EB
5726  19EC
5727  19ED
5728  19EE
5729  19EF
5730  19F0
5731  19F1
5732  19F2
5733  19F3
5734  19F4
5735  19F5
5736  19F6
5737  19F7
5738  19F8
5739  19F9
5740  19FA
5741  19FB
5742  19FC
5743  19FD
5744  19FE
5745  19FF
5746  1A00
5747  1A01
5748  1A02
5749  1A03
5750  1A04
5751  1A05
5752  1A06
5753  1A07
5754  1A08
5755  1A09
5756  1A0A
5757  1A0B
5758  1A0C
5759  1A0D
5760  1A0E
5761  1A0F
5762  1A10
5763  1A11
5764  1A12
5765  1A13
5766  1A14
5767  1A15
5768  1A16
5769  1A17
5770  1A18
5771  1A19
5772  1A1A
5773  1A1B
5774  1A1C
5775  1A1D
5776  1A1E
5777  1A1F
5778  1A20
5779  1A21
5780  1A22
5781  1A23
5782  1A24
5783  1A25
5784  1A26
5785  1A27
5786  1A28
5787  1A29
5788  1A2A
5789  1A2B
5790  1A2C
5791  1A2D
5792  1A2E
5793  1A2F
5794  1A30
5795  1A31
5796  1A32
5797  1A33
5798  1A34
5799  1A35
5800  1A36
5801  1A37
5802  1A38
5803  1A39
5804  1A3A
5805  1A3B
5806  1A3C
5807  1A3D
5808  1A3E
5809  1A3F
5810  1A40
5811  1A41
5812  1A42
5813  1A43
5814  1A44
5815  1A45
5816  1A46
5817  1A47
5818  1A48
5819  1A49
5820  1A4A
5821  1A4B
5822  1A4C
5823  1A4D
5824  1A4E
5825  1A4F
5826  1A50
5827  1A51
5828  1A52
5829  1A53
5830  1A54
5831  1A55
5832  1A56
5833  1A57
5834  1A58
5835  1A59
5836  1A5A
5837  1A5B
5838  1A5C
5839  1A5D
5840  1A5E
5841  1A5F
5842  1A60
5843  1A61
5844  1A62
5845  1A63
5846  1A64
5847  1A65
5848  1A66
5849  1A67
5850  1A68
5851  1A69
5852  1A6A
5853  1A6B
5854  1A6C
5855  1A6D
5856  1A6E
5857  1A6F
5858  1A70
5859  1A71
5860  1A72
5861  1A73
5862  1A74
5863  1A75
5864  1A76
5865  1A77
5866  1A78
5867  1A79
5868  1A7A
5869  1A7B
5870  1A7C
5871  1A7D
5872  1A7E
5873  1A7F
5874  1A80
5875  1A81
5876  1A82
5877  1A83
5878  1A84
5879  1A85
5880  1A86
5881  1A87
5882  1A88
5883  1A89
5884  1A8A
5885  1A8B
5886  1A8C
5887  1A8D
5888  1A8E
5889  1A8F
5890  1A90
5891  1A91
5892  1A92
5893  1A93
5894  1A94
5895  1A95
5896  1A96
5897  1A97
5898  1A98
5899  1A99
5900  1A9A
5901  1A9B
5902  1A9C
5903  1A9D
5904  1A9E
5905  1A9F
5906  1AA0
5907  1AA1
5908  1AA2
5909  1AA3
5910  1AA4
5911  1AA5
5912  1AA6
5913  1AA7
5914  1AA8
5915  1AA9
5916  1AAA
5917  1AAB
5918  1AAC
5919  1AAD
5920  1AAE
5921  1AAF
5922  1AB0
5923  1AB1
5924  1AB2
5925  1AB3
5926  1AB4
5927  1AB5
5928  1AB6
5929  1AB7
5930  1AB8
5931  1AB9
5932  1ABA
5933  1ABB
5934  1ABC
5935  1ABD
5936  1ABE
5937  1ABF
5938  1AC0
5939  1AC1
5940  1AC2
5941  1AC3
5942  1AC4
5943  1AC5
5944  1AC6
5945  1AC7
5946  1AC8
5947  1AC9
5948  1ACA
5949  1ACB
5950  1ACC
5951  1ACD
5952  1ACE
5953  1ACF
5954  1AD0
5955  1AD1
5956  1AD2
5957  1AD3
5958  1AD4
5959  1AD5
5960  1AD6
5961  1AD7
5962  1AD8
5963  1AD9
5964  1ADA
5965  1ADB
5966  1ADC
5967  1ADD
5968  1ADE
5969  1ADF
5970  1AE0
5971  1AE1
5972  1AE2
5973  1AE3
5974  1AE4
5975  1AE5
5976  1AE6
5977  1AE7
5978  1AE8
5979  1AE9
5980  1AEA
5981  1AEB
5982  1AEC
5983  1AED
5984  1AEE
5985  1AEF
5986  1AF0
5987  1AF1
5988  1AF2
5989  1AF3
5990  1AF4
5991  1AF5
5992  1AF6
5993  1AF7
5994  1AF8
5995  1AF9
5996  1AFA
5997  1AFB
5998  1AFC
5999  1AFD
6000  1AFE
6001  1AFF
6002  1B00
6003  1B01
6004  1B02
6005  1B03
6006  1B04
6007  1B05
6008  1B06
6009  1B07
6010  1B08
6011  1B09
6012  1B0A
6013  1B0B
6014  1B0C
6015  1B0D
6016  1B0E
6017  1B0F
6018  1B10
6019  1B11
6020  1B12
6021  1B13
6022  1B14
6023  1B15
6024  1B16
6025  1B17
6026  1B18
6027  1B19
6028  1B1A
6029  1B1B
6030  1B1C
6031  1B1D
6032  1B1E
6033  1B1F
6034  1B20
6035  1B21
6036  1B22
6037  1B23
6038  1B24
6039  1B25
6040  1B26
6041  1B27
6042  1B28
6043  1B29
6044  1B2A
6045  1B2B
6046  1B2C
6047  1B2D
6048  1B2E
6049  1B2F
6050  1B30
6051  1B31
6052  1B32
6053  1B33
6054  1B34
6055  1B35
6056  1B36
6057  1B37
6058  1B38
6059  1B39
6060  1B3A
6061  1B3B
6062  1B3C
6063  1B3D
6064  1B3E
6065  1B3F
6066  1B40
6067  1B41
6068  1B42
6069  1B43
6070  1B44
6071  1B45
6072  1B46
6073  1B47
6074  1B48
6075  1B49
6076  1B4A
6077  1B4B
6078  1B4C
6079  1B4D
6080  1B4E
6081  1B4F
6082  1B50
6083  1B51
6084  1B52
6085  1B53
6086  1B54
6087  1B55
6088  1B56
6089  1B57
6090  1B58
6091  1B59
6092  1B5A
6093  1B5B
6094  1B5C
6095  1B5D
6096  1B5E
6097  1B5F
6098  1B60
6099  1B61
6100  1B62
6101  1B63
6102  1B64
6103  1B65
6104  1B66
6105  1B67
6106  1B68
6107  1B69
6108  1B6A
6109  1B6B
6110  1B6C
6111  1B6D
6112  1B6E
6113  1B6F
6114  1B70
6115  1B71
6116  1B72
6117  1B73
6118  1B74
6119  1B75
6120  1B76
6121  1B77
6122  1B78
6123  1B79
6124  1B7A
6125  1B7B
6126  1B7C
6127  1B7D
6128  1B7E
6129  1B7F
6130  1B80
6131  1B81
6132  1B82
6133  1B83
6134  1B84
6135  1B85
6136  1B86
6137  1B87
6138  1B88
6139  1B89
6140  1B8A
6141  1B8B
6142  1B8C
6143  1B8D
6144  1B8E
6145  1B8F
6146  1B90
6147  1B91
6148  1B92
6149  1B93
6150  1B94
6151  1B95
6152  1B96
6153  1B97
6154  1B98
6155  1B99
6156  1B9A
6157  1B9B
6158  1B9C
6159  1B9D
6160  1B9E
6161  1B9F
6162  1BA0
6163  1BA1
6164  1BA2
6165  1BA3
6166  1BA4
6167  1BA5
6168  1BA6
6169  1BA7
6170  1BA8
6171  1BA9
6172  1BAA
6173  1BAB
6174  1BAC
6175  1BAD
6176  1BAE
6177  1BAF
6178  1BB0
6179  1BB1
6180  1BB2
6181  1BB3
6182  1BB4
6183  1BB5
6184  1BB6
6185  1BB7
6186  1BB8
6187  1BB9
6188  1BBA
6189  1BBB
6190  1BBC
6191  1BBD
6192  1BBE
6193  1BBF
6194  1BC0
6195  1BC1
6196  1BC2
6197  1BC3
6198  1BC4
6199  1BC5
6200  1BC6
6201  1BC7
6202  1BC8
6203  1BC9
6204  1BCA
6205  1BCB
6206  1BCC
6207  1BCD
6208  1BCE
6209  1BCF
6210  1BD0
6211  1BD1
6212  1BD2
6213  1BD3
6214  1BD4
6215  1BD5
6216  1BD6
6217  1BD7
6218  1BD8
6219  1BD9
6220  1BDA
6221  1BDB
6222  1BDC
6223  1BDD
6224  1BDE
6225  1BDF
6226  1BE0
6227  1BE1
6228  1BE2
6229  1BE3
6230  1BE4
6231  1BE5
6232  1BE6
6233  1BE7
6234  1BE8
6235  1BE9
6236  1BEA
6237  1BEB
6238  1BEC
6239  1BED
6240  1BEE
6241  1BEF
6242  1BF0
6243  1BF1
6244  1BF2
6245  1BF3
6246  1BF4
6247  1BF5
6248  1BF6
6249  1BF7
6250  1BF8
6251  1BF9
6252  1BFA
6253  1BFB
6254  1BFC
6255  1BFD
6256  1BFE
6257  1BFF
6258  1C00
6259  1C01
6260  1C02
6261  1C03
6262  1C04
6263  1C05
6264  1C06
6265  1C07
6266  1C08
6267  1C09
6268  1C0A
6269  1C0B
6270  1C0C
6271  1C0D
6272  1C0E
6273  1C0F
6274  1C10
6275  1C11
6276  1C12
6277  1C13
6278  1C14
6279  1C15
6280  1C16
6281  1C17
6282  1C18
6283  1C19
6284  1C1A
6285  1C1B
6286  1C1C
6287  1C1D
6288  1C1E
6289  1C1F
6290  1C20
6291  1C21
6292  1C22
6293  1C23
6294  1C24
6295  1C25
6296  1C26
6297  1C27
6298  1C28
6299  1C29
6300  1C2A
6301  1C2B
6302  1C2C
6303  1C2D
6304  1C2E
6305  1C2F
6306  1C30
6307  1C31
6308  1C32
6309  1C33
6310  1C34
6311  1C35
6312  1C36
6313  1C37
6314  1C38
6315  1C39
6316  1C3A
6317  1C3B
6318  1C3C
6319  1C3D
6320  1C3E
6321  1C3F
6322  1C40
6323  1C41
6324  1C42
6325  1C43
6326  1C44
6327  1C45
6328  1C46
6329  1C47
6330  1C48
6331  1C49
6332  1C4A
6333  1C4B
6334  1C4C
6335  1C4D
6336  1C4E
6337  1C4F
6338  1C50
6339  1C51
6340  1C52
6341  1C53
6342  1C54
6343  1C55
6344  1C56
6345  1C57
6346  1C58
6347  1C59
6348  1C5A
6349  1C5B
6350  1C5C
6351  1C5D
6352  1C5E
6353  1C5F
6354  1C60
6355  1C61
6356  1C62
6357  1C63
6358  1C64
6359  1C65
6360  1C66
6361  1C67
6362  1C68
6363  1C69
6364  1C6A
6365  1C6B
6366  1C6C
6367  1C6D
6368  1C6E
6369  1C6F
6370  1C70
6371  1C71
6372  1C72
6373  1C73
6374  1C74
6375  1C75
6376  1C76
6377  1C77
6378  1C78
6379  1C79
6380  1C7A
6381  1C7B
6382  1C7C
6383  1C7D
6384  1C7E
6385  1C7F
6386  1C80
6387  1C81
6388  1C82
6389  1C83
6390  1C84
6391  1C85
6392  1C86
6393  1C87
6394  1C88
6395  1C89
6396  1C8A
6397  1C8B
6398  1C8C
6399  1C8D
6400  1C8E
6401  1C8F
6402  1C90
6403  1C91
6404  1C92
6405  1C93
6406  1C94
6407  1C95
6408  1C96
6409  1C97
6410  1C98
6411  1C99
6412  1C9A
6413  1C9B
6414  1C9C
6415  1C9D
6416  1C9E
6417  1C9F
6418  1CA0
6419  1CA1
6420  1CA2
6421  1CA3
6422  1CA4
6423  1CA5
6424  1CA6
6425  1CA7
6426  1CA8
6427  1CA9
6428  1CAA
6429  1CAB
6430  1CAC
6431  1CAD
6432  1CAE
6433  1CAF
6434  1CB0
6435  1CB1
6436  1CB2
6437  1CB3
6438  1CB4
6439  1CB5
6440  1CB6
6441  1CB7
6442  1CB8
6443  1CB9
6444  1CBA
6445  1CBB
6446  1CBC
6447  1CBD
6448  1CBE
6449  1CBF
6450  1CC0
6451  1CC1
6452  1CC2
6453  1CC3
6454  1CC4
6455  1CC5
6456  1CC6
6457  1CC7
6458  1CC8
6459  1CC9
6460  1CCA
6461  1CCB
6462  1CCC
6463  1CCD
6464  1CCE
6465  1CCF
6466  1CD0
6467  1CD1
6468  1CD2
6469  1CD3
6470  1CD4
6471  1CD5
6472  1CD6
6473  1CD7
6474  1CD8
6475  1CD9
6476  1CDA
6477  1CDB
6478  1CDC
6479  1CDD
6480  1CDE
6481  1CDF
6482  1CE0
6483  1CE1
6484  1CE2
6485  1CE3
6486  1CE4
6487  1CE5
6488  1CE6
6489  1CE7
6490  1CE8
6491  1CE9
6492  1CEA
6493  1CEB
6494  1CEC
6495  1CED
6496  1CEE
6497  1CEF
6498  1CF0
6499  1CF1
6500  1CF2
6501  1CF3
6502  1CF4
6503  1CF5
6504  1CF6
6505  1CF7
6506  1CF8
6507  1CF9
6508  1CFA
6509  1CFB
6510  1CFC
6511  1CFD
6512  1CFE
6513  1CFF
6514  1D00
6515  1D01
6516  1D02
6517  1D03
6518  1D04
6519  1D05
6520  1D06
6521  1D07
6522  1D08
6523  1D09
6524  1D0A
6525  1D0B
6526  1D0C
6527  1D0D
6528  1D0E
6529  1D0F
6530  1D10
6531  1D11
6532  1D12
6533  1D13
6534  1D14
6535  1D15
6536  1D16
6537  1D17
6538  1D18
6539  1D19
6540  1D1A
6541  1D1B
6542  1D1C
6543  1D1D
6544  1D1E
6545  1D1F
6546  1D20
6547  1D21
6548  1D22
6549  1D23
6550  1D24
6551  1D25
6552  1D26
6553  1D27
6554  1D28
6555  1D29
6556  1D2A
6557  1D2B
6558  1D2C
6559  1D2D
6560  1D2E
6561  1D2F
6562  1D30
6563  1D31
6564  1D32
6565  1D33
6566  1D34
6567  1D35
6568  1D36
6569  1D37
6570  1D38
6571  1D39
6572  1D3A
6573  1D3B
6574  1D3C
6575  1D3D
6576  1D3E
6577  1D3F
6578  1D40
6579  1D41
6580  1D42
6581  1D43
6582  1D44
6583  1D45
6584  1D46
6585  1D47
6586  1D48
6587  1D49
6588  1D4A
6589  1D4B
6590  1D4C
6591  1D4D
6592  1D4E
6593  1D4F
6594  1D50
6595  1D51
6596  1D52
6597  1D53
6598  1D54
6599  1D55
6600  1D56
6601  1D57
6602  1D58
6603  1D59
6604  1D5A
6605  1D5B
6606  1D5C
6607  1D5D
6608  1D5E
6609  1D5F
6610  1D60
6611  1D61
6612  1D62
6613  1D63
6614  1D64
6615  1D65
6616  1D66
6617  1D67
6618  1D68
6619  1D69
6620  1D6A
6621  1D6B
6622  1D6C
6623  1D6D
6624  1D6E
6625  1D6F
6626  1D70
6627  1D71
6628  1D72
6629  1D73
6630  1D74
6631  1D75
6632  1D76
6633  1D77
6634  1D78
6635  1D79
6636  1D7A
6637  1D7B
6638  1D7C
6639  1D7D
6640  1D7E
6641  1D7F
6642  1D80
6643  1D81
6644  1D82
6645  1D83
6646  1D84
6647  1D85
6648  1D86
6649  1D87
6650  1D88
6651  1D89
6652  1D8A
6653  1D8B
6654  1D8C
6655  1D8D
6656  1D8E
6657  1D8F
6658  1D90
6659  1D91
6660  1D92
6661  1D93
6662  1D94
6663  1D95
6664  1D96
6665  1D97
6666  1D98
6667  1D99
6668  1D9A
6669  1D9B
6670  1D9C
6671  1D9D
6672  1D9E
6673  1D9F
6674  1DA0
6675  1DA1
6676  1DA2
6677  1DA3
6678  1DA4
6679  1DA5
6680  1DA6
6681  1DA7
6682  1DA8
6683  1DA9
6684  1DAA
6685  1DAB
6686  1DAC
6687  1DAD
6688  1DAE
6689  1DAF
6690  1DB0
6691  1DB1
6692  1DB2
6693  1DB3
6694  1DB4
6695  1DB5
6696  1DB6
6697  1DB7
6698  1DB8
6699  1DB9
6700  1DBA
6701  1DBB
6702  1DBC
6703  1DBD
6704  1DBE
6705  1DBF
6706  1DC0
6707  1DC1
6708  1DC2
6709  1DC3
6710  1DC4
6711  1DC5
6712  1DC6
6713  1DC7
6714  1DC8
6715  1DC9
6716  1DCA
6717  1DCB
6718  1DCC
6719  1DCD
6720  1DCE
6721  1DCF
6722  1DD0
6723  1DD1
6724  1DD2
6725  1DD3
6726  1DD4
6727  1DD5
6728  1DD6
6729  1DD7
6730  1DD8
6731  1DD9
6732  1DDA
6733  1DDB
6734  1DDC
6735  1DDD
6736  1DDE
6737  1DDF
6738  1DE0
6739  1DE1
6740  1DE2
6741  1DE3
6742  1DE4
6743  1DE5
6744  1DE6
6745  1DE7
6746  1DE8
6747  1DE9
6748  1DEA
6749  1DEB
6750  1DEC
6751  1DED
6752  1DEE
6753  1DEF
6754  1DF0
6755  1DF1
6756  1DF2
6757  1DF3
6758  1DF4
6759  1DF5
6760  1DF6
6761  1DF7
6762  1DF8
6763  1DF9
6764  1DFA
6765  1DFB
6766  1DFC
6767  1DFD
6768  1DFE
6769  1DFF
6770  1E00
6771  1E01
6772  1E02
6773  1E03
6774  1E04
6775  1E05
6776  1E06
6777  1E07
6778  1E08
6779  1E09
6780  1E0A
6781  1E0B
6782  1E0C
6783  1E0D
6784  1E0E
6785  1E0F
6786  1E10
6787  1E11
6788  1E12
6789  1E13
6790  1E14
6791  1E15
6792  1E16
6793  1E17
6794  1E18
6795  1E19
6796  1E1A
6797  1E1B
6798  1E1C
6799  1E1D
6800  1E1E
6801  1E1F
6802  1E20
6803  1E21
6804  1E22
6805  1E23
6806  1E24
6807  1E25
6808  1E26
6809  1E27
6810  1E28
6811  1E29
6812  1E2A
6813  1E2B
6814  1E2C
6815  1E2D
6816  1E2E
6817  1E2F
6818  1E30
6819  1E31
6820  1E32
6821  1E33
6822  1E34
6823  1E35
6824  1E36
6825  1E37
6826  1E38
6827  1E39
6828  1E3A
6829  1E3B
6830  1E3C
6831  1E3D
6832  1E3E
6833  1E3F
6834  1E40
6835  1E41
6836  1E42
6837  1E43
6838  1E44
6839  1E45
6840  1E46
6841  1E47
6842  1E48
6843  1E49
6844  1E4A
6845  1E4B
6846  1E4C
6847  1E4D
6848  1E4E
6849  1E4F
6850  1E50
6851  1E51
6852  1E52
6853  1E53
6854  1E54
6855  1E55
6856  1E56
6857  1E57
6858  1E58
6859  1E59
6860  1E5A
6861  1E5B
6862  1E5C
6863  1E5D
6864  1E5E
6865  1E5F
6866  1E60
6867  1E61
6868  1E62
6869  1E63
6870  1E64
6871  1E65
6872  1E66
6873  1E67
6874  1E68
6875  1E69
6876  1E6A
6877  1E6B
6878  1E6C
6879  1E6D
6880  1E6E
6881  1E6F
6882  1E70
6883  1E71
6884  1E72
6885  1E73
6886  1E74
6887  1E75
6888  1E76
6889  1E77
6890  1E78
6891  1E79
6892  1E7A
6893  1E7B
6894  1E7C
6895  1E7D
6896  1E7E
6897  1E7F
6898  1E80
6899  1E81
6900  1E82
6901  1E83
6902  1E84
6903  1E85
6904  1E86
6905  1E87
6906  1E88
6907  1E89
6908  1E8A
6909  1E8B
6910  1E8C
6911  1E8D
6912  1E8E
6913  1E8F
6914  1E90
6915  1E91
6916  1E92
6917  1E93
6918  1E94
6919  1E95
6920  1E96
6921  1E97
6922  1E98
6923  1E99
6924  1E9A
6925  1E9B
6926  1E9C
6927  1E9D
6928  1E9E
6929  1E9F
6930  1EA0
6931  1EA1
6932  1EA2
6933  1EA3
6934  1EA4
6935  1EA5
6936  1EA6
6937  1EA7
6938  1EA8
6939  1EA9
6940  1EAA
6941  1EAB
6942  1EAC
6943  1EAD
6944  1EAE
6945  1EAF
6946  1EB0
6947  1EB1
6948  1EB2
6949  1EB3
6950  1EB4
6951  1EB5
006952  000306        
006953  000307  var stringsCV[11] := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], hstrings ;
6954  0F74
6955  0F75
6956  0F76
6957  0F77
6958  0F78
6959  0F79
6960  0F7A
6961  0F7B
6962  0F7C
6963  0F7D
6964  0F7E
6965  0F7F
6966  0F80
6967  0F81
6968  0F82
6969  0F83
6970  0F84
6971  0F85
6972  0F86
6973  0F87
6974  0F88
6975  0F89
006976  000308  // Start P2.inc
006977  000309  var oObjects[MaxTotObjects+1] ;                 // address of objects
006978  000310  var CurrentForm, oldn, ImageTouched ;
006979  000311  var TouchXpos, TouchYpos ;
006980  000312  var GObjectType, TouchState, CurInputData, pInputIndex ;
006981  000313  var comRX[40], cmd[CMDLenMAX] ;
006982  000314        
006983  000315  var InputCS, OutputCS ;
006984  000316        
006985  000317  // > ? Constant/Global/Data ? <
006986  000318        
006987  000319  func seroutCS(var op)
006988  000320      serout(op) ;
006989  000321      OutputCS ^= op ;
006990  000322  endfunc
006991  000323        
006992  000324  func nak0()
006993  000325      serout(NAK) ;
006994  000326      InputCS := 0 ;
006995  000327  endfunc
006996  000328        
006997  000329  func seroutOcs()
006998  000330      serout(OutputCS) ;
006999  000331      OutputCS := 0 ;
007000  000332  endfunc
007001  000333        
007002  000334  func SendReport(var id, var objt, var objn, var val)
007003  000335      seroutCS(id) ;
007004  000336      seroutCS(objt) ;
007005  000337      seroutCS(objn) ;
007006  000338      seroutCS(val >> 8) ; // first 8 bits
007007  000339      seroutCS(val) ;
007008  000340      seroutOcs() ;
007009  000341  endfunc
007010  000342        
007011  000343        
007012  000344  func ReadObject(var ObjectType, var ObjectIdx)
007013  000345      var j, k, Objects ;
007014  000346      Objects := *(oObjects+ObjectType) ;
007015  000347        
007016  000348      j := 2 + ObjectIdx * 2 + Objects ;
007017  000349       if (ObjectType == tForm)
007018  000350          k := CurrentForm ;
007019  000351      else if ((ObjectType == tCustomdigits) || (ObjectType == tLeddigits))
007020  000352          k := img_GetWord(hndl, *j, IMAGE_TAG2);
007021  000353      else if (ObjectType == tStrings)
007022  000354          k := stringsCV[ObjectIdx];
007023  000355          else
007024  000356          k := img_GetWord(hndl, *j, IMAGE_INDEX);
007025  000357          if (((ObjectType == tWinButton) || (ObjectType == tAniButton) || (ObjectType == tUserButton) || (ObjectType == t4Dbutton)) && (k)) k := 1 ; // this is not correct for blocked buttons and cannot be fixed as we cannot
007026  000358                                                                                                                                                      // determine if button is momentary or not which is needed for correct answer.
007027  000359      endif
007028  000360      SendReport(REPORT_OBJ, ObjectType, ObjectIdx, k) ;
007029  000361  endfunc
007030  000362        
007031  000363        
007032  000364  func WriteObject(var ObjectType, var ObjectIdx, var NewVal)
007033  000365      var i, j, k, Objects ;
007034  000366      ObjectType &= 0x3f ;
007035  000367      if (ObjectType == tForm)
007036  000368          ActivateForm(ObjectIdx) ;
007037  000369      else
007038  000370          Objects := *(oObjects+ObjectType)+ObjectIdx*2+2 ;
007039  000371          i := *(Objects) ;
007040  000372          switch (ObjectType)
007041  000373              case tWinButton :
007042  000374                  j := InputControls[oWinButtons[ObjectIdx+1]] ;
007043  000375                  break ;
007044  000376              default : j := -1 ;
007045  000377          endswitch
007046  000378          if (j != -1)
007047  000379              k := img_GetWord(hndl, i , IMAGE_INDEX) ;
007048  000380              NewVal := NewVal << 1 ;
007049  000381              if (OVF())      // button group index change
007050  000382                  if (*(j+InputData+Ofs_IPD_P1))
007051  000383                      k &= 1 ;    // mask off old group index for momentary
007052  000384                  else
007053  000385                      k &= 3 ;    // mask off old group index for toggle
007054  000386                  endif
007055  000387              else            // normal set
007056  000388                  if (*(j+InputData+Ofs_IPD_P2) != -1) TurnOffButtons(*(j+InputData+Ofs_IPD_P2)) ;
007057  000389                  k &= 0xfffc ;    // retain only group index for state set
007058  000390              endif
007059  000391              NewVal |= k ;
007060  000392          endif
007061  000393           if (ObjectType == tLeddigits)
007062  000394              img_SetWord(hndl, i , IMAGE_TAG2, NewVal); // where state is 0 to 2
007063  000395              ledDigitsDisplay(i, oLeddigitss, oLedDigitsn) ;
007064  000396          else if (ObjectType == tStrings)
007065  000397              PrintStrings(ObjectIdx, NewVal, 0);
007066  000398          else
007067  000399              img_SetWord(hndl, i , IMAGE_INDEX, NewVal); // where state is 0 to 2
007068  000400              img_Show(hndl, i) ; // will only display if form is current
007069  000401          endif
007070  000402      endif
007071  000403  endfunc
007072  000404        
007073  000405  func TurnOffButtons(var group)
007074  000406      var j, k, l;
007075  000407      for (j := 0; j < nInputs; j++)
007076  000408          k := j*IPDatasize ;
007077  000409          if (*(InputData+k+Ofs_IPD_P2) == group)
007078  000410              l := -1 ;
007079  000411               if (*(InputData+k) == tWinButton)
007080  000412                  l := oWinButtons[*(InputData+k+Ofs_IPD_OBJVIDX)/2] ;
007081  000413                  img_SetWord(hndl, l, IMAGE_INDEX, 0);
007082  000414                  img_Show(hndl, l);      // only shows on current form
007083  000415              endif
007084  000416          endif
007085  000417      next
007086  000418  endfunc
007087  000419        
007088  000420        
007089  000421  // WARNING, this code will crash if newval exceeds maximum displayable number
007090  000422  func ledDigitsDisplay(var imgidx, var typeptr, var setptr)
007091  000423      var i, j, k, l, lb, newval, num[4] ;
007092  000424      if (!((img_GetWord(hndl, imgidx, IMAGE_FLAGS) & I_ENABLED))) return ;  // ;img_GetWord(hndl, imgidx, IMAGE_TAG2) ;if diabled then exit
007093  000425      newval := img_GetWord(hndl, imgidx, IMAGE_TAG2) ;
007094  000426      i := -1 ;
007095  000427      j := *(typeptr) ;
007096  000428      repeat
007097  000429          typeptr += 2 ;
007098  000430          i++ ;
007099  000431          until (*(typeptr) == imgidx);
007100  000432      j := setptr + i*10 ;
007101  000433        
007102  000434      l := 0x500a | (*(j+Ofs_Digits_Digits) << 8) ;       // UDECxZ
007103  000435      to(num) ;
007104  000436      putnum(l, newval) ;
007105  000437      imgidx++ ;
007106  000438      lb := *(j+Ofs_Digits_LeadingBlanks) ;
007107  000439      l := str_Ptr(num) ;
007108  000440      for (i := 0; i < *(j+Ofs_Digits_Digits); i++)
007109  000441          k := str_GetByte(l++) & 0x0f ;
007110  000442          if ( lb && (i < *(j+Ofs_Digits_Digits) - *(j+Ofs_Digits_MinDigits)) )
007111  000443              if (k == 0)
007112  000444                  k := 10 ;
007113  000445              else
007114  000446                  lb := 0 ;
007115  000447              endif
007116  000448          endif
007117  000449          img_SetWord(hndl, imgidx, IMAGE_INDEX, k);
007118  000450          img_SetWord(hndl, imgidx, IMAGE_XPOS, *(j+Ofs_Digits_Left)+i* *(j+Ofs_Digits_Widthdigit)) ;
007119  000451          img_Show(hndl, imgidx);
007120  000452      next
007121  000453  endfunc
007122  000454        
007123  000455        
007124  000456  func ActivateForm(var newform)
007125  000457      var i, j, *p ;
007126  000458        
007127  000459      if (CurrentForm != -1) // deactivate old form, by disabling all inputs
007128  000460          for (i := FormStartIndex[CurrentForm]; i <= FormEndIndex[CurrentForm]; i++)
007129  000461              if (img_GetWord(hndl, i, IMAGE_TAG))
007130  000462                  img_Disable(hndl,i) ;
007131  000463              endif
007132  000464          next
007133  000465      endif
007134  000466      CurrentForm := newform ;
007135  000467      // display newform image or clear to image color
007136  000468      if (FormBGcolors[CurrentForm] != ColorBGimage)
007137  000469          gfx_Set(BACKGROUND_COLOUR,FormBGcolors[CurrentForm]);
007138  000470          gfx_Cls() ;
007139  000471          DoGFXObjects() ;                                    // display GFX 'widgets'
007140  000472      endif
007141  000473        
007142  000474      // enable inputs
007143  000475      for (i := FormStartIndex[CurrentForm]; i < FormEndIndex[CurrentForm]; i++)
007144  000476          j := img_GetWord(hndl, i, IMAGE_TAG) ;
007145  000477          if (j)
007146  000478              j-- ;
007147  000479              img_SetAttributes(hndl, i, I_STAYONTOP+I_ENABLED);        // make sure this is on top of form, if applicable
007148  000480              //if (j != tKeyboard)
007149  000481              if ((j <= tWinButton) || (j >= t4Dbutton) )               // enable inputs
007150  000482                  img_ClearAttributes(hndl, i, I_TOUCH_DISABLE);        // ensure touch is enabled
007151  000483              endif
007152  000484              img_Show(hndl,i) ; // show initialy, if required
007153  000485              if (j == tForm)
007154  000486                  DoGFXObjects() ;                                    // display GFX 'widgets' for image backgruobds
007155  000487              else if (j == tLeddigits)
007156  000488                  ledDigitsDisplay(i, oLeddigitss, oLedDigitsn) ;
007157  000489              endif
007158  000490          endif
007159  000491      next
007160  000492      for (i := 0; i < nStrings; i++)
007161  000493          if (stringsCV[i] != -1)
007162  000494              WriteObject(tStrings, i, stringsCV[i]) ;
007163  000495          endif
007164  000496      next
007165  000497        
007166  000498  endfunc
007167  000499        
007168  000500  func UpdateObjects(var newval)
007169  000501      var IPidx, otherOBJ ;
007170  000502      if ( ( img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) != newval) || (TouchState == Ofs_IPD_RELEASE) ) // only bother if values changed, or release
007171  000503        
007172  000504          img_SetWord(hndl, *(pInputIndex), IMAGE_INDEX, newval);
007173  000505              img_Show(hndl, *(pInputIndex));      // only shows on current form
007174  000506          if ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))
007175  000507              if (*(CurInputData+Ofs_IPD_P1))
007176  000508                  newval &= 1;
007177  000509              else
007178  000510                  newval &= 3;
007179  000511              endif
007180  000512              if (newval > 1) newval := 1;
007181  000513          endif
007182  000514          IPidx := *(CurInputData+TouchState) ;
007183  000515          while(IPidx != 0)
007184  000516              otherOBJ := IPidx + InputData;
007185  000517              if (*(otherOBJ) == OT_REPORT)
007186  000518          SendReport(REPORT_EVENT, GObjectType, *(otherOBJ+Ofs_IPD_OBJVIDX), newval) ;
007187  000519              else if (*(otherOBJ) == OT_MAGIC)
007188  000520                  IPidx := *(otherOBJ+Ofs_IPD_P5) ;
007189  000521                  IPidx(newval) ;
007190  000522              else if (TouchState == *(otherOBJ+Ofs_IPD_P4))
007191  000523                  if (*(otherOBJ) == OT_ACTIVATE)
007192  000524                      ActivateForm(*(otherOBJ+Ofs_IPD_P2) ) ;
007193  000525                      GObjectType := tForm ;
007194  000526                  else if (*(otherOBJ) == OT_SETCONST)
007195  000527                      newval := *(otherOBJ+Ofs_IPD_P3) ;
007196  000528                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
007197  000529                  else if (*(otherOBJ) == OT_SETANOTHER)
007198  000530                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
007199  000531                  else if (*(otherOBJ) == OT_PREVFRAME)
007200  000532                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX))
007201  000533                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)-1) ;
007202  000534                      endif
007203  000535                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
007204  000536                  else if (*(otherOBJ) == OT_NEXTFRAME)
007205  000537                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) < *(otherOBJ+Ofs_IPD_P3))
007206  000538                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)+1) ;
007207  000539                      endif
007208  000540                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
007209  000541                  else if (*(otherOBJ) == OT_PREVSTRING)
007210  000542                      if (stringsCV[*(otherOBJ+Ofs_IPD_P2)])
007211  000543                          WriteObject(tStrings,*(otherOBJ+Ofs_IPD_P2),stringsCV[*(otherOBJ+Ofs_IPD_P2)]-1) ;
007212  000544                      endif
007213  000545                  else if (*(otherOBJ) == OT_NEXTSTRING)
007214  000546                      if (stringsCV[*(otherOBJ+Ofs_IPD_P2)] < *(otherOBJ+Ofs_IPD_P3)) // fix IPD_P2 not filled in yet
007215  000547                          WriteObject(tStrings,*(otherOBJ+Ofs_IPD_P2),stringsCV[*(otherOBJ+Ofs_IPD_P2)]+1) ;
007216  000548                      endif
007217  000549                  endif
007218  000550              endif
007219  000551              IPidx := *(otherOBJ+TouchState) ;
007220  000552          wend
007221  000553      endif
007222  000554  endfunc
007223  000555        
007224  000556  // End P2.inc
007225  000557  func DoGFXObjects()
007226  000558      switch (CurrentForm)
007227  000559          case 1:
007228  000560              gfx_OutlineColour(WHITE) ;
007229  000561              gfx_LinePattern(LPFINE) ;
007230  000562              gfx_Rectangle(24, 100, 174, 256, YELLOW) ;
007231  000563              gfx_OutlineColour(BLACK) ;
007232  000564              gfx_LinePattern(LPSOLID) ;
007233  000565              gfx_OutlineColour(WHITE) ;
007234  000566              gfx_LinePattern(LPFINE) ;
007235  000567              gfx_Rectangle(320, 24, 473, 176, YELLOW) ;
007236  000568              gfx_OutlineColour(BLACK) ;
007237  000569              gfx_LinePattern(LPSOLID) ;
007238  000570          break ;
007239  000571          case 2:
007240  000572              gfx_OutlineColour(WHITE) ;
007241  000573              gfx_LinePattern(LPFINE) ;
007242  000574              gfx_Rectangle(8, 60, 237, 177, YELLOW) ;
007243  000575              gfx_OutlineColour(BLACK) ;
007244  000576              gfx_LinePattern(LPSOLID) ;
007245  000577              gfx_OutlineColour(WHITE) ;
007246  000578              gfx_LinePattern(LPFINE) ;
007247  000579              gfx_Rectangle(8, 188, 237, 257, 0xF800) ;
007248  000580              gfx_OutlineColour(BLACK) ;
007249  000581              gfx_LinePattern(LPSOLID) ;
007250  000582              gfx_OutlineColour(WHITE) ;
007251  000583              gfx_LinePattern(LPFINE) ;
007252  000584              gfx_Rectangle(248, 136, 471, 259, 0x34DF) ;
007253  000585              gfx_OutlineColour(BLACK) ;
007254  000586              gfx_LinePattern(LPSOLID) ;
007255  000587              gfx_OutlineColour(WHITE) ;
007256  000588              gfx_LinePattern(LPFINE) ;
007257  000589              gfx_Rectangle(248, 68, 374, 131, 0xA514) ;
007258  000590              gfx_OutlineColour(BLACK) ;
007259  000591              gfx_LinePattern(LPSOLID) ;
007260  000592          break ;
007261  000593          case 3:
007262  000594              gfx_OutlineColour(WHITE) ;
007263  000595              gfx_LinePattern(LPFINE) ;
007264  000596              gfx_Rectangle(24, 100, 285, 259, YELLOW) ;
007265  000597              gfx_OutlineColour(BLACK) ;
007266  000598              gfx_LinePattern(LPSOLID) ;
007267  000599              gfx_OutlineColour(WHITE) ;
007268  000600              gfx_LinePattern(LPFINE) ;
007269  000601              gfx_Rectangle(332, 100, 464, 259, 0xF800) ;
007270  000602              gfx_OutlineColour(BLACK) ;
007271  000603              gfx_LinePattern(LPSOLID) ;
007272  000604          break ;
007273  000605          case 4:
007274  000606              gfx_OutlineColour(WHITE) ;
007275  000607              gfx_LinePattern(LPFINE) ;
007276  000608              gfx_Rectangle(30, 78, 295, 257, YELLOW) ;
007277  000609              gfx_OutlineColour(BLACK) ;
007278  000610              gfx_LinePattern(LPSOLID) ;
007279  000611              gfx_OutlineColour(WHITE) ;
007280  000612              gfx_LinePattern(LPFINE) ;
007281  000613              gfx_Rectangle(320, 80, 446, 256, 0xF800) ;
007282  000614              gfx_OutlineColour(BLACK) ;
007283  000615              gfx_LinePattern(LPSOLID) ;
007284  000616          break ;
007285  000617          case 5:
007286  000618              gfx_OutlineColour(WHITE) ;
007287  000619              gfx_LinePattern(LPFINE) ;
007288  000620              gfx_Rectangle(32, 92, 274, 233, YELLOW) ;
007289  000621              gfx_OutlineColour(BLACK) ;
007290  000622              gfx_LinePattern(LPSOLID) ;
007291  000623              gfx_OutlineColour(WHITE) ;
007292  000624              gfx_LinePattern(LPFINE) ;
007293  000625              gfx_Rectangle(336, 92, 461, 234, 0xF800) ;
007294  000626              gfx_OutlineColour(BLACK) ;
007295  000627              gfx_LinePattern(LPSOLID) ;
007296  000628          break ;
007297  000629      endswitch
007298  000630  endfunc
007299  000631        
007300  000632  // Start P3.inc
007301  000633  func main()
007302  000634      var comTX[50], cmdi, i, j, TouchStatus ;
007303  000635        
007304  000636        
007305  000637      gfx_ScreenMode(LANDSCAPE) ;
007306  000638        
007307  000639      putstr("Mounting...\n");
007308  000640      if (!(file_Mount()))
007309  000641          while(!(file_Mount()))
007310  000642              putstr("Drive not mounted...");
007311  000643              pause(200);
007312  000644              gfx_Cls();
007313  000645              pause(200);
007314  000646          wend
007315  000647      endif
007316  000648  //    gfx_MoveTo(0, 0);
007317  000649  //    print(mem_Heap()," ") ;
007318  000650  //    gfx_TransparentColour(0x0020);
007319  000651  //    gfx_Transparency(ON);
007320  000652        
007321  000653      // open image control
007322  000654      hndl := file_LoadImageControl("Prototip.dat", "Prototip.gci", 1);
007323  000655        
007324  000656      // init 'constants'
007325  000657  // End P3.inc
007326  000658        
007327  000659      oObjects[tDipSwitch] := oDipSwitchs ; // dummy as no object there
007328  000660      oObjects[tKnob] := oDipSwitchs ; // dummy as no object there
007329  000661      oObjects[tRockerSwitch] := oDipSwitchs ; // dummy as no object there
007330  000662      oObjects[tRotarySwitch] := oDipSwitchs ; // dummy as no object there
007331  000663      oObjects[tGSlider] := oDipSwitchs ; // dummy as no object there
007332  000664      oObjects[tTrackbar] := oDipSwitchs ; // dummy as no object there
007333  000665      oObjects[tWinButton] := oWinButtons ;
007334  000666      oObjects[tAngularmeter] := oDipSwitchs ; // dummy as no object there
007335  000667      oObjects[tCoolgauge] := oDipSwitchs ; // dummy as no object there
007336  000668      oObjects[tCustomdigits] := oDipSwitchs ; // dummy as no object there
007337  000669      oObjects[tForm] := oForms ;
007338  000670      oObjects[tGauge] := oDipSwitchs ; // dummy as no object there
007339  000671      oObjects[tImage] := oImages ;
007340  000672      oObjects[tKeyboard] := oDipSwitchs ; // dummy as no object there
007341  000673      oObjects[tLed] := oDipSwitchs ; // dummy as no object there
007342  000674      oObjects[tLeddigits] := oLeddigitss ;
007343  000675      oObjects[tMeter] := oDipSwitchs ; // dummy as no object there
007344  000676      oObjects[tStrings] := oStringss ;
007345  000677      oObjects[tThermometer] := oDipSwitchs ; // dummy as no object there
007346  000678      oObjects[tUserled] := oUserleds ;
007347  000679      oObjects[tVideo] := oDipSwitchs ; // dummy as no object there
007348  000680      oObjects[tStaticText] := oStaticTexts ;
007349  000681      oObjects[tSounds] := oDipSwitchs ; // dummy as no object there
007350  000682      oObjects[tTimer] := oDipSwitchs ; // dummy as no object there
007351  000683      oObjects[tSpectrum] := oDipSwitchs ; // dummy as no object there
007352  000684      oObjects[tTank] := oDipSwitchs ; // dummy as no object there
007353  000685      oObjects[tUserImages] := oDipSwitchs ; // dummy as no object there
007354  000686      oObjects[tPinOutput] := oDipSwitchs ; // dummy as no object there
007355  000687      oObjects[tPinInput] := oDipSwitchs ; // dummy as no object there
007356  000688      oObjects[t4Dbutton] := oDipSwitchs ; // dummy as no object there
007357  000689      oObjects[tAniButton] := oDipSwitchs ; // dummy as no object there
007358  000690      oObjects[tColorPicker] := oDipSwitchs ; // dummy as no object there
007359  000691      oObjects[tUserButton] := oDipSwitchs ; // dummy as no object there
007360  000692      hFonts[0] := FONT3 ;
007361  000693      hFonts[1] := FONT3 ;
007362  000694      hFonts[2] := FONT3 ;
007363  000695      hFonts[3] := FONT3 ;
007364  000696      hFonts[4] := FONT3 ;
007365  000697      hFonts[5] := FONT3 ;
007366  000698      hFonts[6] := FONT3 ;
007367  000699      hFonts[7] := FONT3 ;
007368  000700      hFonts[8] := FONT3 ;
007369  000701      hFonts[10] := FONT3 ;
007370  000702  // Start P4.inc
007371  000703      hstrings := file_Open("Prototip.txf", 'r') ; // Open handle to access uSD strings, uncomment if required
007372  000704      // init comms
007373  000705      com_Init(comRX,CMDLenMAX,0);
007374  000706      com_SetBaud(COM0,960);
007375  000707      com_TXbuffer(comTX, 100, 0);
007376  000708      // tag 'real' objects
007377  000709      for (i := 0; i <= MaxTotObjects; i++)
007378  000710          if (   (i != tSounds)
007379  000711              && (i != tTimer)
007380  000712              && (i != tPinOutput)
007381  000713              && (i != tPinInput) )
007382  000714              TouchXpos := oObjects[i] ;
007383  000715              TouchYpos := *(TouchXpos) ;
007384  000716              for (ImageTouched := 1; ImageTouched <= TouchYpos; ImageTouched++)
007385  000717                  oldn := *(TouchXpos+ImageTouched*2) ;
007386  000718                  img_SetAttributes(hndl, oldn, I_TOUCH_DISABLE);  // ensure touch is enabled
007387  000719                  if (oldn != -1)
007388  000720                      img_SetWord(hndl, oldn, IMAGE_TAG, i+1);
007389  000721                      img_Disable(hndl, oldn) ;
007390  000722                  endif
007391  000723              next
007392  000724          endif
007393  000725      next
007394  000726        
007395  000727      // display initial form
007396  000728      CurrentForm := -1 ;
007397  000729  // End P4.inc
007398  000730  // Start P5.inc
007399  000731      ActivateForm(0) ; // need to change this according to first actual form
007400  000732        
007401  000733  // End P5.inc
007402  000734  // Start P6.inc Picaso
007403  000735      touch_Set(TOUCH_ENABLE);                            // enable the touch screen
007404  000736      oldn := -1 ;
007405  000737      repeat
007406  000738        
007407  000739          // check comms for command, how to NAK invalid command
007408  000740          if (com_Count() != 0)
007409  000741              i := serin() ;
007410  000742              InputCS ^= i ;               // update checksum
007411  000743              if (   (cmdi > 2)
007412  000744                  && (cmd[0] == WRITE_STRU) )
007413  000745                  j := (cmdi-1) >> 1 + 2 ;
007414  000746                  if (j == CMDLenMAX)    // max length exceeded
007415  000747                      nak0() ;
007416  000748                      cmdi := -1 ;
007417  000749                  else if (cmdi & 1)
007418  000750                      cmd[j] := i ;
007419  000751                      if (cmd[2] == 0)    // if string complete
007420  000752                          if (InputCS)
007421  000753                              nak0() ;
007422  000754                          else
007423  000755                              if (cmd[0] == WRITE_STRU)
007424  000756                              cmd[j] := 0 ;                     // terminate it
007425  000757                              PrintStrings(cmd[1], &cmd[3], 1) ;
007426  000758                              serout(ACK) ;
007427  000759                              else
007428  000760                              endif
007429  000761                          endif
007430  000762                          cmdi := -1 ;
007431  000763                      endif
007432  000764                  else
007433  000765                      cmd[j] := cmd[j] << 8 + i ;
007434  000766                      cmd[2]-- ;          // dec length
007435  000767                  endif
007436  000768                  cmdi++ ;
007437  000769              else // not unicode string
007438  000770                  cmd[cmdi++] := i ;
007439  000771                   if (cmd[0] == WRITE_STR)                  // Ansi String
007440  000772                      if (cmdi == CMDLenMAX)      // max length exceeded
007441  000773                          nak0() ;
007442  000774                          cmdi := 0 ;
007443  000775                      else if (cmdi > 2)
007444  000776                          if (cmd[2] == -1)
007445  000777                              if (InputCS)
007446  000778                                  nak0() ;
007447  000779                              else
007448  000780                                  if (cmd[0] == WRITE_STR)
007449  000781                                  cmd[cmdi-1] := 0 ;                     // terminate it
007450  000782                                  PrintStrings(cmd[1], &cmd[3], 1) ;
007451  000783                                  serout(ACK) ;
007452  000784                                  else
007453  000785                                  endif
007454  000786                              endif
007455  000787                              cmdi := 0 ;
007456  000788                          else
007457  000789                              cmd[2]-- ;          // dec length
007458  000790                          endif
007459  000791                      endif
007460  000792                  else if (   (cmd[0] == READ_OBJ)
007461  000793                           && (cmdi == 4)         )
007462  000794                      if (InputCS)
007463  000795                          nak0() ;
007464  000796                      else
007465  000797                          ReadObject(cmd[1], cmd[2]) ;
007466  000798                      endif
007467  000799                      cmdi := 0 ;
007468  000800                  else if (   (cmd[0] == WRITE_OBJ)    // 6 byte write command (gen option)
007469  000801                           && (cmdi == 6)          )
007470  000802                      if (InputCS)
007471  000803                          nak0() ;
007472  000804                      else
007473  000805                          WriteObject(cmd[1], cmd[2], cmd[3] << 8 + cmd[4]) ;
007474  000806                          serout(ACK) ;
007475  000807                      endif
007476  000808                      cmdi := 0 ;
007477  000809                  else if (   (cmd[0] == WRITE_CONTRAST)
007478  000810                           && (cmdi == 3)         )
007479  000811                      if (InputCS)
007480  000812                          nak0() ;
007481  000813                      else
007482  000814                          gfx_Contrast(cmd[1]) ;
007483  000815                          serout(ACK) ;
007484  000816                      endif
007485  000817                      cmdi := 0 ;
007486  000818                  else if (cmdi == 6)    // we have 6 bytes and we've gotten here -> something wrong
007487  000819                      nak0() ;
007488  000820                      cmdi := 0 ;
007489  000821                  endif
007490  000822              endif   // not unicode string
007491  000823          endif   // a character is available
007492  000824        
007493  000825        
007494  000826      // touch code processing
007495  000827        
007496  000828          TouchStatus := touch_Get(TOUCH_STATUS);               // get touchscreen status
007497  000829          ImageTouched := img_Touched(hndl,-1) ;
007498  000830          if ((TouchStatus == TOUCH_PRESSED) || (TouchStatus == TOUCH_RELEASED) || (TouchStatus == TOUCH_MOVING))
007499  000831              if ((TouchStatus != TOUCH_RELEASED) && (ImageTouched != oldn) && (oldn != -1))
007500  000832                  TouchStatus := TOUCH_RELEASED ;       // simulate release if we move off object
007501  000833              endif
007502  000834              if (TouchStatus != TOUCH_RELEASED)        // if not released
007503  000835                  if (oldn != -1)
007504  000836                      ImageTouched := oldn ;
007505  000837                  else
007506  000838                      if (oldn != ImageTouched)
007507  000839                  oldn := ImageTouched ;
007508  000840                          TouchStatus := TOUCH_PRESSED ;
007509  000841                      endif
007510  000842                  endif
007511  000843                  TouchXpos  := touch_Get(TOUCH_GETX);
007512  000844                  TouchYpos  := touch_Get(TOUCH_GETY);
007513  000845                  TouchState := Ofs_IPD_DOWN ;
007514  000846              else
007515  000847                  ImageTouched := oldn ;                     // simulate release of what we touched
007516  000848                  oldn := -1 ;                    // prevent double release
007517  000849                  TouchState := Ofs_IPD_RELEASE ;
007518  000850              endif
007519  000851              if (ImageTouched != -1)
007520  000852                          CurInputData := InputControls[ImageTouched] + InputData;
007521  000853                          GObjectType := *(CurInputData) ;
007522  000854                          i := GObjectType ;
007523  000855                          if (GObjectType >= t4Dbutton) i -= 23 ; // adjust to ensure next in gosub
007524  000856                          gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
007525  000857              endif
007526  000858          endif
007527  000859   //       if ((n != -1) && (oldn == -1)) oldn := n ;    // save what we touched in case we move off it
007528  000860        
007529  000861          sys_EventsResume() ;
007530  000862      forever
007531  000863        
007532  000864  cDipswitch:
007533  000865        
007534  000866  cKnob:
007535  000867        
007536  000868  cRockerswitch:
007537  000869        
007538  000870  cRotaryswitch:
007539  000871        
007540  000872  cSlider:
007541  000873  cTrackbar:
007542  000874        
007543  000875  c4DButton:
007544  000876  cUserButton:
007545  000877  cWinbutton:
007546  000878      pInputIndex := oWinButtons + *(CurInputData+Ofs_IPD_OBJVIDX) ;
007547  000879  gbutton:
007548  000880      i := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ; // current state
007549  000881      if (*(CurInputData+Ofs_IPD_P1))                                 // momentary, reports 0, but should report 1
007550  000882          if (TouchStatus == TOUCH_RELEASED)
007551  000883              i &= 0xfffe ;
007552  000884              TouchState == Ofs_IPD_DOWN ;
007553  000885          else
007554  000886              i |= 1 ;
007555  000887              TouchState == Ofs_IPD_RELEASE ;
007556  000888          endif
007557  000889      else if (*(CurInputData+Ofs_IPD_P2) == -1)                      // Toggle, reports 0+2, but should report 0+1
007558  000890          if (TouchStatus == TOUCH_RELEASED)                     // only truly change on release
007559  000891              if ((i & 3) == 3)
007560  000892                  i &= 0xfffc ;
007561  000893              else
007562  000894                  i++ ;
007563  000895              endif
007564  000896          else
007565  000897              i |= 1 ;                                      // make down regardless of current state
007566  000898          endif
007567  000899      else                        // group action, up all other buttons on touch press, reports 0 for button down
007568  000900          if (TouchStatus == TOUCH_PRESSED)                     // only truly change on release
007569  000901              TurnOffButtons(*(CurInputData+Ofs_IPD_P2)) ;
007570  000902          endif
007571  000903          i := (i & 0xfffc) | 2 ;
007572  000904      endif
007573  000905        
007574  000906      UpdateObjects(i) ;
007575  000907  endsub ;
007576  000908        
007577  000909  cAniButton:
007578  000910        
007579  000911  cColorPicker:
007580  000912        
007581  000913  endfunc
007582  000914  // End P6.inc
Notice: Check that the function called via pointer  'IPidx' requires 1 argument (line 521 file:Prototip.4DGenieS)
Notice: local var 'p' in func 'ActivateForm' is never used (line 457 file:Prototip.4DGenieS)


Symbol Table:
name                             decimal         hex
_1F                                  -40  0xffffffd8 (PmmC func) args[0] r=0  (not used)
__MAXMEM                           14400  0x00003840 (const dword)  (usage 1)
__MAXPROG                          14400  0x00003840 (const dword)  (usage 1)
__PLATFORM                             1  0x00000001 (const dword)  (not used)
ABS                                  -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
ACK                                    6  0x00000006 (const dword)  (usage 12)
ActivateForm                        7020  0x00001b6c (User func) args[1] r=0  (usage 9)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AUDIO_ENABLE                           7  0x00000007 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (usage 3)
BACKLITE                               6  0x00000006 (const dword)  (not used)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (usage 63)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
BUS_0                                  8  0x00000008 (const dword)  (not used)
BUS_1                                  9  0x00000009 (const dword)  (not used)
BUS_2                                 10  0x0000000a (const dword)  (not used)
BUS_3                                 11  0x0000000b (const dword)  (not used)
BUS_4                                 12  0x0000000c (const dword)  (not used)
BUS_5                                 13  0x0000000d (const dword)  (not used)
BUS_6                                 14  0x0000000e (const dword)  (not used)
BUS_7                                 15  0x0000000f (const dword)  (not used)
bus_In                               -45  0xffffffd3 (PmmC func) args[0] r=1  (not used)
bus_Out                              -46  0xffffffd2 (PmmC func) args[1] r=0  (not used)
BUS_RD_PIN                             4  0x00000004 (const dword)  (not used)
bus_Read                             -49  0xffffffcf (PmmC func) args[0] r=1  (not used)
bus_Set                              -47  0xffffffd1 (PmmC func) args[1] r=0  (not used)
BUS_WR_PIN                             5  0x00000005 (const dword)  (not used)
bus_Write                            -48  0xffffffd0 (PmmC func) args[1] r=0  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                            -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
c4DButton                         UNRESOLVED  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
cAniButton                        UNRESOLVED  (not used)
cColorPicker                      UNRESOLVED  (not used)
cDipswitch                        UNRESOLVED  (not used)
charheight                          -159  0xffffff61 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                           -158  0xffffff62 (PmmC func) args[1] r=1  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
CKMODE_0                               0  0x00000000 (const dword)  (not used)
CKMODE_1                               1  0x00000001 (const dword)  (not used)
CKMODE_2                               2  0x00000002 (const dword)  (not used)
CKMODE_3                               3  0x00000003 (const dword)  (not used)
cKnob                             UNRESOLVED  (not used)
CLIPPING                              19  0x00000013 (const dword)  (not used)
cmd                                  214  0x000000d6 (mem) word[80] (global)  (usage 84)
CMDLenMAX                             80  0x00000050 (const dword)  (usage 12)
ColorBGimage                          32  0x00000020 (const dword)  (usage 9)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COLOUR_MODE                           27  0x0000001b (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (usage 3)
COM1                               63496  0x0000f808 (const dword)  (not used)
com1_Count                          -132  0xffffff7c (PmmC func) args[0] r=1  (not used)
com1_Error                          -134  0xffffff7a (PmmC func) args[0] r=1  (not used)
com1_Full                           -133  0xffffff7b (PmmC func) args[0] r=1  (not used)
com1_Init                           -130  0xffffff7e (PmmC func) args[3] r=0  (not used)
com1_Reset                          -131  0xffffff7d (PmmC func) args[0] r=0  (not used)
com1_Sync                           -135  0xffffff79 (PmmC func) args[0] r=1  (not used)
com1_TXbuffer                       -136  0xffffff78 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -139  0xffffff75 (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -137  0xffffff77 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -138  0xffffff76 (PmmC func) args[1] r=1  (not used)
com_Count                           -122  0xffffff86 (PmmC func) args[0] r=1  (usage 3)
com_Error                           -124  0xffffff84 (PmmC func) args[0] r=1  (not used)
com_Full                            -123  0xffffff85 (PmmC func) args[0] r=1  (not used)
com_Init                            -120  0xffffff88 (PmmC func) args[3] r=0  (usage 3)
com_Reset                           -121  0xffffff87 (PmmC func) args[0] r=0  (not used)
com_SetBaud                         -142  0xffffff72 (PmmC func) args[2] r=1  (usage 3)
com_Sync                            -125  0xffffff83 (PmmC func) args[0] r=1  (not used)
com_TXbuffer                        -126  0xffffff82 (PmmC func) args[3] r=0  (usage 3)
com_TXbufferHold                    -129  0xffffff7f (PmmC func) args[1] r=1  (not used)
com_TXcount                         -127  0xffffff81 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -128  0xffffff80 (PmmC func) args[1] r=1  (not used)
comRX                                134  0x00000086 (mem) word[40] (global)  (usage 3)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -18  0xffffffee (PmmC func) args[1] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
cRockerswitch                     UNRESOLVED  (not used)
cRotaryswitch                     UNRESOLVED  (not used)
cSlider                           UNRESOLVED  (not used)
cTrackbar                         UNRESOLVED  (not used)
CurInputData                         130  0x00000082 (mem) word (global)  (usage 24)
CurrentForm                          116  0x00000074 (mem) word (global)  (usage 45)
cUserButton                       UNRESOLVED  (not used)
cWinbutton                        UNRESOLVED  (not used)
CY                                  -285  0xfffffee3 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_Disconnect                     -293  0xfffffedb (PmmC func) args[0] r=0  (not used)
disp_Init                           -143  0xffffff71 (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -149  0xffffff6b (PmmC func) args[0] r=1  (not used)
disp_setGRAM                        -145  0xffffff6f (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -144  0xffffff70 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -284  0xfffffee4 (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -147  0xffffff6d (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -148  0xffffff6c (PmmC func) args[1] r=0  (not used)
DISPLAY_PAGE                          33  0x00000021 (const dword)  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DoGFXObjects                        5711  0x0000164f (User func) args[0] r=0  (usage 6)
DOWN                                   0  0x00000000 (const dword)  (not used)
DSK                                63490  0x0000f802 (const dword)  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                              -282  0xfffffee6 (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                           -283  0xfffffee5 (PmmC func) args[0] r=1  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FILE_TIMEOUT                       26  0x0000001a (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_Close                          -232  0xffffff18 (PmmC func) args[1] r=1  (not used)
file_Count                          -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -247  0xffffff09 (PmmC func) args[1] r=1  (not used)
file_Error                          -225  0xffffff1f (PmmC func) args[0] r=1  (not used)
file_Exec                           -251  0xffffff05 (PmmC func) args[2] r=1  (not used)
file_Exists                         -230  0xffffff1a (PmmC func) args[1] r=1  (not used)
file_FindFirst                      -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
file_FindNext                       -229  0xffffff1b (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -242  0xffffff0e (PmmC func) args[1] r=1  (usage 3)
file_GetS                           -246  0xffffff0a (PmmC func) args[3] r=1  (not used)
file_GetW                           -244  0xffffff0c (PmmC func) args[1] r=1  (usage 3)
file_Image                          -239  0xffffff11 (PmmC func) args[3] r=1  (not used)
file_Index                          -235  0xffffff15 (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -249  0xffffff07 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -252  0xffffff04 (PmmC func) args[3] r=1  (usage 3)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -253  0xffffff03 (PmmC func) args[0] r=1  (usage 6)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -231  0xffffff19 (PmmC func) args[2] r=1  (usage 3)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -255  0xffffff01 (PmmC func) args[1] r=1  (not used)
file_PutC                           -241  0xffffff0f (PmmC func) args[2] r=1  (not used)
file_PutS                           -245  0xffffff0b (PmmC func) args[2] r=1  (not used)
file_PutW                           -243  0xffffff0d (PmmC func) args[2] r=1  (not used)
file_Read                           -233  0xffffff17 (PmmC func) args[3] r=1  (not used)
file_Rewind                         -248  0xffffff08 (PmmC func) args[1] r=1  (not used)
file_Run                            -250  0xffffff06 (PmmC func) args[2] r=1  (not used)
file_ScreenCapture                  -240  0xffffff10 (PmmC func) args[5] r=1  (not used)
file_Seek                           -234  0xffffff16 (PmmC func) args[3] r=1  (usage 3)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_Size                           -238  0xffffff12 (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -236  0xffffff14 (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -254  0xffffff02 (PmmC func) args[0] r=0  (not used)
file_Write                          -237  0xffffff13 (PmmC func) args[3] r=1  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
flash_BlockErase                    -157  0xffffff63 (PmmC func) args[1] r=1  (not used)
flash_BulkErase                     -156  0xffffff64 (PmmC func) args[0] r=0  (not used)
flash_ID                            -155  0xffffff65 (PmmC func) args[0] r=1  (not used)
flash_SIG                           -154  0xffffff66 (PmmC func) args[0] r=1  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
FONT1                                  0  0x00000000 (const dword)  (not used)
FONT2                                  1  0x00000001 (const dword)  (not used)
FONT3                                  2  0x00000002 (const dword)  (usage 30)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FormBGcolors                        3497  0x00000da9FormBGcolors                        3497  0x00000da9 (mem) word[17] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 8)
FormBGcolors                      UNRESOLVED  (usage 4)
FormEndIndex                          41  0x00000029FormEndIndex                          41  0x00000029 (mem) word[17] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 6)
FormStartIndex                         7  0x00000007FormStartIndex                         7  0x00000007 (mem) word[17] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 7)
FormStartIndex                    UNRESOLVED  (usage 2)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS    2806  0x00000af6 (const ??? 0)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                         -85  0xffffffab (PmmC func) args[1] r=1  (not used)
gfx_BevelShadow                     -104  0xffffff98 (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -103  0xffffff99 (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                         -92  0xffffffa4 (PmmC func) args[1] r=1  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                            -74  0xffffffb6 (PmmC func) args[2] r=0  (not used)
gfx_Bullet                           -71  0xffffffb9 (PmmC func) args[1] r=0  (not used)
gfx_Button                           -80  0xffffffb0 (PmmC func) args[9] r=0  (not used)
GFX_BUTTON_BACKGROUND                 64  0x00000040 (const dword)  (not used)
GFX_BUTTON_FOREGROUND                 63  0x0000003f (const dword)  (not used)
GFX_BUTTON_MODE                       65  0x00000041 (const dword)  (not used)
gfx_ChangeColour                     -76  0xffffffb4 (PmmC func) args[2] r=0  (not used)
gfx_Circle                           -61  0xffffffc3 (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                     -62  0xffffffc2 (PmmC func) args[4] r=0  (not used)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                         -94  0xffffffa2 (PmmC func) args[1] r=0  (usage 6)
gfx_ClipWindow                       -75  0xffffffb5 (PmmC func) args[4] r=0  (usage 3)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 6)
gfx_ColourMode                      -102  0xffffff9a (PmmC func) args[1] r=1  (not used)
gfx_Contrast                        -100  0xffffff9c (PmmC func) args[1] r=1  (usage 3)
gfx_Dot                              -70  0xffffffba (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                          -78  0xffffffb2 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                    -79  0xffffffb1 (PmmC func) args[5] r=0  (not used)
gfx_FrameDelay                       -97  0xffffff9f (PmmC func) args[1] r=1  (not used)
gfx_Get                              -90  0xffffffa6 (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                         -64  0xffffffc0 (PmmC func) args[2] r=1  (not used)
GFX_HILIGHT_BACKGROUND                61  0x0000003d (const dword)  (not used)
GFX_HILIGHT_FOREGROUND                62  0x0000003e (const dword)  (not used)
GFX_HILITE_LINE                       58  0x0000003a (const dword)  (not used)
gfx_Hline                            -57  0xffffffc7 (PmmC func) args[4] r=1  (not used)
gfx_IncX                             -72  0xffffffb8 (PmmC func) args[0] r=1  (not used)
gfx_IncY                             -73  0xffffffb7 (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_SELECTION                    60  0x0000003c (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
GFX_LEFT_GUTTER_WIDTH                 68  0x00000044 (const dword)  (not used)
gfx_Line                             -56  0xffffffc8 (PmmC func) args[5] r=0  (not used)
GFX_LINE_COUNT                        59  0x0000003b (const dword)  (not used)
gfx_LinePattern                     -101  0xffffff9b (PmmC func) args[1] r=1  (usage 72)
gfx_LineRel                          -55  0xffffffc9 (PmmC func) args[2] r=0  (not used)
gfx_LineTo                           -54  0xffffffca (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                          -53  0xffffffcb (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (usage 3)
gfx_ObjectColour                     -93  0xffffffa3 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                            -67  0xffffffbd (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                        -66  0xffffffbe (PmmC func) args[2] r=0  (not used)
gfx_Origin                           -89  0xffffffa7 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                    -99  0xffffff9d (PmmC func) args[1] r=1  (usage 72)
gfx_Panel                            -81  0xffffffaf (PmmC func) args[6] r=0  (not used)
gfx_PenSize                          -91  0xffffffa5 (PmmC func) args[1] r=1  (not used)
GFX_PIXEL_SHIFT                       70  0x00000046 (const dword)  (not used)
gfx_Polygon                          -69  0xffffffbb (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                    -88  0xffffffa8 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                         -68  0xffffffbc (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                         -63  0xffffffc1 (PmmC func) args[3] r=0  (not used)
GFX_RECT_X1                           71  0x00000047 (const dword)  (not used)
GFX_RECT_X2                           73  0x00000049 (const dword)  (not used)
GFX_RECT_Y1                           72  0x00000048 (const dword)  (not used)
GFX_RECT_Y2                           74  0x0000004a (const dword)  (not used)
gfx_Rectangle                        -59  0xffffffc5 (PmmC func) args[5] r=0  (usage 36)
gfx_RectangleFilled                  -60  0xffffffc4 (PmmC func) args[5] r=0  (usage 6)
gfx_RGBto565                         -84  0xffffffac (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
GFX_RIGHT_GUTTER_WIDTH                69  0x00000045 (const dword)  (not used)
gfx_ScreenCopyPaste                  -83  0xffffffad (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                       -98  0xffffff9e (PmmC func) args[1] r=1  (usage 3)
gfx_Selection                        -86  0xffffffaa (PmmC func) args[3] r=0  (not used)
gfx_Set                              -50  0xffffffce (PmmC func) args[2] r=0  (usage 3)
gfx_SetClipRegion                    -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
gfx_Slider                           -82  0xffffffae (PmmC func) args[8] r=1  (not used)
GFX_STATUSBAR_HEIGHT                  67  0x00000043 (const dword)  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOOLBAR_HEIGHT                    66  0x00000042 (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                     -96  0xffffffa0 (PmmC func) args[1] r=1  (not used)
gfx_TransparentColour                -95  0xffffffa1 (PmmC func) args[1] r=1  (not used)
gfx_Triangle                         -65  0xffffffbf (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                   -87  0xffffffa9 (PmmC func) args[7] r=0  (not used)
gfx_Vline                            -58  0xffffffc6 (PmmC func) args[4] r=1  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -105  0xffffff97 (PmmC func) args[1] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -106  0xffffff96 (PmmC func) args[1] r=1  (not used)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GObjectType                          126  0x0000007e (mem) word (global)  (usage 24)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (not used)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
hFonts                                 2  0x00000002 (mem) word[11] (global)  (usage 33)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                              -214  0xffffff2a (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   0  0x00000000 (mem) word (global)  (usage 105)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
hstrings                              46  0x0000002e (mem) word (global)  (usage 12)
I2C                                63520  0x0000f820 (const dword)  (not used)
I2C_Ack                             -169  0xffffff57 (PmmC func) args[0] r=0  (not used)
I2C_AckPoll                         -172  0xffffff54 (PmmC func) args[1] r=1  (not used)
I2C_AckStatus                       -171  0xffffff55 (PmmC func) args[0] r=0  (not used)
I2C_Close                           -163  0xffffff5d (PmmC func) args[0] r=0  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_Getn                            -175  0xffffff51 (PmmC func) args[2] r=1  (not used)
I2C_Gets                            -174  0xffffff52 (PmmC func) args[2] r=1  (not used)
I2C_Idle                            -173  0xffffff53 (PmmC func) args[0] r=0  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_Nack                            -170  0xffffff56 (PmmC func) args[0] r=0  (not used)
I2C_Open                            -162  0xffffff5e (PmmC func) args[1] r=0  (not used)
I2C_Putn                            -177  0xffffff4f (PmmC func) args[2] r=1  (not used)
I2C_Puts                            -176  0xffffff50 (PmmC func) args[1] r=1  (not used)
I2C_Read                            -167  0xffffff59 (PmmC func) args[0] r=1  (not used)
I2C_Restart                         -166  0xffffff5a (PmmC func) args[0] r=1  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I2C_Start                           -164  0xffffff5c (PmmC func) args[0] r=1  (not used)
I2C_Stop                            -165  0xffffff5b (PmmC func) args[0] r=1  (not used)
I2C_Write                           -168  0xffffff58 (PmmC func) args[1] r=1  (not used)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (usage 6)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (usage 3)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (usage 6)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
IFONT_OFFSET                           0  0x00000000 (const dword)  (not used)
iiLeddigits0                          57  0x00000039 (const ??? 0)  (not used)
iiLeddigits1                          59  0x0000003b (const ??? 0)  (not used)
iiLeddigits10                         31  0x0000001f (const ??? 0)  (not used)
iiLeddigits11                         33  0x00000021 (const ??? 0)  (not used)
iiLeddigits12                         38  0x00000026 (const ??? 0)  (not used)
iiLeddigits13                        137  0x00000089 (const ??? 0)  (not used)
iiLeddigits14                        142  0x0000008e (const ??? 0)  (not used)
iiLeddigits15                        147  0x00000093 (const ??? 0)  (not used)
iiLeddigits16                        151  0x00000097 (const ??? 0)  (not used)
iiLeddigits17                        153  0x00000099 (const ??? 0)  (not used)
iiLeddigits18                        155  0x0000009b (const ??? 0)  (not used)
iiLeddigits19                        166  0x000000a6 (const ??? 0)  (not used)
iiLeddigits2                          79  0x0000004f (const ??? 0)  (not used)
iiLeddigits20                        171  0x000000ab (const ??? 0)  (not used)
iiLeddigits21                        176  0x000000b0 (const ??? 0)  (not used)
iiLeddigits22                        181  0x000000b5 (const ??? 0)  (not used)
iiLeddigits23                        183  0x000000b7 (const ??? 0)  (not used)
iiLeddigits24                        185  0x000000b9 (const ??? 0)  (not used)
iiLeddigits25                        194  0x000000c2 (const ??? 0)  (not used)
iiLeddigits26                        198  0x000000c6 (const ??? 0)  (not used)
iiLeddigits27                        201  0x000000c9 (const ??? 0)  (not used)
iiLeddigits28                        204  0x000000cc (const ??? 0)  (not used)
iiLeddigits29                        207  0x000000cf (const ??? 0)  (not used)
iiLeddigits3                          81  0x00000051 (const ??? 0)  (not used)
iiLeddigits30                        210  0x000000d2 (const ??? 0)  (not used)
iiLeddigits31                          8  0x00000008 (const ??? 0)  (not used)
iiLeddigits32                         10  0x0000000a (const ??? 0)  (not used)
iiLeddigits33                         12  0x0000000c (const ??? 0)  (not used)
iiLeddigits34                         46  0x0000002e (const ??? 0)  (not used)
iiLeddigits35                         48  0x00000030 (const ??? 0)  (not used)
iiLeddigits36                         50  0x00000032 (const ??? 0)  (not used)
iiLeddigits37                         21  0x00000015 (const ??? 0)  (not used)
iiLeddigits38                         23  0x00000017 (const ??? 0)  (not used)
iiLeddigits39                         25  0x00000019 (const ??? 0)  (not used)
iiLeddigits4                          69  0x00000045 (const ??? 0)  (not used)
iiLeddigits5                          71  0x00000047 (const ??? 0)  (not used)
iiLeddigits6                          73  0x00000049 (const ??? 0)  (not used)
iiLeddigits7                          64  0x00000040 (const ??? 0)  (not used)
iiLeddigits8                          27  0x0000001b (const ??? 0)  (not used)
iiLeddigits9                          29  0x0000001d (const ??? 0)  (not used)
iImage0                              117  0x00000075 (const ??? 0)  (usage 3)
iImage1                              126  0x0000007e (const ??? 0)  (usage 3)
iImage2                              132  0x00000084 (const ??? 0)  (usage 3)
iLeddigits0                           56  0x00000038 (const ??? 0)  (usage 3)
iLeddigits1                           58  0x0000003a (const ??? 0)  (usage 3)
iLeddigits10                          30  0x0000001e (const ??? 0)  (usage 3)
iLeddigits11                          32  0x00000020 (const ??? 0)  (usage 3)
iLeddigits12                          37  0x00000025 (const ??? 0)  (usage 3)
iLeddigits13                         136  0x00000088 (const ??? 0)  (usage 3)
iLeddigits14                         141  0x0000008d (const ??? 0)  (usage 3)
iLeddigits15                         146  0x00000092 (const ??? 0)  (usage 3)
iLeddigits16                         150  0x00000096 (const ??? 0)  (usage 3)
iLeddigits17                         152  0x00000098 (const ??? 0)  (usage 3)
iLeddigits18                         154  0x0000009a (const ??? 0)  (usage 3)
iLeddigits19                         165  0x000000a5 (const ??? 0)  (usage 3)
iLeddigits2                           78  0x0000004e (const ??? 0)  (usage 3)
iLeddigits20                         170  0x000000aa (const ??? 0)  (usage 3)
iLeddigits21                         175  0x000000af (const ??? 0)  (usage 3)
iLeddigits22                         180  0x000000b4 (const ??? 0)  (usage 3)
iLeddigits23                         182  0x000000b6 (const ??? 0)  (usage 3)
iLeddigits24                         184  0x000000b8 (const ??? 0)  (usage 3)
iLeddigits25                         193  0x000000c1 (const ??? 0)  (usage 3)
iLeddigits26                         197  0x000000c5 (const ??? 0)  (usage 3)
iLeddigits27                         200  0x000000c8 (const ??? 0)  (usage 3)
iLeddigits28                         203  0x000000cb (const ??? 0)  (usage 3)
iLeddigits29                         206  0x000000ce (const ??? 0)  (usage 3)
iLeddigits3                           80  0x00000050 (const ??? 0)  (usage 3)
iLeddigits30                         209  0x000000d1 (const ??? 0)  (usage 3)
iLeddigits31                           7  0x00000007 (const ??? 0)  (usage 3)
iLeddigits32                           9  0x00000009 (const ??? 0)  (usage 3)
iLeddigits33                          11  0x0000000b (const ??? 0)  (usage 3)
iLeddigits34                          45  0x0000002d (const ??? 0)  (usage 3)
iLeddigits35                          47  0x0000002f (const ??? 0)  (usage 3)
iLeddigits36                          49  0x00000031 (const ??? 0)  (usage 3)
iLeddigits37                          20  0x00000014 (const ??? 0)  (usage 3)
iLeddigits38                          22  0x00000016 (const ??? 0)  (usage 3)
iLeddigits39                          24  0x00000018 (const ??? 0)  (usage 3)
iLeddigits4                           68  0x00000044 (const ??? 0)  (usage 3)
iLeddigits5                           70  0x00000046 (const ??? 0)  (usage 3)
iLeddigits6                           72  0x00000048 (const ??? 0)  (usage 3)
iLeddigits7                           63  0x0000003f (const ??? 0)  (usage 3)
iLeddigits8                           26  0x0000001a (const ??? 0)  (usage 3)
iLeddigits9                           28  0x0000001c (const ??? 0)  (usage 3)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (usage 3)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (not used)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 42)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (usage 9)
IMAGE_TAG2                            13  0x0000000d (const dword)  (usage 9)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (not used)
IMAGE_XPOS                             2  0x00000002 (const dword)  (usage 3)
IMAGE_YPOS                             3  0x00000003 (const dword)  (not used)
ImageTouched                         120  0x00000078 (mem) word (global)  (usage 36)
img_ClearAttributes                 -187  0xffffff45 (PmmC func) args[3] r=1  (usage 3)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -181  0xffffff4b (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -180  0xffffff4c (PmmC func) args[2] r=1  (usage 6)
img_Enable                          -179  0xffffff4d (PmmC func) args[2] r=1  (not used)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -184  0xffffff48 (PmmC func) args[3] r=1  (usage 45)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -182  0xffffff4a (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SetAttributes                   -186  0xffffff46 (PmmC func) args[3] r=1  (usage 6)
img_SetPosition                     -178  0xffffff4e (PmmC func) args[4] r=1  (not used)
img_SetWord                         -183  0xffffff49 (PmmC func) args[4] r=1  (usage 21)
img_Show                            -185  0xffffff47 (PmmC func) args[2] r=1  (usage 18)
img_Touched                         -188  0xffffff44 (PmmC func) args[2] r=1  (usage 3)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
INPUT                                  1  0x00000001 (const dword)  (not used)
InputControls                         75  0x0000004bInputControls                         75  0x0000004b (mem) word[219] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 6)
InputCS                              374  0x00000176 (mem) word (global)  (usage 21)
InputData                            513  0x00000201InputData                            513  0x00000201 (mem) word[1144] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 24)
INVERSE                               64  0x00000040 (const dword)  (not used)
IO1_PIN                                1  0x00000001 (const dword)  (not used)
IO2_PIN                                2  0x00000002 (const dword)  (not used)
IO3_PIN                                3  0x00000003 (const dword)  (not used)
IO4_PIN                                4  0x00000004 (const dword)  (not used)
IO5_PIN                                5  0x00000005 (const dword)  (not used)
IPDatasize                            22  0x00000016 (const dword)  (usage 3)
isalnum                             -207  0xffffff31 (PmmC func) args[1] r=1  (not used)
isalpha                             -206  0xffffff32 (PmmC func) args[1] r=1  (not used)
isdigit                             -202  0xffffff36 (PmmC func) args[1] r=1  (not used)
islower                             -205  0xffffff33 (PmmC func) args[1] r=1  (not used)
isprint                             -208  0xffffff30 (PmmC func) args[1] r=1  (not used)
isspace                             -209  0xffffff2f (PmmC func) args[1] r=1  (not used)
iStatictext0                          19  0x00000013 (const ??? 0)  (usage 3)
iStatictext10                         94  0x0000005e (const ??? 0)  (usage 3)
iStatictext11                         95  0x0000005f (const ??? 0)  (usage 3)
iStatictext12                         96  0x00000060 (const ??? 0)  (usage 3)
iStatictext13                          4  0x00000004 (const ??? 0)  (usage 3)
iStatictext14                          5  0x00000005 (const ??? 0)  (usage 3)
iStatictext15                         83  0x00000053 (const ??? 0)  (usage 3)
iStatictext16                         66  0x00000042 (const ??? 0)  (usage 3)
iStatictext17                         60  0x0000003c (const ??? 0)  (usage 3)
iStatictext18                         61  0x0000003d (const ??? 0)  (usage 3)
iStatictext19                         62  0x0000003e (const ??? 0)  (usage 3)
iStatictext20                         74  0x0000004a (const ??? 0)  (usage 3)
iStatictext21                         75  0x0000004b (const ??? 0)  (usage 3)
iStatictext22                         76  0x0000004c (const ??? 0)  (usage 3)
iStatictext23                         77  0x0000004d (const ??? 0)  (usage 3)
iStatictext24                         84  0x00000054 (const ??? 0)  (usage 3)
iStatictext25                         85  0x00000055 (const ??? 0)  (usage 3)
iStatictext26                         86  0x00000056 (const ??? 0)  (usage 3)
iStatictext27                         65  0x00000041 (const ??? 0)  (usage 3)
iStatictext28                         40  0x00000028 (const ??? 0)  (usage 3)
iStatictext29                         41  0x00000029 (const ??? 0)  (usage 3)
iStatictext3                          55  0x00000037 (const ??? 0)  (usage 3)
iStatictext30                         35  0x00000023 (const ??? 0)  (usage 3)
iStatictext31                         36  0x00000024 (const ??? 0)  (usage 3)
iStatictext32                         39  0x00000027 (const ??? 0)  (usage 3)
iStatictext33                        213  0x000000d5 (const ??? 0)  (usage 3)
iStatictext34                         42  0x0000002a (const ??? 0)  (usage 3)
iStatictext35                         43  0x0000002b (const ??? 0)  (usage 3)
iStatictext36                         44  0x0000002c (const ??? 0)  (usage 3)
iStatictext37                         98  0x00000062 (const ??? 0)  (usage 3)
iStatictext38                         99  0x00000063 (const ??? 0)  (usage 3)
iStatictext39                        100  0x00000064 (const ??? 0)  (usage 3)
iStatictext4                           1  0x00000001 (const ??? 0)  (usage 3)
iStatictext40                        101  0x00000065 (const ??? 0)  (usage 3)
iStatictext41                        102  0x00000066 (const ??? 0)  (usage 3)
iStatictext42                        111  0x0000006f (const ??? 0)  (usage 3)
iStatictext43                        112  0x00000070 (const ??? 0)  (usage 3)
iStatictext44                        113  0x00000071 (const ??? 0)  (usage 3)
iStatictext45                        114  0x00000072 (const ??? 0)  (usage 3)
iStatictext46                        115  0x00000073 (const ??? 0)  (usage 3)
iStatictext47                        116  0x00000074 (const ??? 0)  (usage 3)
iStatictext48                        120  0x00000078 (const ??? 0)  (usage 3)
iStatictext49                        123  0x0000007b (const ??? 0)  (usage 3)
iStatictext5                          87  0x00000057 (const ??? 0)  (usage 3)
iStatictext50                        124  0x0000007c (const ??? 0)  (usage 3)
iStatictext51                        125  0x0000007d (const ??? 0)  (usage 3)
iStatictext52                        127  0x0000007f (const ??? 0)  (usage 3)
iStatictext53                        130  0x00000082 (const ??? 0)  (usage 3)
iStatictext54                        131  0x00000083 (const ??? 0)  (usage 3)
iStatictext55                        133  0x00000085 (const ??? 0)  (usage 3)
iStatictext56                        139  0x0000008b (const ??? 0)  (usage 3)
iStatictext57                        140  0x0000008c (const ??? 0)  (usage 3)
iStatictext58                        145  0x00000091 (const ??? 0)  (usage 3)
iStatictext59                        156  0x0000009c (const ??? 0)  (usage 3)
iStatictext6                          90  0x0000005a (const ??? 0)  (usage 3)
iStatictext60                        157  0x0000009d (const ??? 0)  (usage 3)
iStatictext61                        158  0x0000009e (const ??? 0)  (usage 3)
iStatictext62                        159  0x0000009f (const ??? 0)  (usage 3)
iStatictext63                        162  0x000000a2 (const ??? 0)  (usage 3)
iStatictext64                        164  0x000000a4 (const ??? 0)  (usage 3)
iStatictext65                        169  0x000000a9 (const ??? 0)  (usage 3)
iStatictext66                        174  0x000000ae (const ??? 0)  (usage 3)
iStatictext67                        179  0x000000b3 (const ??? 0)  (usage 3)
iStatictext68                        186  0x000000ba (const ??? 0)  (usage 3)
iStatictext69                        187  0x000000bb (const ??? 0)  (usage 3)
iStatictext7                          88  0x00000058 (const ??? 0)  (usage 3)
iStatictext70                        188  0x000000bc (const ??? 0)  (usage 3)
iStatictext71                        191  0x000000bf (const ??? 0)  (usage 3)
iStatictext72                        195  0x000000c3 (const ??? 0)  (usage 3)
iStatictext73                        196  0x000000c4 (const ??? 0)  (usage 3)
iStatictext74                        199  0x000000c7 (const ??? 0)  (usage 3)
iStatictext75                        202  0x000000ca (const ??? 0)  (usage 3)
iStatictext76                        205  0x000000cd (const ??? 0)  (usage 3)
iStatictext77                        208  0x000000d0 (const ??? 0)  (usage 3)
iStatictext78                        110  0x0000006e (const ??? 0)  (usage 3)
iStatictext79                         51  0x00000033 (const ??? 0)  (usage 3)
iStatictext8                          91  0x0000005b (const ??? 0)  (usage 3)
iStatictext80                        214  0x000000d6 (const ??? 0)  (usage 3)
iStatictext81                        215  0x000000d7 (const ??? 0)  (usage 3)
iStatictext82                        216  0x000000d8 (const ??? 0)  (usage 3)
iStatictext9                          92  0x0000005c (const ??? 0)  (usage 3)
iStrings0                           2801  0x00000af1iStrings0                           2801  0x00000af1 (mem) word[13] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 3)
iStrings1                           2827  0x00000b0biStrings1                           2827  0x00000b0b (mem) word[13] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 3)
iStrings10                          3035  0x00000bdbiStrings10                          3035  0x00000bdb (mem) word[13] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 3)
iStrings2                           2853  0x00000b25iStrings2                           2853  0x00000b25 (mem) word[13] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 3)
iStrings3                           2879  0x00000b3fiStrings3                           2879  0x00000b3f (mem) word[13] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 3)
iStrings4                           2905  0x00000b59iStrings4                           2905  0x00000b59 (mem) word[13] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 3)
iStrings5                           2931  0x00000b73iStrings5                           2931  0x00000b73 (mem) word[13] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 3)
iStrings6                           2957  0x00000b8diStrings6                           2957  0x00000b8d (mem) word[13] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 3)
iStrings7                           2983  0x00000ba7iStrings7                           2983  0x00000ba7 (mem) word[13] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 3)
iStrings8                           3009  0x00000bc1iStrings8                           3009  0x00000bc1 (mem) word[13] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 3)
isupper                             -204  0xffffff34 (PmmC func) args[1] r=1  (not used)
iswhite                             -210  0xffffff2e (PmmC func) args[1] r=1  (not used)
isxdigit                            -203  0xffffff35 (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -198  0xffffff3a (PmmC func) args[1] r=0  (not used)
iUserled0                            107  0x0000006b (const ??? 0)  (usage 3)
iUserled1                            108  0x0000006c (const ??? 0)  (usage 3)
iUserled2                            109  0x0000006d (const ??? 0)  (usage 3)
IVORY                              65534  0x0000fffe (const dword)  (not used)
iWinbutton0                            0  0x00000000 (const ??? 0)  (usage 3)
iWinbutton1                           13  0x0000000d (const ??? 0)  (usage 3)
iWinbutton10                          97  0x00000061 (const ??? 0)  (usage 3)
iWinbutton11                          34  0x00000022 (const ??? 0)  (usage 3)
iWinbutton12                          67  0x00000043 (const ??? 0)  (usage 3)
iWinbutton13                          17  0x00000011 (const ??? 0)  (usage 3)
iWinbutton14                         103  0x00000067 (const ??? 0)  (usage 3)
iWinbutton15                         104  0x00000068 (const ??? 0)  (usage 3)
iWinbutton16                         105  0x00000069 (const ??? 0)  (usage 3)
iWinbutton17                         106  0x0000006a (const ??? 0)  (usage 3)
iWinbutton18                           6  0x00000006 (const ??? 0)  (usage 3)
iWinbutton19                         118  0x00000076 (const ??? 0)  (usage 3)
iWinbutton2                           14  0x0000000e (const ??? 0)  (usage 3)
iWinbutton20                         119  0x00000077 (const ??? 0)  (usage 3)
iWinbutton21                         121  0x00000079 (const ??? 0)  (usage 3)
iWinbutton22                         122  0x0000007a (const ??? 0)  (usage 3)
iWinbutton23                         128  0x00000080 (const ??? 0)  (usage 3)
iWinbutton24                         129  0x00000081 (const ??? 0)  (usage 3)
iWinbutton26                         134  0x00000086 (const ??? 0)  (usage 3)
iWinbutton27                         135  0x00000087 (const ??? 0)  (usage 3)
iWinbutton28                         138  0x0000008a (const ??? 0)  (usage 3)
iWinbutton29                         143  0x0000008f (const ??? 0)  (usage 3)
iWinbutton3                           15  0x0000000f (const ??? 0)  (usage 3)
iWinbutton30                         144  0x00000090 (const ??? 0)  (usage 3)
iWinbutton31                         148  0x00000094 (const ??? 0)  (usage 3)
iWinbutton32                         149  0x00000095 (const ??? 0)  (usage 3)
iWinbutton33                         160  0x000000a0 (const ??? 0)  (usage 3)
iWinbutton34                         163  0x000000a3 (const ??? 0)  (usage 3)
iWinbutton35                         167  0x000000a7 (const ??? 0)  (usage 3)
iWinbutton36                         168  0x000000a8 (const ??? 0)  (usage 3)
iWinbutton37                         172  0x000000ac (const ??? 0)  (usage 3)
iWinbutton38                         173  0x000000ad (const ??? 0)  (usage 3)
iWinbutton39                         177  0x000000b1 (const ??? 0)  (usage 3)
iWinbutton4                           16  0x00000010 (const ??? 0)  (usage 3)
iWinbutton40                         178  0x000000b2 (const ??? 0)  (usage 3)
iWinbutton41                         189  0x000000bd (const ??? 0)  (usage 3)
iWinbutton42                         192  0x000000c0 (const ??? 0)  (usage 3)
iWinbutton43                         211  0x000000d3 (const ??? 0)  (usage 3)
iWinbutton44                         212  0x000000d4 (const ??? 0)  (usage 3)
iWinbutton45                          18  0x00000012 (const ??? 0)  (usage 3)
iWinbutton46                         161  0x000000a1 (const ??? 0)  (usage 3)
iWinbutton47                         190  0x000000be (const ??? 0)  (usage 3)
iWinbutton48                          52  0x00000034 (const ??? 0)  (usage 3)
iWinbutton49                          53  0x00000035 (const ??? 0)  (usage 3)
iWinbutton5                           54  0x00000036 (const ??? 0)  (usage 3)
iWinbutton50                          93  0x0000005d (const ??? 0)  (usage 3)
iWinbutton51                         217  0x000000d9 (const ??? 0)  (usage 3)
iWinbutton52                         218  0x000000da (const ??? 0)  (usage 3)
iWinbutton6                           82  0x00000052 (const ??? 0)  (usage 3)
iWinbutton7                            2  0x00000002 (const ??? 0)  (usage 3)
iWinbutton8                            3  0x00000003 (const ??? 0)  (usage 3)
iWinbutton9                           89  0x00000059 (const ??? 0)  (usage 3)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
kKeyboardKeystrokes                 3531  0x00000dcbkKeyboardKeystrokes                 3531  0x00000dcb (mem) word[1] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (usage 3)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
ledDigitsDisplay                    7366  0x00001cc6 (User func) args[3] r=0  (usage 6)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (not used)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                              -213  0xffffff2b (PmmC func) args[1] r=1  (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (usage 36)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (usage 36)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                4077  0x00000fed (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -15  0xfffffff1 (PmmC func) args[2] r=1  (not used)
MaxTotObjects                         33  0x00000021 (const dword)  (usage 6)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
MEDIA_ADDRESS_MW                      92  0x0000005c (const dword)  (not used)
MEDIA_ADDRESS_UW                      93  0x0000005d (const dword)  (not used)
media_Flush                         -118  0xffffff8a (PmmC func) args[0] r=1  (not used)
media_Image                         -117  0xffffff8b (PmmC func) args[2] r=0  (not used)
media_Init                          -119  0xffffff89 (PmmC func) args[0] r=1  (not used)
media_RdSector                      -111  0xffffff91 (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -113  0xffffff8f (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -114  0xffffff8e (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                      124  0x0000007c (const dword)  (not used)
MEDIA_SECTOR_LO                      123  0x0000007b (const dword)  (not used)
media_SetAdd                        -109  0xffffff93 (PmmC func) args[2] r=0  (not used)
media_SetSector                     -110  0xffffff92 (PmmC func) args[2] r=0  (not used)
media_Video                         -107  0xffffff95 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -108  0xffffff94 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -115  0xffffff8d (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
media_WrSector                      -112  0xffffff90 (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -217  0xffffff27 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -218  0xffffff26 (PmmC func) args[1] r=1  (not used)
mem_Compare                         -224  0xffffff20 (PmmC func) args[3] r=1  (not used)
mem_Copy                            -223  0xffffff21 (PmmC func) args[3] r=1  (not used)
mem_Free                            -220  0xffffff24 (PmmC func) args[1] r=1  (not used)
mem_Heap                            -221  0xffffff23 (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -219  0xffffff25 (PmmC func) args[2] r=1  (not used)
mem_Set                             -222  0xffffff22 (PmmC func) args[3] r=1  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -14  0xfffffff2 (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
NAK                                   21  0x00000015 (const dword)  (usage 3)
nak0                                8368  0x000020b0 (User func) args[0] r=0  (usage 24)
nAniTimers                             0  0x00000000 (const dword)  (not used)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
nInputs                              104  0x00000068 (const dword)  (usage 3)
nObjects                             219  0x000000db (const dword)  (not used)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
nStrings                              11  0x0000000b (const dword)  (usage 3)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
oDipSwitchs                         3061  0x00000bf5oDipSwitchs                         3061  0x00000bf5 (mem) word[1] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 78)
OFF                                    0  0x00000000 (const dword)  (usage 3)
oForms                              3171  0x00000c63oForms                              3171  0x00000c63 (mem) word[18] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 3)
Ofs_Digits_Digits                      2  0x00000002 (const dword)  (usage 9)
Ofs_Digits_LeadingBlanks               8  0x00000008 (const dword)  (usage 3)
Ofs_Digits_Left                        0  0x00000000 (const dword)  (usage 3)
Ofs_Digits_MinDigits                   4  0x00000004 (const dword)  (usage 3)
Ofs_Digits_Widthdigit                  6  0x00000006 (const dword)  (usage 3)
Ofs_IPD_DOWN                          16  0x00000010 (const dword)  (usage 6)
Ofs_IPD_OBJVIDX                       20  0x00000014 (const dword)  (usage 9)
Ofs_IPD_P1                             2  0x00000002 (const dword)  (usage 15)
Ofs_IPD_P2                             4  0x00000004 (const dword)  (usage 48)
Ofs_IPD_P3                             6  0x00000006 (const dword)  (usage 9)
Ofs_IPD_P4                             8  0x00000008 (const dword)  (usage 3)
Ofs_IPD_P5                            10  0x0000000a (const dword)  (usage 9)
Ofs_IPD_P6                            12  0x0000000c (const dword)  (usage 18)
Ofs_IPD_P7                            14  0x0000000e (const dword)  (not used)
Ofs_IPD_RELEASE                       18  0x00000012 (const dword)  (usage 9)
Ofs_String_Ansi                       22  0x00000016 (const dword)  (usage 3)
Ofs_String_BGColor                    16  0x00000010 (const dword)  (usage 6)
Ofs_String_FGColor                    14  0x0000000e (const dword)  (usage 3)
Ofs_String_FontAttribs                18  0x00000012 (const dword)  (usage 3)
Ofs_String_Form                       24  0x00000018 (const dword)  (usage 3)
Ofs_String_Size                        4  0x00000004 (const dword)  (usage 3)
Ofs_String_StartH                      0  0x00000000 (const dword)  (usage 3)
Ofs_String_StartL                      2  0x00000002 (const dword)  (usage 3)
Ofs_String_Transparent                20  0x00000014 (const dword)  (usage 3)
Ofs_String_x1                          6  0x00000006 (const dword)  (usage 12)
Ofs_String_x2                         10  0x0000000a (const dword)  (usage 9)
Ofs_String_y1                          8  0x00000008 (const dword)  (usage 12)
Ofs_String_y2                         12  0x0000000c (const dword)  (usage 9)
oImages                             3207  0x00000c87oImages                             3207  0x00000c87 (mem) word[4] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 3)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
oldn                                 118  0x00000076 (mem) word (global)  (usage 42)
oLedDigitsn                         3535  0x00000dcfoLedDigitsn                         3535  0x00000dcf (mem) word[200] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 6)
oLeddigitss                         3215  0x00000c8foLeddigitss                         3215  0x00000c8f (mem) word[41] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 9)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (usage 3)
oObjects                              48  0x00000030 (mem) word[34] (global)  (usage 108)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
oStaticTexts                        3329  0x00000d01oStaticTexts                        3329  0x00000d01 (mem) word[84] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 3)
oStringss                           3297  0x00000ce1oStringss                           3297  0x00000ce1 (mem) word[12] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 4)
oStringss                         UNRESOLVED  (usage 2)
OT_ACTIVATE                          103  0x00000067 (const dword)  (usage 114)
OT_MAGIC                             108  0x0000006c (const dword)  (usage 3)
OT_NEXTFRAME                         104  0x00000068 (const dword)  (usage 3)
OT_NEXTSTRING                        106  0x0000006a (const dword)  (usage 3)
OT_PREVFRAME                         105  0x00000069 (const dword)  (usage 3)
OT_PREVSTRING                        107  0x0000006b (const dword)  (usage 3)
OT_REPORT                            100  0x00000064 (const dword)  (usage 48)
OT_SETANOTHER                        102  0x00000066 (const dword)  (usage 3)
OT_SETCONST                          101  0x00000065 (const dword)  (usage 3)
oUserleds                           3321  0x00000cf9oUserleds                           3321  0x00000cf9 (mem) word[4] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 3)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OUTPUT                                 0  0x00000000 (const dword)  (not used)
OutputCS                             376  0x00000178 (mem) word (global)  (usage 9)
OVF                                  -21  0xffffffeb (PmmC func) args[0] r=1  (usage 3)
oWinButtons                         3063  0x00000bf7oWinButtons                         3063  0x00000bf7 (mem) word[54] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (usage 12)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (not used)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 6)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
PICASO                                 1  0x00000001 (const dword)  (usage 3)
PICASO_FUNCTIONS                       0  0x00000000 (const ??? 0)  (not used)
pin_HI                               -42  0xffffffd6 (PmmC func) args[1] r=1  (not used)
pin_LO                               -43  0xffffffd5 (PmmC func) args[1] r=1  (not used)
pin_Read                             -44  0xffffffd4 (PmmC func) args[1] r=1  (not used)
pin_Set                              -41  0xffffffd7 (PmmC func) args[2] r=1  (not used)
PINK                               65049  0x0000fe19 (const dword)  (not used)
pInputIndex                          132  0x00000084 (mem) word (global)  (usage 15)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -12  0xfffffff4 (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
PrintStrings                        8401  0x000020d1 (User func) args[3] r=0  (usage 9)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (usage 6)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (usage 3)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 6)
RAND                                 -19  0xffffffed (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
READ_OBJ                               0  0x00000000 (const dword)  (usage 3)
READ_PAGE                             34  0x00000022 (const dword)  (not used)
ReadCmd                              128  0x00000080 (const dword)  (not used)
ReadObject                          8117  0x00001fb5 (User func) args[2] r=0  (usage 3)
RED                                63488  0x0000f800 (const dword)  (not used)
REPORT_EVENT                           7  0x00000007 (const dword)  (usage 3)
REPORT_MAGIC_EVENT_BYTES              10  0x0000000a (const dword)  (not used)
REPORT_MAGIC_EVENT_DBYTES             11  0x0000000b (const dword)  (not used)
REPORT_OBJ                             5  0x00000005 (const dword)  (usage 3)
reserved                            -294  0xfffffeda (PmmC func) args[0] r=0  (not used)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
rKeyboardRoutines                   3533  0x00000dcdrKeyboardRoutines                   3533  0x00000dcd (mem) word[1] (member of G:\Mi unidad\EEABB\TFG\Prototip\Codi\LCD\4D Workshop\1.6\Prototip.4DWork\Prototip.4DGenieS)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RUNFLASH                             128  0x00000080 (const dword)  (usage 3)
RXMODE_0                               0  0x00000000 (const dword)  (not used)
RXMODE_1                               1  0x00000001 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SCREEN_MODE                           23  0x00000017 (const dword)  (not used)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -20  0xffffffec (PmmC func) args[1] r=0  (not used)
SELECT                                 3  0x00000003 (const dword)  (not used)
SELECT_MULTIPLE                        4  0x00000004 (const dword)  (not used)
SendReport                          8303  0x0000206f (User func) args[4] r=0  (usage 6)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (usage 3)
serin1                              -140  0xffffff74 (PmmC func) args[0] r=1  (not used)
serinX                               N/A         N/A (macro) serin   (not used)
serout                                -3  0xfffffffd (PmmC func) args[1] r=0  (usage 21)
serout1                             -141  0xffffff73 (PmmC func) args[1] r=0  (not used)
seroutCS                            8383  0x000020bf (User func) args[1] r=0  (usage 15)
seroutOcs                           8353  0x000020a1 (User func) args[0] r=0  (usage 3)
seroutX                              N/A         N/A (macro) serout   (not used)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (not used)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -17  0xffffffef (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (not used)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -258  0xfffffefe (PmmC func) args[1] r=0  (not used)
snd_Continue                        -261  0xfffffefb (PmmC func) args[0] r=0  (not used)
snd_Pause                           -260  0xfffffefc (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -257  0xfffffeff (PmmC func) args[1] r=1  (not used)
snd_Playing                         -262  0xfffffefa (PmmC func) args[0] r=1  (not used)
snd_Stop                            -259  0xfffffefd (PmmC func) args[0] r=0  (not used)
snd_Volume                          -256  0xffffff00 (PmmC func) args[1] r=0  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
spi_Disable                         -153  0xffffff67 (PmmC func) args[0] r=0  (not used)
SPI_FAST                               0  0x00000000 (const dword)  (not used)
spi_Init                            -150  0xffffff6a (PmmC func) args[3] r=0  (not used)
SPI_MED                                1  0x00000001 (const dword)  (not used)
spi_Read                            -151  0xffffff69 (PmmC func) args[0] r=1  (not used)
SPI_SLOW                               2  0x00000002 (const dword)  (not used)
spi_Write                           -152  0xffffff68 (PmmC func) args[1] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -22  0xffffffea (PmmC func) args[1] r=1  (not used)
SSD1963_ENTER_IDLE_MODE               57  0x00000039 (const dword)  (not used)
SSD1963_ENTER_INVERT_MODE             33  0x00000021 (const dword)  (not used)
SSD1963_ENTER_NORMAL_MODE             19  0x00000013 (const dword)  (not used)
SSD1963_ENTER_PARTIAL_MODE            18  0x00000012 (const dword)  (not used)
SSD1963_ENTER_SLEEP_MODE              16  0x00000010 (const dword)  (not used)
SSD1963_EXIT_IDLE_MODE                56  0x00000038 (const dword)  (not used)
SSD1963_EXIT_INVERT_MODE              32  0x00000020 (const dword)  (not used)
SSD1963_EXIT_SLEEP_MODE               17  0x00000011 (const dword)  (not used)
SSD1963_GET_ADDRESS_MODE              11  0x0000000b (const dword)  (not used)
SSD1963_GET_DBC_CONF                 209  0x000000d1 (const dword)  (not used)
SSD1963_GET_DBC_TH                   213  0x000000d5 (const dword)  (not used)
SSD1963_GET_DISPLAY_MODE              13  0x0000000d (const dword)  (not used)
SSD1963_GET_GPIO0_ROP                201  0x000000c9 (const dword)  (not used)
SSD1963_GET_GPIO1_ROP                203  0x000000cb (const dword)  (not used)
SSD1963_GET_GPIO2_ROP                205  0x000000cd (const dword)  (not used)
SSD1963_GET_GPIO3_ROP                207  0x000000cf (const dword)  (not used)
SSD1963_GET_GPIO_CONFIG              185  0x000000b9 (const dword)  (not used)
SSD1963_GET_GPIO_STATUS              187  0x000000bb (const dword)  (not used)
SSD1963_GET_HORZ_PERIOD              181  0x000000b5 (const dword)  (not used)
SSD1963_GET_LCD_GEN0                 192  0x000000c0 (const dword)  (not used)
SSD1963_GET_LCD_GEN1                 194  0x000000c2 (const dword)  (not used)
SSD1963_GET_LCD_GEN2                 196  0x000000c4 (const dword)  (not used)
SSD1963_GET_LCD_GEN3                 198  0x000000c6 (const dword)  (not used)
SSD1963_GET_LCD_MODE                 177  0x000000b1 (const dword)  (not used)
SSD1963_GET_LSHIFT_FREQ              231  0x000000e7 (const dword)  (not used)
SSD1963_GET_PIXEL_DATA_INTERFACE     241  0x000000f1 (const dword)  (not used)
SSD1963_GET_PLL_MN                   227  0x000000e3 (const dword)  (not used)
SSD1963_GET_PLL_STATUS               228  0x000000e4 (const dword)  (not used)
SSD1963_GET_POST_PROC                189  0x000000bd (const dword)  (not used)
SSD1963_GET_POWER_MODE                10  0x0000000a (const dword)  (not used)
SSD1963_GET_PWM_CONFIG               191  0x000000bf (const dword)  (not used)
SSD1963_GET_SCANLINE                  69  0x00000045 (const dword)  (not used)
SSD1963_GET_TEAR_EFFECT_STATUS        14  0x0000000e (const dword)  (not used)
SSD1963_GET_VERT_PERIOD              183  0x000000b7 (const dword)  (not used)
SSD1963_NOP                            0  0x00000000 (const dword)  (not used)
SSD1963_READ_DDB                     161  0x000000a1 (const dword)  (not used)
SSD1963_READ_MEMORY_CONTINUE          62  0x0000003e (const dword)  (not used)
SSD1963_READ_MEMORY_START             46  0x0000002e (const dword)  (not used)
SSD1963_SET_ADDRESS_MODE              54  0x00000036 (const dword)  (not used)
SSD1963_SET_COLUMN_ADDRESS            42  0x0000002a (const dword)  (not used)
SSD1963_SET_DBC_CONF                 208  0x000000d0 (const dword)  (not used)
SSD1963_SET_DBC_TH                   212  0x000000d4 (const dword)  (not used)
SSD1963_SET_DEEP_SLEEP               229  0x000000e5 (const dword)  (not used)
SSD1963_SET_DISPLAY_OFF               40  0x00000028 (const dword)  (not used)
SSD1963_SET_DISPLAY_ON                41  0x00000029 (const dword)  (not used)
SSD1963_SET_GAMMA_CURVE               38  0x00000026 (const dword)  (not used)
SSD1963_SET_GPIO0_ROP                200  0x000000c8 (const dword)  (not used)
SSD1963_SET_GPIO1_ROP                202  0x000000ca (const dword)  (not used)
SSD1963_SET_GPIO2_ROP                204  0x000000cc (const dword)  (not used)
SSD1963_SET_GPIO3_ROP                206  0x000000ce (const dword)  (not used)
SSD1963_SET_GPIO_CONFIG              184  0x000000b8 (const dword)  (not used)
SSD1963_SET_GPIO_VALUE               186  0x000000ba (const dword)  (not used)
SSD1963_SET_HORZ_PERIOD              180  0x000000b4 (const dword)  (not used)
SSD1963_SET_LCD_GEN0                 193  0x000000c1 (const dword)  (not used)
SSD1963_SET_LCD_GEN1                 195  0x000000c3 (const dword)  (not used)
SSD1963_SET_LCD_GEN2                 197  0x000000c5 (const dword)  (not used)
SSD1963_SET_LCD_GEN3                 199  0x000000c7 (const dword)  (not used)
SSD1963_SET_LCD_MODE                 176  0x000000b0 (const dword)  (not used)
SSD1963_SET_LSHIFT_FREQ              230  0x000000e6 (const dword)  (not used)
SSD1963_SET_PAGE_ADDRESS              43  0x0000002b (const dword)  (not used)
SSD1963_SET_PARTIAL_AREA              48  0x00000030 (const dword)  (not used)
SSD1963_SET_PLL                      224  0x000000e0 (const dword)  (not used)
SSD1963_SET_PLL_MN                   226  0x000000e2 (const dword)  (not used)
SSD1963_SET_POST_PROC                188  0x000000bc (const dword)  (not used)
SSD1963_SET_PWM_CONFIG               190  0x000000be (const dword)  (not used)
SSD1963_SET_REAR_ON                   53  0x00000035 (const dword)  (not used)
SSD1963_SET_SCROLL_AREA               51  0x00000033 (const dword)  (not used)
SSD1963_SET_SCROLL_START              55  0x00000037 (const dword)  (not used)
SSD1963_SET_TEAR_OFF                  52  0x00000034 (const dword)  (not used)
SSD1963_SET_TEAR_SCANLINE             68  0x00000044 (const dword)  (not used)
SSD1963_SET_VERT_PERIOD              182  0x000000b6 (const dword)  (not used)
SSD1963_SOFT_RESET                     1  0x00000001 (const dword)  (not used)
SSD1963_WRITE_MEMORY_CONTINUE         60  0x0000003c (const dword)  (not used)
SSD1963_WRITE_MEMORY_START            44  0x0000002c (const dword)  (not used)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
str_Cat                             -278  0xfffffeea (PmmC func) args[2] r=1  (not used)
str_CatN                            -279  0xfffffee9 (PmmC func) args[3] r=1  (not used)
str_Copy                            -287  0xfffffee1 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -288  0xfffffee0 (PmmC func) args[3] r=1  (not used)
str_Find                            -274  0xfffffeee (PmmC func) args[2] r=1  (not used)
str_FindI                           -275  0xfffffeed (PmmC func) args[2] r=1  (not used)
str_GetByte                         -268  0xfffffef4 (PmmC func) args[1] r=1  (usage 3)
str_GetC                            -267  0xfffffef5 (PmmC func) args[2] r=1  (not used)
str_GetD                            -264  0xfffffef8 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -266  0xfffffef6 (PmmC func) args[2] r=1  (not used)
str_GetW                            -265  0xfffffef7 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -269  0xfffffef3 (PmmC func) args[1] r=1  (not used)
str_Length                          -276  0xfffffeec (PmmC func) args[1] r=1  (not used)
str_Match                           -272  0xfffffef0 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -273  0xfffffeef (PmmC func) args[2] r=1  (not used)
str_Printf                          -277  0xfffffeeb (PmmC func) args[2] r=1  (not used)
str_Ptr                             -263  0xfffffef9 (PmmC func) args[1] r=1  (usage 3)
str_PutByte                         -270  0xfffffef2 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -271  0xfffffef1 (PmmC func) args[2] r=0  (not used)
strheight                           -161  0xffffff5f (PmmC func) args[0] r=1  (not used)
Strings0Count                          0  0x00000000 (const dword)  (not used)
Strings0Size                           1  0x00000001 (const dword)  (usage 3)
Strings0StartH                         0  0x00000000 (const dword)  (usage 3)
Strings0StartL                      1024  0x00000400 (const dword)  (usage 3)
Strings10Count                         0  0x00000000 (const dword)  (not used)
Strings10Size                          1  0x00000001 (const dword)  (usage 3)
Strings10StartH                        0  0x00000000 (const dword)  (usage 3)
Strings10StartL                      512  0x00000200 (const dword)  (usage 3)
Strings1Count                          0  0x00000000 (const dword)  (not used)
Strings1Size                           1  0x00000001 (const dword)  (usage 3)
Strings1StartH                         0  0x00000000 (const dword)  (usage 3)
Strings1StartL                      1536  0x00000600 (const dword)  (usage 3)
Strings2Count                          0  0x00000000 (const dword)  (not used)
Strings2Size                           1  0x00000001 (const dword)  (usage 3)
Strings2StartH                         0  0x00000000 (const dword)  (usage 3)
Strings2StartL                      4096  0x00001000 (const dword)  (usage 3)
Strings3Count                          0  0x00000000 (const dword)  (not used)
Strings3Size                           1  0x00000001 (const dword)  (usage 3)
Strings3StartH                         0  0x00000000 (const dword)  (usage 3)
Strings3StartL                      4608  0x00001200 (const dword)  (usage 3)
Strings4Count                          0  0x00000000 (const dword)  (not used)
Strings4Size                           1  0x00000001 (const dword)  (usage 3)
Strings4StartH                         0  0x00000000 (const dword)  (usage 3)
Strings4StartL                      2560  0x00000a00 (const dword)  (usage 3)
Strings5Count                          0  0x00000000 (const dword)  (not used)
Strings5Size                           1  0x00000001 (const dword)  (usage 3)
Strings5StartH                         0  0x00000000 (const dword)  (usage 3)
Strings5StartL                      3072  0x00000c00 (const dword)  (usage 3)
Strings6Count                          0  0x00000000 (const dword)  (not used)
Strings6Size                           1  0x00000001 (const dword)  (usage 3)
Strings6StartH                         0  0x00000000 (const dword)  (usage 3)
Strings6StartL                      3584  0x00000e00 (const dword)  (usage 3)
Strings7Count                          0  0x00000000 (const dword)  (not used)
Strings7Size                           1  0x00000001 (const dword)  (usage 3)
Strings7StartH                         0  0x00000000 (const dword)  (usage 3)
Strings7StartL                      2048  0x00000800 (const dword)  (usage 3)
Strings8Count                          0  0x00000000 (const dword)  (not used)
Strings8Size                           1  0x00000001 (const dword)  (usage 3)
Strings8StartH                         0  0x00000000 (const dword)  (usage 3)
Strings8StartL                         0  0x00000000 (const dword)  (usage 3)
Strings9Size                           0  0x00000000 (const dword)  (not used)
Strings9StartH                         0  0x00000000 (const dword)  (not used)
Strings9StartL                         0  0x00000000 (const dword)  (not used)
stringsCV                             24  0x00000018 (mem) word[11] (global)  (usage 27)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                            -160  0xffffff60 (PmmC func) args[1] r=1  (not used)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
sys_DeepSleep                       -295  0xfffffed9 (PmmC func) args[1] r=1  (not used)
sys_EventQueue                      -194  0xffffff3e (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -195  0xffffff3d (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -196  0xffffff3c (PmmC func) args[0] r=0  (usage 3)
sys_GetTimer                        -192  0xffffff40 (PmmC func) args[1] r=1  (not used)
sys_SetTimer                        -191  0xffffff41 (PmmC func) args[2] r=0  (not used)
sys_SetTimerEvent                   -193  0xffffff3f (PmmC func) args[2] r=1  (not used)
sys_Sleep                           -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -280  0xfffffee8 (PmmC func) args[0] r=1  (not used)
sys_T                               -189  0xffffff43 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -190  0xffffff42 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
t4Dbutton                             30  0x0000001e (const dword)  (usage 15)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
tAngularmeter                          7  0x00000007 (const dword)  (usage 3)
tAniButton                            31  0x0000001f (const dword)  (usage 6)
tColorPicker                          32  0x00000020 (const dword)  (usage 3)
tCoolgauge                             8  0x00000008 (const dword)  (usage 3)
tCustomdigits                          9  0x00000009 (const dword)  (usage 6)
tDipSwitch                             0  0x00000000 (const dword)  (usage 3)
TEAL                                1040  0x00000410 (const dword)  (usage 3)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
tForm                                 10  0x0000000a (const dword)  (usage 15)
tGauge                                11  0x0000000b (const dword)  (usage 3)
tGSlider                               4  0x00000004 (const dword)  (usage 3)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
tImage                                12  0x0000000c (const dword)  (usage 3)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (not used)
TIMER2                                 2  0x00000002 (const dword)  (not used)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
tKeyboard                             13  0x0000000d (const dword)  (usage 3)
tKnob                                  1  0x00000001 (const dword)  (usage 3)
tLed                                  14  0x0000000e (const dword)  (usage 3)
tLeddigits                            15  0x0000000f (const dword)  (usage 12)
tMagicObject                          34  0x00000022 (const dword)  (not used)
tMeter                                16  0x00000010 (const dword)  (usage 3)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (usage 3)
tolower                             -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -199  0xffffff39 (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_DRIVE                           78  0x0000004e (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -201  0xffffff37 (PmmC func) args[1] r=1  (usage 9)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 3)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 3)
TOUCH_MOVING                           3  0x00000003 (const dword)  (usage 3)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 9)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (usage 18)
touch_Set                           -200  0xffffff38 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
TouchState                           128  0x00000080 (mem) word (global)  (usage 24)
TouchXpos                            122  0x0000007a (mem) word (global)  (usage 12)
TouchYpos                            124  0x0000007c (mem) word (global)  (usage 9)
toupper                             -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
tPinInput                             29  0x0000001d (const dword)  (usage 6)
tPinOutput                            28  0x0000001c (const dword)  (usage 6)
translate                             -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (usage 3)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
tRockerSwitch                          2  0x00000002 (const dword)  (usage 3)
tRotarySwitch                          3  0x00000003 (const dword)  (usage 3)
tScope                                25  0x00000019 (const dword)  (not used)
tSounds                               22  0x00000016 (const dword)  (usage 6)
tSpectrum                             24  0x00000018 (const dword)  (usage 3)
tStaticText                           21  0x00000015 (const dword)  (usage 3)
tStrings                              17  0x00000011 (const dword)  (usage 18)
tTank                                 26  0x0000001a (const dword)  (usage 3)
tThermometer                          18  0x00000012 (const dword)  (usage 3)
tTimer                                23  0x00000017 (const dword)  (usage 6)
tTrackbar                              5  0x00000005 (const dword)  (usage 3)
TurnOffButtons                      7662  0x00001dee (User func) args[1] r=0  (usage 6)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
tUserButton                           33  0x00000021 (const dword)  (usage 9)
tUserImages                           27  0x0000001b (const dword)  (usage 3)
tUserled                              19  0x00000013 (const dword)  (usage 3)
tVideo                                20  0x00000014 (const dword)  (usage 3)
tWinButton                             6  0x00000006 (const dword)  (usage 174)
txt_Attributes                       -38  0xffffffda (PmmC func) args[1] r=1  (usage 3)
txt_BGcolour                         -26  0xffffffe6 (PmmC func) args[1] r=1  (usage 3)
txt_Bold                             -34  0xffffffde (PmmC func) args[1] r=1  (not used)
txt_Delay                            -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -25  0xffffffe7 (PmmC func) args[1] r=1  (usage 3)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontID                           -27  0xffffffe5 (PmmC func) args[1] r=1  (usage 3)
txt_Height                           -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
txt_Italic                           -35  0xffffffdd (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -23  0xffffffe9 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -33  0xffffffdf (PmmC func) args[1] r=1  (usage 3)
txt_Set                              -24  0xffffffe8 (PmmC func) args[2] r=0  (not used)
txt_Underline                        -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
txt_Width                            -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
uadd_3232                           -290  0xfffffede (PmmC func) args[3] r=1  (usage 3)
ucmp_3232                           -292  0xfffffedc (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
uLCD_43PT_GFX2                         0  0x00000000 (const ??? 0)  (not used)
umul_1616                           -289  0xfffffedf (PmmC func) args[3] r=1  (usage 3)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                        -281  0xfffffee7 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
UpdateObjects                       6389  0x000018f5 (User func) args[1] r=0  (usage 3)
USER_INITIALIZED_DISPLAY              32  0x00000020 (const dword)  (not used)
usub_3232                           -291  0xfffffedd (PmmC func) args[3] r=1  (not used)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
WHEAT                              63222  0x0000f6f6 (const dword)  (not used)
WHITE                              65535  0x0000ffff (const dword)  (usage 66)
WHITESMOKE                         63422  0x0000f7be (const dword)  (not used)
WRITE_CONTRAST                         4  0x00000004 (const dword)  (usage 3)
WRITE_MAGIC_BYTES                      8  0x00000008 (const dword)  (not used)
WRITE_MAGIC_DBYTES                     9  0x00000009 (const dword)  (not used)
WRITE_OBJ                              1  0x00000001 (const dword)  (usage 3)
WRITE_PAGE                            35  0x00000023 (const dword)  (not used)
WRITE_STR                              2  0x00000002 (const dword)  (usage 6)
WRITE_STRU                             3  0x00000003 (const dword)  (usage 6)
WriteCmd                               0  0x00000000 (const dword)  (not used)
WriteObject                         7785  0x00001e69 (User func) args[3] r=0  (usage 24)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (usage 18)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
